<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Home on Zee Tsui</title>
    <link>/</link>
    <description>Recent content in Home on Zee Tsui</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 18 Jun 2023 00:00:00 +0000</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>在汽车发明之前设计安全带？——我对 AGI 的思考</title>
      <link>/temp/20230618-%E5%9C%A8%E6%B1%BD%E8%BD%A6%E5%8F%91%E6%98%8E%E4%B9%8B%E5%89%8D%E8%AE%BE%E8%AE%A1%E5%AE%89%E5%85%A8%E5%B8%A6%E6%88%91%E5%AF%B9-ai-%E7%9A%84%E6%80%9D%E8%80%83/</link>
      <pubDate>Sun, 18 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>/temp/20230618-%E5%9C%A8%E6%B1%BD%E8%BD%A6%E5%8F%91%E6%98%8E%E4%B9%8B%E5%89%8D%E8%AE%BE%E8%AE%A1%E5%AE%89%E5%85%A8%E5%B8%A6%E6%88%91%E5%AF%B9-ai-%E7%9A%84%E6%80%9D%E8%80%83/</guid>
      <description>最近的一些大新闻 网友言论 我的看法 尾巴 </description>
    </item>
    
    <item>
      <title>基于 syncthing 的云盘容器搭建方案（发现 &#43; 中继 &#43; 同步）</title>
      <link>/posts/2023/20230315-%E5%9F%BA%E4%BA%8E-syncthing-%E7%9A%84%E4%BA%91%E7%9B%98%E6%96%B9%E6%A1%88%E5%8F%91%E7%8E%B0-&#43;-%E4%B8%AD%E7%BB%A7-&#43;-%E5%90%8C%E6%AD%A5/</link>
      <pubDate>Wed, 15 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>/posts/2023/20230315-%E5%9F%BA%E4%BA%8E-syncthing-%E7%9A%84%E4%BA%91%E7%9B%98%E6%96%B9%E6%A1%88%E5%8F%91%E7%8E%B0-&#43;-%E4%B8%AD%E7%BB%A7-&#43;-%E5%90%8C%E6%AD%A5/</guid>
      <description>最近因为个人的需求，需要搭建一个独立并且能够与 OneDrive 互通的一个网盘，用来代替同步全平台设备之间的文件。经过短暂的探索之后，我使用 Syncthing 完成了个人的最佳实践。
此搭建方案中的流程并没有严格从 0 开始阐述，所以部分内容可能需要一定的 docker 和命令行基础。
整体结构 Syncthing 本身做的是多端的设备文件同步，设备间掉线或者断开连接就会失去同步，这和传统意义上的云盘有些不同。由于我们需要实现的是云盘场景，所以自然需要在结构配置上满足一些基本特性。
基本特性 一直在线：所以我们需要存在一台长期在线的机器作为中间设备，让其他设备实时同步文件； 跨系统：这一点 Syncthing 已经提供了几乎全平台的客户端，所以基本不需要我们做什么，按照平台下载软件即可； 暴露公网：此处方案就比较多样了，公网服务器的话可以直接搭建，本地可以通过 Nginx 反向代理 + FRP 实现公网暴露。 安全性 &amp;amp; 私密性：Syncthing 提供的发现服务和中继服务默认会暴露公网，变成公共服务吃池的一部分；所以如果完全个人使用需要的话，需要额外进行配置。 此时整体流程就清晰了起来：我们需要搭建一套 Syncthing 服务 + 中继 + 发现 一体的服务端当成实时在线的中心节点，并且部署在公网上；然后其他需要同步文件的设备（比如手机、笔记本、平板）只需安装 syncthing 的本体，然后将中继和远程设备配置到服务端，正常与服务端进行同步即可。
这样虽然比其他的 Syncthing 同步方案稍显复杂，但是可以通过中心节点来避免设备下线就断开同步的问题，做到设备下线也不影响文件的同步。
具体搭建操作 搭建操作主要围绕着上文提到的服务端，我们需要搭建。Syncthing 的主程序 syncthing、发现服务 stdiscov 和中继服务 strelay 都提供了容器化的解决方案，所以可以通过容器很方便地进行部署。
拉取容器 首先通过一下命令拉取所需的三个容器：
docker pull syncthing/syncthing docker pull syncthing/relaysrv docker pull syncthing/discosrv 命令行启动参数 因为个人单独写了一套类 Kubernetes 的单机配置方案，最终所有配置都会转化为命令行；如果有 docker-compose 相关的需要，可以直接通过命令行的参数进行等价转换。
Syncthing docker run --rm -dit --name=syncthing \ -u $(id -u):$(id -g) \ # 设置容器内用户权限 --link relayserver --link discoverserver \ # 网桥搭桥，保证容器内能与 relay 和 disov 正常通信 -p &amp;lt;port&amp;gt;:8384 -p &amp;lt;port&amp;gt;:22000 \ # 8384 是前端页面端口，22000 是服务发现端口 -v &amp;lt;path_to_syncthing_config&amp;gt;:/var/syncthing/config \ # syncthing 配置文件路径映射 -v &amp;lt;path_to_syncthing_Sync&amp;gt;:/var/syncthing/Sync \ # syncthing 默认同步文件夹路径映射 syncthing/syncthing 如果基于本方案，那么流量会全部走 relay 中继，22000 可不用暴露公网使用。</description>
    </item>
    
    <item>
      <title>2022 年度总结</title>
      <link>/posts/2023/20230129-2022-%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 29 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>/posts/2023/20230129-2022-%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</guid>
      <description>以前的年度总结都是在家里面边过着节边慢慢磨出来的，这一次就趁着年前来简单总结一下自己的 2022 吧（其实最后还是因为事情多，从年前写到了年后）。
完全不一样的一年 今年算是走出学校踏上工作岗位后真正的完整一年，走出象牙塔一段时间，感觉自己能够在社会上立足了；所以从年初开始，没被社会暴打过的我至少还是呆着一些兴奋在的。
一些文章会说，毕业后由于工作繁忙加上大家各奔东西，人的社交圈子就会急速减小，在我身上也确实是这样。交际方面，因为平日工作的繁忙，朋友间除了平常网上的闲聊和寒暄之外便没有了更多的交集；父母虽然会聊得更频繁，但碍于地理上的距离也难得在小长假聚一次。人嘛，最终还是渐渐活成了一个人的样子。不过这种孤独并不是蹲在孤独的角落，然后自己冷冷地看着远处与自己无关而热闹的街；它更像是热闹聚会中的 break，让人能够感到片刻的放松和平静，却也不会因此脱离与他人的联系。
我是一个社会阅历及其不足的人——借用同事的话就是 “性格好到让人觉着好欺负”，容易在很多地方被当做 “老实人” 来坑——阅历的缺乏也确实让我暴露出很多的缺陷。我常常事后才会意识到这是一个问题，但也好在从长远来看它暴露地够早，也让我真正深刻地触及到了这个社会的阴晴不定，不挨打就不知道疼。
棱角总是要挨磨的，稚气总是要褪去的。工作上的压力、生活上的不适应、自己人生路上的短暂迷茫——一个个问题不经商量地全数涌现眼前，但这当然都会过去；起身抹去眼泪，黑暗是黎明的序曲，摔倒是奔跑的间奏。
总的来说，这一年突出的就是一个字 “惨”（🐶），惨出个一日千里，惨出个恍如隔世。
以前的目标？ 这是在写 2022 年度总结之前就盘算着的一个部分，我也十分好奇自己的以往定下来的目标，到现在这样一个时间节点时完成了多少。
但事实上，我自己很少立 flag。因为每一个完成的 flag 都得是理所当然，而每一个未完成的 flag 会在未来的每时每刻——像倒计时映在汪淼眼里那样——让 “到底是没时间，还是没能力？” 的质疑横架在我的身上。对于有强烈信念的人来说，这就是鞭策；但是对于像我这样 今年事明年毕 的人来说，这包袱还是有些过重了。
翻了翻以前的总结类博客文章，也确实一如既往地更着重于一年的总结。未来的一年我希望自己能够在技术上的基础更加沉稳一些，然后一步步地把小目标完成下去。明年这个时候再回顾，也不至于只是感慨。
疫情之下 突然的放开让沿海城市（特别是广东）首当其冲，以前是零星几个小区阳性，现在是整个城市都阳了。这一次放开的迅速显然是迫于压力的结果，短时间内就出现了资源挤兑，包括但不限于药物、消毒物品等；外卖在疫情高峰的两周里，也出现了没有骑手小哥和配送费上涨的情形；快递节奏变得十分奇怪，两件物品从同一个地方同一个快递发出，酒精之类的物品就一定能够在中间的站点卡住，比其他的物品晚一两周才送到。疫情下也只有京东顺丰保持着稳定的时效，属实是当代布里吉斯。
我很早在上海那一波的时候，就提醒父母别老光逮着中医信、提早准备一些布洛芬备用、那些连花清瘟颗粒都没啥效果。不过父母买药方面似乎还是有他们的一套理解，不过日常消毒和卫生倒是很充足，起到了有效防范。
大概是过敏性鼻炎的原因，我在羊窝里蹦跶着幸存了下来，直到现在。期间酒精和药物都屯了一些，虽然我屯了超过一人份的药物（n &amp;gt; 1 &amp;amp;&amp;amp; n &amp;lt; 2），但都是家里寄的连花清瘟颗粒，布洛芬一颗没有。所以某种意义上来说，倒也是没有造成药物挤兑或者资源浪费，我的罪恶感也少了些许。
疫情下，还是身体最重要。
这一年买的好物 这一年没有买啥好东西，添了一台便携的 Matebook E Go（可见之前的文章），然后做了常规的数码设备迭代。今年初购置了计划很久的一套 NAS（QNAP T-416） + NUC（零刻 N5105）解决方案，并且为此填了近一个月的坑去搭建一些基础设施，把所有的服务从服务器拉到了本地，现在勉强好用了一些。后续有空的话，会把这段时间遇到的坑给总结一下，记录到博客里。
这一年的游戏 &amp;amp; 电影 貌似整体的 PC 游戏行业都没有什么我感兴趣大作，很多游戏也都不约而同地跳票到了 2023 年或以后，属实是被 COVID 摧残麻了。
今年大部分游戏时间都献给了原神和 CSGO 之类的快速游戏，确实工作之后就极少有大块的时间来玩游戏了。2023 年会推出挺多，比如 The Last of US: PART I、Pragmata 等，就先期待一波（并许愿能有空玩游戏）。</description>
    </item>
    
    <item>
      <title>Kubernetes 开源容器平台结构简介</title>
      <link>/posts/2023/20230125-kubernetes-%E5%BC%80%E6%BA%90%E5%AE%B9%E5%99%A8%E5%B9%B3%E5%8F%B0%E7%BB%93%E6%9E%84%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Wed, 25 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>/posts/2023/20230125-kubernetes-%E5%BC%80%E6%BA%90%E5%AE%B9%E5%99%A8%E5%B9%B3%E5%8F%B0%E7%BB%93%E6%9E%84%E7%AE%80%E4%BB%8B/</guid>
      <description>经典结构图 containerd &amp;amp; kubernetes &amp;amp; runc 角色分工和层级 Kubernetes：部署容器的平台，属于最上层与用户交互的角色。
主要承担的功能：负责集群成员管理，以及自动化的 Pod 的调度维护。 containerd：容器平台（Docker、Kubernetes）的低一层，底层运行时（runc、kata）的高一层，属于中间负责 Pod 级别管理的角色。
主要承担的功能：镜像管理（镜像导入导出删除）、容器管理（容器创建删除停止），文件系统的快照管理。 runc：底层运行时，属于直接与底层操作系统交互的角色；类似的 runtime 还有 kata、Firecracker、gVisor 等，用于不同的操作系统平台且遵循 OCI 规范。
主要承担的功能：根据镜像配置，使用系统提供的 cgroups 之类的资源隔离组件，为不同的容器创建运行环境，然后调起 endpoint。 containerd 和 kubernetes 都通过 systemd 维护进程，二者之间通过 gRPC 进行通信（遵循 OCI 规范）
containerd 和 runc 是直接通过进程调用的方式进行交互和绑定。大白话就是 containerd 为每个容器开了一个 shim 进程；然后 shim 进程拼了一个 runc 命令跑容器，并作为主进程接管所有的 runc 僵尸进程，然后监控容器的状态。
从 kubernetes 到 runc 的流程 kuberlet 通过 gRPC 向 containerd 发送命令调用 以前是 kuberlet 调用 CRI-containerd，然后 CRI-containerd 再调用 contaienrd；后来 cri 直接作为一个插件集成进了 containerd，调用链缩短为了 kubelet -&amp;gt; containerd -&amp;gt; runc 源码也可以看到，cri 现在在 containerd 的内部是作为插件进行加载的。 containerd 收到请求，创建 containerd-shim 实例 containerd-shim 实例才会真正操作容器，负责管理一个容器的整个声明周期，并且对其状态进行监控和上报；容器进程需要一个父进程来做状态收集、维持 stdin 等 fd 打开等工作，假如这个父进程就是 containerd，那如果 containerd 挂掉的话，整个宿主机上所有的容器都得退出了，引入 containerd-shim 可以规避这个问题。 创建 shim 进程（通过 runtime/shim 的 newInit() 初始化） newInit() 中会调用 process.</description>
    </item>
    
    <item>
      <title>containerd 默认配置参数解析</title>
      <link>/posts/2023/20230123-containerd-%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Mon, 23 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>/posts/2023/20230123-containerd-%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90/</guid>
      <description>该配置文件的所有配置项，都会加载到 Config 结构体中（坐标：services/server/config/config.go）。
该文档可以配合 containerd 服务加载流程对照使用。
TOML 快速入门，可见博客文章 TOML 配置格式详解 disabled_plugins = [] # 禁用的插件名列表 imports = [] # 导入其他的 toml 配置并应用（import 的 toml 配置文件 version 参数不能大于此 toml 配置） oom_score = 0 # containerd 主进程的 OOM Score（/proc/&amp;lt;pid&amp;gt;/oom_score_adj），范围 -1000 到 1000，OOM Killer 会根据该值回收进程 # 可见 https://learning-kernel.readthedocs.io/en/latest/mem-management.html plugin_dir = &amp;#34;&amp;#34; # 插件的路径 required_plugins = [] # 需要引入的插件名列表 root = &amp;#34;/var/lib/containerd&amp;#34; # containerd 的根目录，用来保存持久化数据，包括 Snapshots, Content, Metadata 以及各种插件的数据，每一个插件都有自己单独的目录 # 默认所有的 container 文件都会存于该路径下 # containerd 所有功能都来自于已加载的插件 state = &amp;#34;/run/containerd&amp;#34; # containerd 的状态目录 temp = &amp;#34;&amp;#34; version = 2 # toml 配置文件的版本 [cgroup] # Linux cgroup 的定制化参数（与创建 container 相关） path = &amp;#34;&amp;#34; # 指定 cgroup 的路径，默认 &amp;#34;&amp;#34; 值则会找默认的 cgroup [debug] # 配置 containerd socket 连接的 debug 监听端口，一般生产环境用不到 address = &amp;#34;&amp;#34; # socket 地址，默认 &amp;#34;&amp;#34; 值则会找 /run/containerd/debug.</description>
    </item>
    
    <item>
      <title>contaienrd 简介及安装运行</title>
      <link>/posts/2023/20230121-contaienrd-%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Sat, 21 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>/posts/2023/20230121-contaienrd-%E7%AE%80%E4%BB%8B/</guid>
      <description>一、什么是 containerd Containerd 是一个工业级标准的容器运行时，它强调简单性、健壮性和可移植性。Containerd 可以在宿主机中管理完整的容器生命周期，核心功能有：
管理容器的生命周期(从创建容器到销毁容器) 拉取/推送容器镜像 存储管理(管理镜像及容器数据的存储) 调用 runC 运行容器(与 runC 等容器运行时交互) 管理容器网络接口及网络 二、安装并运行 containerd 官网安装步骤 从官网下载 containerd-&amp;lt;VERSION&amp;gt;-&amp;lt;OS&amp;gt;-&amp;lt;ARCH&amp;gt;.tar.gz 包，并解压到 /usr/local 目录：
$ tar Cxzvf /usr/local containerd-1.6.2-linux-amd64.tar.gz bin/ bin/containerd-shim-runc-v2 bin/containerd-shim bin/ctr bin/containerd-shim-runc-v1 bin/containerd bin/containerd-stress 可以使用 systemd 启动 containerd 服务，从 https://raw.githubusercontent.com/containerd/containerd/main/containerd.service 下载 containerd.service 并放置到 /usr/local/lib/systemd/system/containerd.service，使用如下命令运行：
systemctl daemon-reload systemctl enable --now containerd containerd 运行依赖 runc，可以从 https://github.com/containernetworking/plugins/releases 下载 cni-plugins-&amp;lt;OS&amp;gt;-&amp;lt;ARCH&amp;gt;-&amp;lt;VERSION&amp;gt;.tgz 包，并把 runc 文件放置到 /usr/local/sbin/runc 路径下：
$ install -m 755 runc.amd64 /usr/local/sbin/runc 三、containerd 上下游生态 北向：containerd通过实现Kubernetes的CRI（容器运行时接口）接口与Kubernetes进行交互</description>
    </item>
    
    <item>
      <title>或许 WoA 才是移动办公最优解——Matebook E Go 使用体验</title>
      <link>/posts/2022/20221217-%E6%88%96%E8%AE%B8-woa-%E6%89%8D%E6%98%AF%E7%A7%BB%E5%8A%A8%E5%8A%9E%E5%85%AC%E6%9C%80%E4%BC%98%E8%A7%A3matebook-e-go-%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C/</link>
      <pubDate>Sat, 17 Dec 2022 00:00:00 +0000</pubDate>
      
      <guid>/posts/2022/20221217-%E6%88%96%E8%AE%B8-woa-%E6%89%8D%E6%98%AF%E7%A7%BB%E5%8A%A8%E5%8A%9E%E5%85%AC%E6%9C%80%E4%BC%98%E8%A7%A3matebook-e-go-%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C/</guid>
      <description>为什么是 Matebook E Go？ 以前我是一个坚定的 All in One 拥趸，践行着通过一台设备来取满足全部需求的思路。但无奈现实中的 All in One 就意味着傻大黑粗，还有 All in Boom 一炸全炸；哪怕出门只需要做一些轻度办公，也不得不带上沉重的游戏本和电源适配器。使用体验极差，唯独锻炼效果极佳。
所以，在最近的疫情期间，我 闲得没事儿干 一直想通过分布式的设备来满足我大部分的需求。典型场景就只有两种 —— 一个是高性能 + 低便携场景，跑跑模型、玩一玩大型游戏，或者是开几个 IDE + VSCode 去做一些重量级的代码项目；另一个是这篇博客主要讨论的低性能 + 高便携场景，比如公共场合使用电脑进行事务处理，不需要流畅跑 3A 大作，跑十几个 Chromium 应用以及基本的编译构建就行了（毕竟在图书馆或者咖啡厅打游戏就挺朋克的，属实没啥必要）。
因为我是一个比较依赖于高自由度系统的用户，所以 Macbook Air 这样的设备就不太合适了；我最开始的选择是 Surface Pro 9，但考虑到微软糟糕的售后，以及我曾经不太好的 Surface Pro 使用及售后体验，我最终还是选择了定位相近且配置体验大差不差的设备 —— Matebook E Go。
个人使用场景 首先说一下我的态度：目前不建议把任何 WoA 设备作为主力机，第二台电脑才是最适合它的角色。并且在选择 WoA 设备前，最好还是排查一下自己使用的软件或者环境有没有架构不兼容的情况。
从个人的使用角度去看：
日常 80% 的事务都用不到高性能；浏览信息、处理文档和写代码，只要兼容性足够，性能差的副作用最多就是编译慢一些，不存在基本功能的缺失； 另外的 20% 中，除了玩游戏以外，大部分也都可以推到远程处理，有一个高性能的主机作为 backend 就能完美解决。 所以如果经常出门，那么很显然续航会是 TOP1 的考虑参数，其次是便携性，最后才是性能和外观。目前 ARM 架构带来的续航优势就十分明显，并且个人的使用场景不存在架构不兼容。
适合做什么 适合出门（误）。作为电脑它适合做一些基本的办公（现在大部分基础的办公套件都能够正常使用了），然后还有基本的娱乐（刷网页、看视频、玩一些小游戏）；作为平板，可以作为 Windows 平板，也可以装安卓应用当台安卓平板。</description>
    </item>
    
    <item>
      <title>我的桌面简介 1.0</title>
      <link>/posts/2022/20221130-%E6%88%91%E7%9A%84%E6%A1%8C%E9%9D%A2%E7%AE%80%E4%BB%8B-1.0/</link>
      <pubDate>Wed, 30 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>/posts/2022/20221130-%E6%88%91%E7%9A%84%E6%A1%8C%E9%9D%A2%E7%AE%80%E4%BB%8B-1.0/</guid>
      <description>最近一直在规划未来 5 ~ 10 年的桌面方案（包括主机、键盘、桌面配件等），所以想去整一个系列的博客文章，来记录自己的桌面以及设备一步一步的进化历程；可能将来再回过头来看这段时间的版本迭代，也会是一段有意义的回忆记录。
桌面一览 这就是我的桌面 1.0 版本全景，主要的设备就是电脑和平板。
可以看出来书桌上物件的结构非常简陋简单，最初在搭建的时候完全没有考虑美感，纯粹是把自己已有的设备尽量合理地堆在一个小小的桌面平台上。
目前从需求的角度来考虑，这已经足够我 90% 的日常使用场景了，一些使用上的不便基本可以靠“多走两步”来解决。一桌一扇一抚尺，打打游戏敲敲代码还是很合适的。当然，从图中可以很明显看出来桌面略显局促，但凡再加一个其他的设备就会施展不开。后续我会尝试升级到一个更大的桌面，最好是带升降功能，以提供一个可以站立的工作环境，保护颈椎。
桌面设备 显示器：红米 RMMNT27NU（4K 60Hz） 平时我在书桌上会打游戏 + 写代码 + 做图 + 摄影，所以个人对于显示器的基本要求就是 4K，并且色彩空间要全，色偏不能太大；帧率、HDR 这些特性对我来说不是刚需，存不存在实际上都没有太大的影响，当然多多益善。
之前我买了一款蚂蚁电竞的 27 英寸 4K 144Hz 的电竞显示器，想着能够在打游戏上也尽量获得一个不错的体验。但是实际在收到手后发现了比较多的问题，首先是整个显示器的架子太大了，完全体直接占掉了桌子 2/3 的纵向空间，加个键盘就没法放手了；除此之外，屏幕离眼睛极近，试着打了几把游戏还有不同程度的掉帧（可能是 3060 的锅？）。
感谢京东的 7 天无理由退换货，我最后直接把需求降了一档入手了红米的这款显示器，除了帧率之外没啥缺点，桌面的空间也大了好多。
笔记本：魔霸新锐 2021（5900HX + RTX3060 140W） 这台笔记本是在去年的双十一入手的，9799 的高价接盘，买后两个月京东怒降 ￥1000；还好我属于刚需用户，降价对我来说感知不是很强烈，只是略显肉疼。自带的 512GB 系统盘对于游戏党来说是绝对不够的，华硕也很贴心地留了扩展位，我给它加了一块 1TB 的西数固态（虽然还是不够用，直接顶满了都）。
桌搭方面，我平时就把它直接卡在显示屏下面，顺带也能挡住显示器的底座，看起来更和谐。图片里面看着斜，是因为我想提高一下散热效率，所以直接用两个瓶盖顶在了下面（瓶盖 yyds）。
打 FPS 游戏时 144Hz 是刚需，所以时常还是会抽出来用自带的 240Hz 显示器打游戏。其他像原神、大表哥 2 这类的游戏就直接上大显示器，对帧率不敏感，4K 的观感也更好。
鼠标：罗技 G102 鼠标用的是经典 G102，属于老设备了，从大二用到现在（中间坏了一个）。使用体验上面没什么可说的，就是来自老牌大厂的稳和体验一致性。后面我会考虑换成逻辑 G304 无线鼠标，这样桌面上也能少一根线。</description>
    </item>
    
    <item>
      <title>数据库操作命令速查</title>
      <link>/posts/2022/20220109-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5/</link>
      <pubDate>Sun, 09 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>/posts/2022/20220109-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5/</guid>
      <description>增 insert into man (id, name, age) value (1, &amp;#39;jack&amp;#39;, 27) # 按照结构插入数据 insert man values (4, &amp;#39;a&amp;#39;, 1), (5, &amp;#39;b&amp;#39;, null) # 插入多条数据 删 delete form man delete * form man # 删除整张表 delete from man where id = 2 # 删除表中的指定数据 truncate man #不可逆删除 改 update man set id = 2 where name = &amp;#39;jack&amp;#39; # 更新 man 表中为 jack 的数据，将 id 改为 2 update man set age = 30 where id = 5 or id = 4 # 更新 man 表中 id 为 4 或 5 的数据，将 age 改为 30 查 desc man # 看 man 表的数据格式 desc bus.</description>
    </item>
    
    <item>
      <title>2021 年度总结</title>
      <link>/posts/2022/20220102-2021-%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 02 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>/posts/2022/20220102-2021-%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</guid>
      <description>疫情反复 在 2020 年末的时候，我与许多人一样期盼着 2021 年疫情能够进一步控制下去。可现实似乎没有出现什么好转，甚至在临近年末还诞生了 Omicron 这样传播力更强的变种。病毒变异的速度之快，足以让西方认识到群体免疫、与病毒共存是不可取的暴论。
就这样在疫情的笼罩之下过了两年，我不觉已经习惯了出门带上口罩，手机健康码不离身，附近发生疫情而管制的时候更甚。如今疫情真的是常态化了，今年可能还会维持着这样的状态，也不知道这朵盘旋在人类上空的阴霾何时才会消去。
挥别本科时光 年初趁着寒假没有什么事儿我把剩下的驾考完成了，拿到了驾照。为了练手，我在家长陪同下开了许久的市路和高速，这里还需要感谢一下当年发明了自动挡的工程师们，让开车变成了一项并不复杂的操作。
去年的年初到中旬，毕业的迷惘和繁忙的事物让我笼罩在低落和沉稳的情绪之下。不得不说，双学位让我在毕业时节更加忙碌了，需要赶着完成两个学科跨度很大的毕设和答辩，同时兼顾着处理比赛以及零零碎碎的毕业事务。当初报上双学位为的就是更宽广的发展空间，可毕业之后才发现，第二个学位带来的 buff 加成寥寥，虽说不是如虎添翼，但至少也不虚此行了。
说来也十分离谱，大学四年的活动范围基本上只有校园及周围的五百米，直到大四有了些闲时，才得以四处走走熟悉周遭；而真正熟悉了这片地方之后，却不得已又要离开它了。
六月份，我从学校正式毕业了，一次少有准备的绝妙经历。正如我再日志里面写过的那样——我们大学苦学四年就是为了这一刻，可真正毕业时，却又不觉怀念起它。学校里是纯粹的，这种纯粹不仅是在朋友关系上，还有生活节奏的秩序井然。我如今感觉最为深刻的便是毕业之后，由于身份转变所带来的割裂感——这就像是爬上了一座山顶后，面前横驻着更高的一层坎，但来都来了，这么高的山也上了，你只能继续去爬。
当毕业的最后一天，我与同乡一齐收拾完行李，登上最后一趟回家的车，望向窗外——那些以往我根本不回去在意的景色和人，如今却如同烈酒一般猛扎入我的心中。想哭却又没什么好哭的，维持着一种想念却不留恋的平衡。
毕竟我现在还留在宿舍微信群看学弟唠嗑抱怨，可得劲了（逃
朋友们 聚是一团火，散是满天星。出乎我意料的是，同学朋友们大多都开始了读研的生活，远远大于工作的人数；出国的出国，工作的工作，甚至还有人在毕业后就结婚了。走出校园后，大家各奔前程，都有美好的未来。
比赛和项目 今年只有一个大学收官比赛——复微杯电子设计大赛。由于时间问题，这个比赛的跨度达到了一个月，我与一个朋友以软硬件进行分割来分别实现。从最开始拿到命题的分析并阅读论文，找数据集并造出所需的数据，验证基线网络并改进实现以达到性能和FPGA利用率的平衡，到最后调参 finetune 出 acc 最高的模型。我在其中完整地实现了整个流程，并在最终达到了 100% 的比赛测试集准确度（本地 validation acc 为 97%）。
去年相较于之前着手的项目少了一些。首先是 oneline，由于这是一个完全由“比赛驱动开发”的库，所以今年也只有神经网络训练模块和 tool 模块的优化改进——现在可以快速搭建网络并部署训练，同时开放了网络遍历的接口来方便监视或者额外的数据运算。然后便是一些处于学习目的练习性项目，比如 TinySTL 等，再此按下不表。
玩过的游戏 去年玩（看）了很多的游戏，如死亡搁浅、赛博朋克 2077、荒野大镖客 2 等。感谢 EPIC 在年末的 10 美元优惠大促，让我能够提前办年货，玩到了更多的 3A 大作，希望明年多来点。如今大厂游戏的视觉画面早已大同小异，更多的只是风格化的区别，因此我会更加关心玩法和剧情上的差异。
一整年中，我最喜欢的就是死亡搁浅（虽然这是 2019 年发售的游戏）。最早我是在朋友家将它当电影看的（同时我也认为死亡搁浅更像电影）——虽然没有了操作的临场感，但剧情上更加连贯沉浸——越看越入迷，体验极佳。小岛秀夫在剧情中对于死亡和神学的探讨让我印象深刻，其中大量充斥着生死轮回之类的佛家思想，属实很让我印象深刻。以后有时间我想单独写一下对死亡搁浅故事的理解。
赛博朋克 2077 是我今年买过最后悔的游戏，我从来没有在其他任何一个游戏中遇见过这么多的 bug，集中体现在死板的剧情路线，死板到但凡脱离一点路线，就会发现各式各样的 bug——比如有的人没有碰撞体积，剧情中的任务载具路线全部写死，各种穿模，站在线路上就会被撞一跤。赛博朋克这个大 IP 其实有充足的的素材和思路去填充游戏的，但波兰蠢驴就是没有做好，没得洗；鉴于波兰蠢驴承诺今年一定会做好，还是希望能够好好完善吧。
一句话评价，我作为一个赛博朋克题材的拥趸，戴着这么厚的滤镜也没能接受这款游戏的糟糕体验。
荒野大镖客 2 是年末和赛博朋克 2077 一块在 EPIC 上买的，45 RMB 能够买到这种质量的大作可以说是无敌了，特别是与 79 RMB 的 2077 放在一起更显得实惠。这个画面在 1080P 的屏幕上画质能够开到全高，如同电影一般，动作和交互细节满分。由于年末彩钢库歘就，剧情还没过完就不多做评论了。</description>
    </item>
    
    <item>
      <title>MRO、装饰器的调用顺序——Python 中需要注意的细节</title>
      <link>/posts/2021/20211227-mro%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8Fpython-%E4%B8%AD%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%BB%86%E8%8A%82/</link>
      <pubDate>Mon, 27 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/2021/20211227-mro%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8Fpython-%E4%B8%AD%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%BB%86%E8%8A%82/</guid>
      <description>1. 重载运算符的调用顺序 class Foo: def __init__(self, name): self._name = name def __str__(self): return self._name def __eq__(self, other): return other is self class Bar(Foo): def __eq__(self, other): return str(self) == str(other) class Foo1: def __init__(self, name): self._name = name def __str__(self): return self._name def __eq__(self, other): return str(self) == str(other) foo = Foo(&amp;#34;Hello&amp;#34;) bar = Bar(&amp;#34;Hello&amp;#34;) foo1 = Foo1(&amp;#34;Hello&amp;#34;) print(foo == bar) # True, 调用了 bar 的 __eq__ print(bar == foo) # True, 调用了 bar 的 __eq__ print(foo == foo1) # False, 调用了 foo 的 __eq__ print(foo1 == foo) # True, 调用了 foo1 的 __eq__ Python 中，如果 == 符号两端变量属于具有继承关系的类，则会优先调用子类的重载方法；如果 == 符号两端变量分别属于两个完全不同的类，则会调用左端类的重载进行判断（见代码中print部分的后两个）</description>
    </item>
    
    <item>
      <title>XML 转 JSON 的 TypeScript 简易实现</title>
      <link>/posts/2021/20211003-xml-%E8%BD%AC-json-%E7%9A%84-typescript-%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Sun, 03 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/2021/20211003-xml-%E8%BD%AC-json-%E7%9A%84-typescript-%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0/</guid>
      <description>为什么重复写脚本？ 最近在参与的一个 TypeScript 项目上出现了一个功能，即通过读取 xml 文件的属性信息来检查特定的动作是否执行完成。当然作为一名合格的模块战士，最好的方式就是用第三方库来解析 xml 文件，但作为一个折腾玩家，自己实现的功能才更加具有可控性。
json 相较于 xml 更加通用和方便，虽然 npm 上已经有 sax 这个开源库提供现成的 xml 解析方案了，但这些方案由于需要兼容很多“阴间” xml 样例，不得已会存在很多匹配上的的冗余代码。因此，考虑到项目中的 xml 并不存在特殊格式，所以可以简化很多步骤，在执行速度以及体积大小上会存在一定的优势。
方案简要 这一次的算法实现，我并没有过多地考虑性能优化——这并不只是因为我偷懒——主要还是先实现一个可用的 Demo 为主。xml 的内容解析类似于文本分析，所以在实现时很自然地就往递归遍历想了，简单粗暴，效果拔群。具体思路就是正确找出标签的开头位置和结尾位置进行解析，然后中间的内容递归到下一层进行匹配解析。
从这个角度出发，要解决的问题就分为了三个：标签文本拆分，json 对象构建，内容解析。
标签文本拆分 xml 始终以 &amp;lt;&amp;gt; 为标签进行内容分割，夹着子文本和子标签。所以如果要正确进行后续的匹配，只需要按照 &amp;lt;&amp;gt; 标记进行内容上的分割即可，然后将生成的字符串列表交给下一层进行处理。最终的实现效果是这样的：
源文本： &amp;#34; &amp;lt;/param&amp;gt; Hello World!&amp;lt;a&amp;gt;test&amp;lt;/a&amp;gt;Cest la vie &amp;lt;/param&amp;gt;&amp;#34; // 使用 .trim() 去除两边多余的空格回车 目标字符串列表： [ &amp;#34;&amp;lt;/param&amp;gt;&amp;#34;, &amp;#34;Hello World!&amp;#34;, &amp;#34;&amp;lt;a&amp;gt;&amp;#34;, &amp;#34;test&amp;#34;, &amp;#34;&amp;lt;/a&amp;gt;&amp;#34;, &amp;#34;Cest la vie&amp;#34;, &amp;#34;&amp;lt;/param&amp;gt;&amp;#34; ] 这样便可以方便得按照标签为单位进行处理了，这一部分在实现上没有考虑太多，直接新开辟了一个容器（再次偷懒），然后双指针遍历一遍匹配 &amp;lt;&amp;gt; 存入内存即可。后续再根据该列表的内容以及对应的规则进行 json 对象构建和参数匹配。
json 对象构建 内容解析部分需要根据 xml 的文本内容来构建 json 结构。首先是捣鼓这个结构到底长啥样，不仅需要具有通用性，而且不能够丢失原文本的信息（能够反向还原回去）。</description>
    </item>
    
    <item>
      <title>【算法笔记】动态规划 &amp; 最长公共子序列</title>
      <link>/posts/2021/20210604-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</link>
      <pubDate>Fri, 04 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/2021/20210604-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</guid>
      <description>突然发现自己有很长一段时间没有学习和更新算法相关的内容了。当然这并不完全是因为懒，主要还是临近毕业事务较多没能顾得上，做题的也感觉生分了许多。
什么是最长公共子序列（LCS, Longest Common Sequence） 关于 LCS 网络上有两种不同的含义，一个是“最长公共字符串（Longest Common String）”，一个是“最长公共子序列（Longest Commo Sequence）”。二者存在一定的差别，本文单独就后者进行相关的讨论。
最长公共子序列是动态规划中的一个经典的问题，即给定序列 A 和序列 B，然后求出两个序列中最大的公共子序列的长度，且该公共子序列中的元素可以不相邻。这类型的题目如果使用暴力解法一般都会直接顶满指数级的 $O(n^2)$ 复杂度，因此一般都会使用动态规划的写法来求解。
问题解法 LeetCode 上的对应题目见【1143. 最长公共子序列】。
首先介绍一下常规的暴力解法，直接通过递归来遍历所有可能的情况。代码如下：
def lcs(s1, s2): if s1 == &amp;#34;&amp;#34; or s2 == &amp;#34;&amp;#34;: return 0 elif s1[-1] == s2[-1]: return lcs(s1[:-1], s2[:-1])+1 else: return max(lcs(s1, s2[:-1]), lcs(s1[:-1], s2)) 这一写法显然存在着不足，即递归的部分会大量的重复，从而导致时间上的开销过大。因此，我们引入动态规划算法并建立矩阵进行相关数据的存储。假设两个字符串分别为 text1 和 text2，并定义dp[i][j] 为 text1 在 [0, i] 范围内的子串和 text2 在 [0, j] 范围内的子串的最长公共子序列。
状态转移：如果 text1[i-1]==text2[j-1]，那么说明我们找到了公共子串中的一个字符，则 dp[i][j] = dp[i-1][j-1] + 1；否则，如果 text1[i-1]!</description>
    </item>
    
    <item>
      <title>【瞎扯 4】苹果新品发布会 | 平板笔记本会不会合并？</title>
      <link>/posts/2021/20210501-%E7%9E%8E%E6%89%AF-4%E8%8B%B9%E6%9E%9C%E6%96%B0%E5%93%81%E5%8F%91%E5%B8%83%E4%BC%9A-_-%E5%B9%B3%E6%9D%BF%E7%AC%94%E8%AE%B0%E6%9C%AC%E4%BC%9A%E4%B8%8D%E4%BC%9A%E5%90%88%E5%B9%B6/</link>
      <pubDate>Sat, 01 May 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/2021/20210501-%E7%9E%8E%E6%89%AF-4%E8%8B%B9%E6%9E%9C%E6%96%B0%E5%93%81%E5%8F%91%E5%B8%83%E4%BC%9A-_-%E5%B9%B3%E6%9D%BF%E7%AC%94%E8%AE%B0%E6%9C%AC%E4%BC%9A%E4%B8%8D%E4%BC%9A%E5%90%88%E5%B9%B6/</guid>
      <description>最近在科技圈最为热门的就是苹果的新品发布会了，这次主要发布了以下几件产品，下面来展开介绍，顺便阐释一下自己的观点。
紫色 iPhone 12/12 mini &amp;amp; Apple TV 4K 一个是因为市场表现而进行的颜色更新，一个是常规的升级迭代，这里就不过多赘述了。
iPad Pro iPad Pro 的升级可以说来了一记重锤——把地表最强 ARM 芯片 M1 直接下放到了平板上，让平板这一级别的设备也有了桌面端的强大算力。不过考虑到 M1 芯片就是以前 A 系列的换名升级（可能是为了突出统一的硬件环境）然后添加了片载内存和提高了性能等，所以这一操作并不会太出人意料，就是感觉有点早。
目前的缺陷肯定有，因为平板的电源管理比较激进，M1 肯定不能像 MBP 那样 43W 满载运行，所以性能肯定是会差上一截的。另外，最拉胯的毫无疑问就是 iPadOS 系统，这个系统真的乏善可陈——娱乐体验顶天但生产力不足——甚至我觉得这个系统就应该改名为爱奇艺系统（狗头）。软件环境以及系统特色的桎梏让目前的 iPad 生产力只能满足轻度的文字处理、视频剪辑、美术绘画等工作，而软件开发、重度视频处理、科学分析建模之类的就几乎没有用武之地。
但这并不意味着我就是在唱衰 iPad 了，因为 M1 让硬件环境实现了统一，这就意味着将来 MacOS 上运行的（ARM 或者 Rossetta 转译）工具都能够在平板上正常运行。不过，正如 MKBHD 所说的那样，最好还是别因为将来可能出现的软件生态而去盲目超前购买这类硬件。毕竟现在苹果的 ARM 生态还算不上完整、bug 也十分多，如果为了生产力还是老老实实用上自己熟悉的硬件环境吧（尤其是理工科）。
新款 iMac 新款的 iMac 厚度已经与日常常见的显示屏无异，再也不用在发布会上侧着放了（笑）。有人吐槽它的下巴还是和以前的一样厚，但我觉得苹果也是有合理性在的。一个是为了保持以前的 ID 设计——如果没了下巴，那么正面辨识度就不会像现在的设计那般明显了。第二个原因就是为了缩减厚度而做的妥协，毕竟外置电源都整出来了，可见苹果对厚度设计上的要求。把元器件全部堆叠在屏幕后方其实也十分合理，但是可能就没有现在来得那么惊艳。“有传承感”这样的出发点在苹果身上也是十分常见的，因此我更倾向于前者。
AirTag 防丢追踪器 AirTag 简直就是在背后摆了 Tile 一道，一样的功能和实现方式加上了苹果官方的 Buff 后可以说直接断掉了 Tile 的后路。哪怕苹果并没有和 Tile 竞争的欲望，但强大的生态体系和 builtin 的舒适的体验绝对会让绝大部分的 Tile 用户倒戈——除非 AirTag 翻车。</description>
    </item>
    
    <item>
      <title>【算法笔记】布隆过滤器</title>
      <link>/posts/2021/20210428-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</link>
      <pubDate>Wed, 28 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/2021/20210428-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</guid>
      <description>话不多说，这次直接切入主题，介绍一种牺牲准确性的哈希加速方法——布隆过滤器。这种数据结构及其算法原理较为简单，所以内容不会过于复杂。
什么是布隆过滤器（Bloom Filter） 布隆过滤器（英语：Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。
上面是来自维基百科的介绍，详情可见布隆过滤器 - 维基百科。
说白了，布隆过滤器就类似与 set() 的操作，可以用于匹配特定键是否在集合之中。其原理也很简单，就是使用了多个哈希函数对键进行哈希得出多个值，然后将内存中对应位置设置为 1，如下图所示（来源见水印）：
当我们有一个 obj1 和 obj2 时，首先用 3 个 Hash 函数进行哈希得出对应的地址，然后依次设为 1，即可实现写入布隆过滤器的过程。
归纳一下具体的算法步骤：
初始化 k 个 Hash 函数，同时保证其能够分别哈希到不同的内存位置； 初始化一个长度为 n 比特的数组（bitarray/bitmap），每个位都设置为 0； 加入 key 时，先散列出 k 个地址，并将该位置的数据设置为 1； 查找 key 时，同样散列出 k 个地址，然后查询内存对应的内存位置，若全为 1 可认为在集合中，若有 0 则一定不在集合中。 该算法的缺点十分明显，因为位置存在重复性，所以不能够进行删除操作；同时，由于查询出来的内存位置此时可能已经有了其他的键 Hash 出来的 1，所以全为 1 的时候存在一定的误判率——当然，有 0 就已经可以证明该键并没有经过哈希了，不会发生误判。
这时候相信很多人会有一个疑问：为什么不用直接用哈希表呢？正常情况下，为了保证哈希表 $O(1)$ 的复杂度以及防止哈希冲突，哈希表的存储效率通常在 50% 以下，这就意味着哈希表往往都会较大，而布隆过滤器不用存键值，而且更加“紧凑”，所以可以在相对于小的内存里提供较好的查找性能。但代价就是存在一定的误判率，业务中也需要进行该方面的考量。
当数据量较小的时候，直接使用哈希表便可以优雅地解决问题了；此时使用布隆过滤器反而还需要承担额外不必要的错误率，得不偿失。
常用场景 实际的应用场景中，布隆过滤器广泛地应用于网页黑名单系统、垃圾邮件过滤系统、网页 URL 去重、垃圾邮件识别、大集合中重复元素的判断和缓存穿透等。下面是一些详细的场景：
数据库防止穿库。 Google Bigtable，HBase 和 Cassandra 以及 Postgresql 使用BloomFilter来减少不存在的行或列的磁盘查找。避免代价高昂的磁盘查找会大大提高数据库查询操作的性能。 业务场景中判断用户是否阅读过某视频或文章，比如抖音或头条，当然会导致一定的误判，但不会让用户看到重复的内容。 缓存宕机、缓存击穿场景，一般判断用户是否在缓存中，如果在则直接返回结果，不在则查询db，如果来一波冷数据，会导致缓存大量击穿，造成雪崩效应，这时候可以用布隆过滤器当缓存的索引，只有在布隆过滤器中，才去查询缓存，如果没查询到，则穿透到db。如果不在布隆器中，则直接返回。 WEB拦截器，如果相同请求则拦截，防止重复被攻击。用户第一次请求，将请求参数放入布隆过滤器中，当第二次请求时，先判断请求参数是否被布隆过滤器命中。可以提高缓存命中率。Squid 网页代理缓存服务器在 cache digests 中就使用了布隆过滤器。Google Chrome浏览器使用了布隆过滤器加速安全浏览服务 Venti 文档存储系统也采用布隆过滤器来检测先前存储的数据。 SPIN 模型检测器也使用布隆过滤器在大规模验证问题时跟踪可达状态空间。 （摘自愚公要移山的答案）</description>
    </item>
    
    <item>
      <title>用 Python 实现一个可自动识别的文件夹单向同步功能</title>
      <link>/posts/2021/20210327-%E7%94%A8-python-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8F%AF%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9%E5%8D%95%E5%90%91%E5%90%8C%E6%AD%A5%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Sat, 27 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/2021/20210327-%E7%94%A8-python-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8F%AF%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9%E5%8D%95%E5%90%91%E5%90%8C%E6%AD%A5%E5%8A%9F%E8%83%BD/</guid>
      <description>写在前面：这是我对类 unison 这样猝发式同步工具的一种复现尝试；因为我平时主要就是在一个文件夹内进行操作，所以算法更为简单，并没有实现针对单个文件进行处理的双向同步。 我如今已经使用了更为高效易用的 FreeFileSync 去进行文件同步和备份操作，该程序已经归档。
为什么我想写这个算法 在日常生活以及学习中，文件夹同步这一操作自然是必不可少的，一个方便使用的文件同步软件可以很好的对这种进行操作。通过我以前的文章可以了解到，我之前一直都在使用 Unison 来进行本地以及 WSL 不同的文件夹间的同步。而后来由于自己的问题，更换电脑后，由于 Unison 麻烦的配置以及自己对于文件夹同步的想法，我还是想尝试自己写一个文件夹同步的算法。
文件夹同步的方式有两种，一种是 rsync 那样的单向同步，一种是 Unison 一样的双向同步（Unison 也是基于 rsync 的）；当然我更需要的是双向的，所以这就不由得涉及到了很多的同步问题，最后我还是改成实现一个自动识别主文件夹的单向同步，这同样也可以达到双向同步的效果。
算法细节 算法很简单，总共分为两个层面。首先是同步的工具，我直接使用了 rsync 来进行传输的操作，然后同步两个或多个文件夹即可；第二个部分就是判断哪个文件夹为同步的主文件夹，这一部分使用了文件的时间戳作为指纹保存，在同步之后，如果有与保存的指纹不同，则可判定其做了修改，即新文件夹。
时间戳生成算法 def timeset(path, data: dict, prefix: str): source = os.getcwd() path_list = os.listdir(path) os.chdir(path) for n in path_list: if os.path.isfile(n): if n != &amp;#39;syncing.json&amp;#39;: data[os.path.join(prefix, n)] = int(os.path.getmtime(n)) else: timeset(n, data, os.path.join(prefix, n)) os.chdir(source) return data 而如果在数据中没有指纹，则两个文件夹为新文件夹，此时直接取时间戳最大的文件夹。在判断完哪一个文件夹为同步的主文件夹之后，直接进行 rsync 同步即可。
算法源码 当然，为了保证该脚本的可用性，文件地址判定以及信息确认之类的都采用了严谨的写法，从而保证不会出现错误。
def sync_folder_local(*args, main=None): # WARNING: This function only works correctly with single-folder editing # It would have a bug occured when multi folders were edited database = load_json(f&amp;#39;{ os.</description>
    </item>
    
    <item>
      <title>【算法笔记】基于用户投票的排序算法</title>
      <link>/posts/2021/20210224-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E5%9F%BA%E4%BA%8E%E7%94%A8%E6%88%B7%E6%8A%95%E7%A5%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</link>
      <pubDate>Wed, 24 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/2021/20210224-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E5%9F%BA%E4%BA%8E%E7%94%A8%E6%88%B7%E6%8A%95%E7%A5%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</guid>
      <description>这是一篇拖了很久的文章，其实很早之前便想把它写出来，但无奈只能拖到了现在。希望现在趁着还有些闲心，可以把以前记录过的坑全给填齐了。
基于用户投票的排序算法十分多样，不同社交平台的机制（点赞，点踩，热度等）会基于不同变量的排序算法。为了保证算法的普遍适用性，文章仅对一般的基于用户投票的算法模型进行介绍，全文使用“主题”作为排序的元素。
牛顿冷却算法 这是一个常用的基于时间和投票的排序算法，使用了指数式衰减的牛顿冷却公式为基础。其最为直观的结果就是投票高且时间较近的主题的排名会更为靠前，然后随着时间的增加，该主题便会“冷却”，排名逐渐降低。
公式如下：
$$T&amp;rsquo;(t)=-\alpha(T(t)-H)$$
$T(t)$：温度 $T$ 的时间 $t$ 的函数 $T&amp;rsquo;(t)$：温度 $T$ 的时间 $t$ 的导数 $H$ 代表室温，$T(t)-H$ 就是当前温度与室温之间的温差 常数 $\alpha(\alpha&amp;gt;0)$：室温与降温速率之间的比例关系，不同的物质有不同的 $\alpha$ 值。 基于这样的式子，我们可以进一步将其化简，得出我们最终在排序算法中所使用的式子：
$$T=T_0e^{-\alpha(t-t_0)}$$
$T$ 和 $t$：当前时刻的温度和时间 $T_0$ 和 $t_0$：之前的某一时刻的温度和时间 $\alpha$ ：冷却系数，一般根据需求计算得出，且 $\alpha$ 越大，同一时间衰减的速度越快 可以看出，牛顿冷却算法在需要考虑时间和票数两种因素的情况下，可以做一个很好的权衡。
威尔逊区间 因为“牛顿冷却算法”的指数衰减特性，其只适用于一段时间内的排序，而“威尔逊区间” 则适用于对整体的主题进行排序。
为什么需要“威尔逊区间”算法来进行排序呢，直接赞的数量减去踩的数量不好吗？这就涉及到样本空间的问题了。
假设现在有两个主题，一个有 500 赞和 450 踩，另一个有 60 赞和 0 踩，那么按照直观的解法 $60 - 0 &amp;gt; 500 - 450$，第二个放在了前面。实际上这样并不合理，因为明显第一个主题的讨论更高，这便意味着该主题的权重应该更高，更具有代表性，所以理应让第一个主题排序靠前。同理，$Score=\frac{赞成票}{总票数}$ 在有很多小样本的情况下也十分不准确。
基于这样的想法，有了下面这个太长不看的公式：
$$\frac{\bar{p}+\frac{1}{2n}z_{1-\frac{\alpha}{2}}^2\pm z_{1-\frac{\alpha}{2}}\sqrt{\frac{\bar{p}(1-\bar{p})}{n}+\frac{z_{1-\frac{\alpha}{2}}^2}{4n^2}}}{1+\frac{1}{n}z_{1-\frac{\alpha}{2}}^2}$$
$\bar{p}$：赞成票比例 $n$：样本大小 $z_{1-\frac{\alpha}{2}}$：对应某个置信水平的 $z$ 统计量（参考概率论） 通过式子我们可以看出，最大值为 $\frac{\bar{p}+\frac{1}{2n}z_{1-\frac{\alpha}{2}}^2+z_{1-\frac{\alpha}{2}}\sqrt{\frac{\bar{p}(1-\bar{p})}{n}+\frac{z_{1-\frac{\alpha}{2}}^2}{4n^2}}}{1+\frac{1}{n}z_{1-\frac{\alpha}{2}}^2}$，最小值为 $\frac{\bar{p}+\frac{1}{2n}z_{1-\frac{\alpha}{2}}^2-z_{1-\frac{\alpha}{2}}\sqrt{\frac{\bar{p}(1-\bar{p})}{n}+\frac{z_{1-\frac{\alpha}{2}}^2}{4n^2}}}{1+\frac{1}{n}z_{1-\frac{\alpha}{2}}^2}$（就是取了个正负号）。当 n 足够大时，最小值便会趋向于 $\bar{p}$，反之在样本量小时，该值便会远远小于 $\bar{p}$。这就达到了样本量大的权重更高这一要求。</description>
    </item>
    
    <item>
      <title>【算法笔记】meet-in-the-middle 算法</title>
      <link>/posts/2021/20210223-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0meet-in-the-middle-%E7%AE%97%E6%B3%95/</link>
      <pubDate>Tue, 23 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/2021/20210223-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0meet-in-the-middle-%E7%AE%97%E6%B3%95/</guid>
      <description>meet-in-the-middle 算法（又称折半搜索、双向搜索），属于一种优化的 DFS 或 BFS 算法。同分治算法近似，它将问题进行了拆分，然后进行合并归一，得出最后的结果。这样做的好处是在穷举解的时候能够对很多情况进行剪枝，降低了时间复杂度。
n &amp;lt;= 40 的搜索类型题目一般都可以优化，本质上这是一种空间换时间的算法。
穷举类的问题当匹配条件越多的时候，其时间复杂度便会越大，所以可以通过将多个条件拆分匹配的方式来减小复杂度。 简单来说，这就是“分而治之”的一种手段。
常见类型 求和 这一部分可直接见「举个例子」部分。
双向搜索 这在关系网处理和图的路径规划中经常使用，且在寻路问题中表现很好。算法会同时从两个节点开始搜索，并且看什么时候这两个搜索的边界相遇。这个可以将需要扩展的节点降低到 $O(p^{k/2})$。
2DES 破解 DES 算法为密码体制中的对称密码体制，又被称为美国数据加密标准，是 1972 年美国 IBM 公司研制的对称密码体制加密算法。明文按 64 位进行分组，密钥长 64 位，密钥事实上是 56 位参与 DES 运算（第 8、16、24、32、40、48、56、64 位是校验位， 使得每个密钥都有奇数个1），分组后的明文组和 56 位的密钥按位替代或交换的方法形成密文组的加密方法。
DES 算法如今之所以被淘汰，是因为秘钥空间太小。其密钥的 $2^{56}$ 种可能性在以前是很难穷举破解的，但如今随着算力的发展，把所有可能的秘钥遍历一遍也是可以的（参考 BTC 挖矿）。在这之后的 DES 算法便开始显得力不从心，亟待升级，于是就有了 3DES 算法——使用 3 个密钥进行 3 次 DES 加密运算。
2DES 去哪儿了？答案是 DES 算法过后直接提升到了 3DES，直接把 2DES 给跳过了。理论上来说 2DES 具有 $2^{102}$ 的秘钥空间，已足够使用，但是为什么不用呢，原因就在于 meet-in-the-middle 算法为基础的中间人攻击（Diffile-Hellman 发明）——信息论课堂上的老朋友了，在这儿只用简单的语言介绍其原理。
假设我需要通过一组 2DES 的明文与密文破解出秘钥，我并不需要遍历 $2^{102}$ 整个秘钥空间，而是使用明文枚举 $2^{56}$ 个秘钥加密，得到 $2^{56}$ 个中间值并存入哈希表；然后使用密文枚举 $2^{56}$ 个秘钥并与明文的哈希库做对比，得到的所有值中一定有一个与之前加密所得到的相等，即 $E_{ki}(p) = D_{kj}(s)$，meet-in-the-middle 结束。这整个破解过程中不难发现，只要有足够大的空间用于存储哈希表，2DES 破解密码的时间仅仅相当于破解 2 次 DES。</description>
    </item>
    
    <item>
      <title>文件夹同步工具 unison 简易指北</title>
      <link>/posts/2021/20210218-%E6%96%87%E4%BB%B6%E5%A4%B9%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7-unison-%E6%96%87%E4%BB%B6%E5%A4%B9%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7-unison-%E7%AE%80%E6%98%93%E6%8C%87%E5%8C%97/</link>
      <pubDate>Thu, 18 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/2021/20210218-%E6%96%87%E4%BB%B6%E5%A4%B9%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7-unison-%E6%96%87%E4%BB%B6%E5%A4%B9%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7-unison-%E7%AE%80%E6%98%93%E6%8C%87%E5%8C%97/</guid>
      <description>unison 是一款跨 Windows/Linux/MacOS 平台的双向文件同步工具，不仅支持本地对本地同步，也支持通过 SSH、RSH 和 Socket 等网络协议进行同步；但需要注意的是，unison 无法实现实时双向同步，仅支持猝发实时同步。
unison 安装 Linux unison 可以直接安装预编译包：sudo apt-get install unison
Others Windows、MacOS 以及其它平台和源码，都能够在官方 Github 仓库的 Release 页面下载。
两个文件夹之间双向同步文件 在两台主机之间进行文件夹同步，需要确保主机都正确安装了 unison，并部署了 ssh 服务。unison 会开启一个监听端口，使用 unison dir1 ssh://username@remotehostname(ip)//absolute/path/to/dir2 结构的命令即可进行文件同步。
注意：两个文件夹的顺序是任意的，且只能够在远程和本地、本地和本地之间进行同步，不能够对两台远程机进行操作。
本地文件夹进行同步，直接使用 unison dir1 dir2 进行同步即可。
unison 的配置选项 unison 会在用户目录创建一个 .unison 文件夹来保存相关的配置，里面一般会存有 defalut.prf 作为默认配置。在平时可以通过 unison default dir1 dir2 来选择 default 作为配置文件进行同步。除了使用配置文件外，unison 命令还可以接受如下的一些参数：
-testserver 测试连通性，连接到服务器即退出；如果服务器端 unison 可执行文件不在默认目录下，甚至没有 unison 命令（需要你编译一个上传到服务器），则需要使用 -servercmd 参数告诉要执行的服务器 unison 命令位置。 使用 -testserver 参数，则成功链接即退出，也不会去执行目录的比较等后续操作。 -auto 接受缺省的动作，然后等待用户确认是否执行。 -batch batch mode, 全自动模式，接受缺省动作，并执行。 -ignore xxx 增加 xxx 到忽略列表中 -ignorecase [true|false|default] 是否忽略文件名大小写 -follow xxx 是否支持对符号连接指向内容的同步； 例如在我的 ~/.</description>
    </item>
    
    <item>
      <title>为什么使用 Obsidian 搭建内容库</title>
      <link>/posts/2021/20210210-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-obsidian-%E6%90%AD%E5%BB%BA%E5%86%85%E5%AE%B9%E5%BA%93/</link>
      <pubDate>Wed, 10 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/2021/20210210-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-obsidian-%E6%90%AD%E5%BB%BA%E5%86%85%E5%AE%B9%E5%BA%93/</guid>
      <description>人生苦短，与其万事一把梭，不如把大量重复性高、灵活性差的工作及内容交给电脑负责。我们能够记下并熟练掌握的东西是有限的，把低频而琐碎的内容放在内容库里，用时才翻出来，省时又省力，轻松加愉快；但这样难受就难受在检索的前摇时间较长，即便优化了也不及“出口成章”般的顺畅。在日常的学习过程中，与其费心记忆冗杂而琐碎的点子，不如把重心放在处理复杂逻辑问题上，其余的交给电脑进行“冷存储”；在 Linux 编程的途中愈不断学习与深入，那些琐碎的命令和冗长的代码就让我对此的感受就愈发深刻。
OneNote 和 Notion、Wolai 所以在之前从高中开始的很长的一段时间里面，我都在使用 OneNote 或者 Notion(Wolai) 这样的笔记类应用去记录各种想法和备忘。电脑不仅有着比纸笔更加快速的记录，还让我养成了更便捷的 Review 习惯。但是后来随着自己的工具集变化和发展路线的深入，这些笔记类应用的缺点也暴露了出来。
首先是 OneNote 这一款我使用得最久的应用（即便今天我也离不开它）。功能强大检索方便，但导出、页面的美观度和数据库的通用性无法满足我的要求；即便如此，OneNote 与 Office 的高度绑定性和方便的云同步让我一直把它当作最好的第一手记录工具。
另外一个就是 Notion 这类的 All in one 的笔记类应用，由于 Notion 的网络问题，我最后还是转到了国内同类型的 Wolai。这类产品使用起来非常舒爽，网络上也有十分多的用户分享他们基于 Notion 搭建的社区和笔记等。因此一开始我也毫不意外地加入了其中，但后来随着自己记录的内容增多，网页应用自然而然出现了性能瓶颈以及一个十分关键的问题——内容所有权，应用中的数据是完全无法离线使用的。我作为一个十分在乎数据安全的人，就天然对这种纯网络应用带着一丝担忧，所以最后我还是把数据拿了出来。
说一些题外话，Wolai 的创始人——可能出于自己作为老产品经理的身份——似乎总是对于笔记类的产品有着一种与常人习惯不同的执念，这直接或间接地导致了其功能上的定价策略、以及部分功能上的设计总是带着陌生的反直觉感，比如语雀那样十分方便的基础 OCR 功能放在了会员功能中，又比如菜单页上“随便看看”和“关系图”占据了主要位置，而“新建页面”和“回收站”这类重要功能却直接收进二级菜单；早期的 Wolai 到处都充斥着类似的象牙塔似的思考（如今已有改进），况且早期的 alpha 版本还到处有着 Notion 的痕迹（源码和样式）。
尽管如此，Wolai 作为一款已经融了千万的产品，综合表现及本土化相较于 Notion 来说还是十分不错的，我也使用了很久。
Obsidian 为了找到一个适合自己的工具，我针对自己的需求，花了两天时间尝试了头部部分的主流笔记类应用，最终还是选择了 Obsidian。
当然，这并不是说 Obsidian 有多出色，它的缺点也十分明显，只不过它更加简洁的数据组织结构十分讨喜（主要还是历史遗留问题）。其他同样满足需求的还有 Logseq 和思源笔记，这两款同样是本地化存储、界面美观、支持双链、社区迭代活跃（重点）。
Obsidian 的不足 Obsidian 的不足可太多了，毕竟是一款去年才诞生的产品。（逃）
一个是网络问题，当前有一个正在 Early Bird 的付费云服务，其国外部署的服务器在国内使用可能会存在 404 问题。其实我更希望 Obsidian 能够提供一个自设同步服务的方法，不仅可以增加用户的定制化选择，也能让我们用更低的成本来搭建服务。
第二，没有手机端。官网说 coming soon，也希望能做得完善一些，不要像思源笔记那样匆匆上马，结果拉跨。
第三，没有基础的 OCR 功能。这倒不是一个特别重要的点，毕竟 OCR 可以通过外挂的方法来解决，但是能够 built-in 才是坠好的。</description>
    </item>
    
    <item>
      <title>【算法笔记】动态规划 &amp; 二分搜索法</title>
      <link>/posts/2021/20210122-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%B3%95/</link>
      <pubDate>Fri, 22 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/2021/20210122-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%B3%95/</guid>
      <description>动态规划（DP, Dynamic Programming）由于需要对问题进行抽象拆分，然后化简，因此具有一定的难度和乐趣。它属于一种算法设计的技巧，即对暴力遍历中的各种情况（重叠子问题）进行合理地剪枝，从而达到减小时间复杂度的目标。
动态规划的一般流程为：递归的暴力解法 → 带备忘录的递归解法 → 非递归的动态规划解法。也就是说，平时使用动态规划的方法来解决一个特定的问题时，并不是一蹴而就的，而是从暴力的问题出发进行一步步优化而来的。
此外，本文除了会对动态规划及其相关的应用进行阐述之外，还会介绍对动态规划问题进行优化的二分搜索法。
一个问题是该用递推、贪心、搜索还是动态规划，完全是由这个问题本身阶段间状态的转移方式决定的。
缓存、重叠子问题、记忆化 以 Fibonacci 数列为例，直接写出来的代码是这样的：
def fib(n:int) -&amp;gt; int: if n == 0: return 0 elif n == 1 or n == 2: return 1 else: return fib(n - 1) + fib(n - 2) 这是使用了递归的 Fibonacci 数列求解算法。因为是递归，所以该解法中一定会存在着重复部分，计算机还是会傻傻地对其重新计算一次，这便是需要进行优化剪枝的重叠子问题。我们可以在计算 fib(n) 之后，使用 LRU Cache 或者创建一个列表来把 fib(n) 给缓存起来，这样就可以避免对其进行重复运算，从而节省时间。
这便是动态规划最基本的运用，即通过一张表作为“备忘录”，从而减少递归的次数。
原本暴力求解的时间复杂度为 $O(n^2)$，经过优化后的时间复杂度仅为 $O(n)$。但是空间复杂度增大为了 $O(n)$，这本质上就是一个空间换时间的过程。
举个例子 下面用几个例子来归纳动态规划的原理：
凑零钱问题：「322.零钱兑换」 这一题其实可以通过递归的方法来解决，但是自从 LeetCode 改了测试集之后，递归解法就一定会超时（无论如何神优化都会超），所以只得从 DP 来入手。此题和背包问题一致，即求在固定的容量下能够装得下的最小（最大）数量。方法在于通过一个 DP Table 的形式来对最小硬币数量来进行记录，首先需要分析它的转移方程，当容量为 1（amount == 1）时的最优值一致往下推，等于 2 等于 3 等于 4……，最后等于 amount 的时候便可以得出最终的结果了。</description>
    </item>
    
    <item>
      <title>The Awakening of Feminism</title>
      <link>/posts/2021/20210121-the-awakening-of-feminism/</link>
      <pubDate>Thu, 21 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/2021/20210121-the-awakening-of-feminism/</guid>
      <description>This is one of my theses during the study of translation, as a review-like assignment after reading multiple English novels. The Feminism, facing commercialization issues nowadays, should be mentioned and respected indeed.
The Awakening of Femanism Jane Eyre is an orphan, who was born into a poor clergyman&amp;rsquo;s family and her parents died. Therefore, the little Jane Eyre was in foster care at her uncle and aunt&amp;rsquo;s house. After the death of her uncle Mr.</description>
    </item>
    
    <item>
      <title>【算法笔记】并查集</title>
      <link>/posts/2021/20210117-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E5%B9%B6%E6%9F%A5%E9%9B%86/</link>
      <pubDate>Sun, 17 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/2021/20210117-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E5%B9%B6%E6%9F%A5%E9%9B%86/</guid>
      <description>最近在 LeetCode 的每日一题中，大量出现了使用并查集进行算法设计的题目，如「684.冗余连接」、「803.打砖块」、「947.移除最多的同行或同列石头」。并查集这一点本身并不难学习，但有时候在题目中不容易发现对应的连接关系。
什么是并查集？ 并查集是一种树形的数据结构，旨在通过特定的规则，将属于同一类别的点归于一个树中，构成一个集合。其包括两种基本操作：
合并（Union）：将两个不同的集合合并为一个集合，或者将新的元素合入特定的集合 查找（Find）：确定两个元素是否在同一个集合中，或者确定某个元素处于哪一个子集 注意：虽然并查集是一个树形的数据结构，但考虑到内存以及时空复杂度，一般都会使用数组或者列表来实现，而非 Node 树结点。
建树初始化 首先，需要根据当前数据的规模来开辟空间，同时确保原始数据能够 One-Hot 地映射到创建的节点集合中，即创建的空间能够包括所有的原始数据。下面是样板代码（Python）：
class Union: def __init__(self, N): self.p = list(range(N)) # 初始化列表，每一个节点的值等于索引，其中 N 要根据原始数据确定 这一部分不难理解，即开辟一块额外的空间来保存并查集中的父子关系，因为现在还没有初始化关系，所以每一个点都指向自己的位置。接下来便是合并（Union），目的是输入数据形成并查集，样板代码如下：
def find(self, x): if x != self.p[x]: self.p[x] = self.find(self.p[x]) # 这里的递归是为了压缩路径，加快查找速度，下面会讲到 return self.p[x] find() 会返回该点所对应集合的根（父亲），如果两个点返回同样的根（父亲），则证明其处于同一个集合中。
一般情况下合并的样本代码如下：
def union(self, x, y): xr = self.find(x) # 找出 x 对应的根 yr = self.find(y) # 找出 y 对应的根 self.p[xr] = yr # 将 x 的根指向 y 的根，因为其属于同一个集合 不同的题目用到的数据不同，一般是某个点的坐标 (x, y) 之类。这类题往往都可以使用递归、DP 等方法解决，所以我经常会往递归和 DP 的方向去想，然后卡在某个状态上（暴风哭泣），从而忘了直接用更简单的并查集来解。</description>
    </item>
    
    <item>
      <title>2020 年度总结</title>
      <link>/posts/2021/20210113-2020-%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</link>
      <pubDate>Wed, 13 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/2021/20210113-2020-%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</guid>
      <description>2020 年是不寻常的一年，是匆匆度过的一年，无论对于这个世界，还是对于我。
由于 COVID-19 疫情，从年初至 9 月我都被迫留于家中，学业和生活也从来没有离开过这一块巴掌大的地方。好在国内的疫情控制得出色，周遭并没有收到特别严重的影响。倒是两三个朋友因为疫情被所在了国外，大费周章好几个月才能够平安回国。
我平时就有着轻微的社交恐惧症，所以相对于周围的人，这一次全国范围的出行限制并没有对我的生活产生特别大的影响，反而给了我一段特别长而充足的时间去重新审视和反思自己。
和去年一样，我想从几个关键词来总结这一年。
累并快乐着 “累并快乐着”，这大概是我这一年来最真实的写照；不仅需要保持学习，还要保持锻炼减重。虽然很难，但也在一定程度上提高了我的规划能力。
年初被达哥错误地挂了一科“马原”，直接给了我一记心灵暴击 debuff。尽管后面成绩改了回来，但也是直接或间接地影响我走上了考研这一条路，之后便是经历着考研和学期的课程内容的轮转。疫情让一些课程由考试变为了论文或课程设计形式，这在一定程度上倒也减轻了压力。
出于“保底”策略，我在秋招期间也被师兄怂恿抽空面了华为。但为了保证考研复习的进度，我只面了华为一家公司，没有办法像其他的大佬那样海投海面。这样最大的不足就是没办法找到一个最优解（比如今年的美团工资倒挂 30w+，就十分香）；华为 14 级虽然工资低了些，但作为保底岗也能算作一个局部次优解。
总的来说，这一年的学习生活让我承担着极大的强度。当然，对于已经上了一年半双学位课程的我，这还是能够统筹的。如今回想起那一段时光，也是一段难忘的时光罢。
比赛 &amp;amp; 项目 2020 年虽然忙，但也没有落下比赛和项目，毕竟生活已经如此艰难，不如就越充实越好（笑）。
第一个是 ASC，在我们完成了 NLP 的赛题并提交 Proposal 之后，由于疫情愈加严重，初赛由 2 月延期到了 12 月。这就很巧了，正好卡在我考研的时间点，所以无奈只能够退出校队放弃比赛。第二便是数模美赛，因为当时比较忙不太上心，勉强得了个小奖。最后一个是广东省省级的调研比赛（具体的名字忘了），时间跨度大概几个月，所以我只能在前期发力打下了基础。后期大佬们通力配合力挽狂澜拿到了省第五，还是不错的。
至于项目，由于去年大部分时间和心力都放在了备考上面，所以除了日常维护之外，也没有更多地去参加其他项目。
技术 不得不说，虽然我在专业学科内已经接触和学习了非常多的计算机知识，但《数据结构》、《操作系统》、《计算机组成原理》、《计算机网络》这四大科目的复习让我的体系更加系统了，也暴露并修正了我以前的很多短板，比如数据结构的学习不够系统，对计算机的底层不够了解等等。当然，自己的计算机水平也在复习的过程中得到了很多提升，对自己的水平也有了更客观的评估；后续更多地会去学习大佬们的项目，然后贡献一些自己的力量（如果可以的话）。
出于对 Linux 系统底层的深入，这一年我开始密集地接触和使用 WSL2，这成为了如今我最喜欢并且感觉最好用的“Linux 发行版”，WSL 这种丝滑的感觉真的太舒适了（笑）。
产品 今年由于在家待着的时间特别多，所以我也在网络上不停地探索着新鲜的玩意儿，参加了两款产品的 A 测，也提了一些 issue 和小建议。
第一个是 Billfish，一款基于 sqlite 的免费素材管理软件，主打的就是高性能以及针对 Eagle。那时候的我迫于空空的钱包，一直想寻找一个 Eagle 类的免费软件，知乎上翻到了 Billfish 的消息后我便试了试，然后买了 Eagle（逃）。
主要还是 Eagle 这种 Eletron App 在高分屏上的体验很好，性能也还过得去（官方也在不停优化）；Billfish 的界面是用 QT 写的，在管理素材上各种 Bug 频出；性能的确不错，但这大概也是它仅有的优点了。
第二款产品是 Wolai，这是一款成长地十分快的类 Notion 产品。在 Alpha 的早期阶段基本没有双休日，迭代非常快，现在也慢慢地拉近了与 Notion 在体验上的距离。前段时间马锐拉在朋友圈说 Wolai 成功融资了千万，感觉以后前景会很大。</description>
    </item>
    
    <item>
      <title>如何优雅地使用 WSL2</title>
      <link>/posts/2021/20210107-%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8-wsl2/</link>
      <pubDate>Thu, 07 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/2021/20210107-%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8-wsl2/</guid>
      <description>这是一个 WSL2 的使用指南，以及本人在安装和使用 WSL2 所遇到的各种问题的解决办法整理。
为什么是 WSL2？ 最开始使用 WSL2，纯粹是想尝试一下这个“世界上最好的 Linux 发行版”，然后便一发不可收拾，慢慢地将自己的开发环境也转移到了 WSL2 上。WSL2 毕竟是微软的亲儿子，其在各种软件以及环境的适配方面十分出色（相比于其他的虚拟机），VSCode、J 系软件等都能够很好地自动检查和适配 WSL 的相关配置，大部分的配置都能够做到自动化，摆脱了传统虚拟机繁琐的操作，这显著降低了 Linux on Windows 这一体系的使用难度和入门门槛。
在使用 WSL2 的这几个月的时间里，我也充分地了解了 WSL2 的运行机制和使用方法。在过程中也发现很多的 WSL2 坑在中文互联网上并没有特定的解决方法，只能通过 StackOverflow 和 GitHub Issue 中找到，因此我把这一部分的内容集中了起来，勉强算作一个较为完备的流程。
我后续踩到的坑也会持续更新至这篇文章中。
什么是 WSL2 WSL2 是 WSL 的“升级版”，相比于 WSL 只提供了一层类 Linux 的接口，WSL2 是在虚拟硬件层（Hyper-V）上运行了完整的 Linux 系统，与 Windows10 平级；且 Windows 和 WSL 之间可以通过 wsl 命令进行访问，也可以当成一个远程机进行维护。同时，从 Linux 的角度看，Windows10 的文件系统和 Linux 的文件系统直接挂载到了 /mnt 上，所以跨文件系统访问十分方便。
相比于 WSL1，WSL2 的启动速度会更快、内存占用更少，同时性能也更高。
注意：因为 Windows10 和 Linux 属于两种不同的文件系统，且目前 WSL2 在文件系统的兼容性上还存在问题——系统间进行 IO 走的网络协议，所以如果经常进行跨文件系统 IO 的话会有肉眼可见的性能损失（见官方对比）。对此建议将文件移至 Linux 系统的根目录（/mnt/wsl）内再进行操作。</description>
    </item>
    
    <item>
      <title>LeetCode Weekly Contest 204 Review</title>
      <link>/posts/2020/20200830-leetcode-weekly-contest-204-review/</link>
      <pubDate>Sun, 30 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/20200830-leetcode-weekly-contest-204-review/</guid>
      <description>因为 30 日当天返校，要处理很多事情，所以当天搁置了，此为后来补上的文章。
第一题：重复至少 K 次且长度为 M 的模式 给你一个正整数数组 arr，请你找出一个长度为 m 且在数组中至少重复 k 次的模式。
模式 是由一个或多个值组成的子数组（连续的子序列），连续重复多次但不重叠。 模式由其长度和重复次数定义。
如果数组中存在至少重复 k 次且长度为 m 的模式，则返回 true，否则返回 false。
示例：
输入：arr = [1,2,4,4,4,4], m = 1, k = 3 输出：true 解释：模式 (4) 的长度为 1 ，且连续重复 4 次。注意，模式可以重复 k 次或更多次，但不能少于 k 次。 分析 这道题用 Python 的话就是一道秒解题，直接匹配即可。
代码 Python class Solution: def containsPattern(self, arr: List[int], m: int, k: int) -&amp;gt; bool: i = 0 while i &amp;lt; len(arr): p = arr[i:i+m] if p * k == arr[i:i+m*k]: return True i += 1 return False 第二题：乘积为正数的最长子数组长度 给你一个整数数组 nums ，请你求出乘积为正数的最长子数组的长度。</description>
    </item>
    
    <item>
      <title>LeetCode Weekly Contest 203 Review</title>
      <link>/posts/2020/20200823-leetcode-weekly-contest-203-review/</link>
      <pubDate>Sun, 23 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/20200823-leetcode-weekly-contest-203-review/</guid>
      <description>每一道题目都附上了链接，现在可以更直接地进入题目了。
第一题：圆形赛道上经过次数最多的扇区 给你一个整数 n 和一个整数数组 rounds 。有一条圆形赛道由 n 个扇区组成，扇区编号从 1 到 n 。现将在这条赛道上举办一场马拉松比赛，该马拉松全程由 m 个阶段组成。其中，第 i 个阶段将会从扇区 rounds[i - 1] 开始，到扇区 rounds[i] 结束。举例来说，第 1 阶段从 rounds[0] 开始，到 rounds[1] 结束。
请你以数组形式返回经过次数最多的那几个扇区，按扇区编号升序排列。
注意，赛道按扇区编号升序逆时针形成一个圆（请参见第一个示例）。
示例：
输入：n = 4, rounds = [1,3,1,2] 输出：[1,2] 解释：本场马拉松比赛从扇区 1 开始。经过各个扇区的次序如下所示： 1 --&amp;gt; 2 --&amp;gt; 3（阶段 1 结束）--&amp;gt; 4 --&amp;gt; 1（阶段 2 结束）--&amp;gt; 2（阶段 3 结束，即本场马拉松结束） 其中，扇区 1 和 2 都经过了两次，它们是经过次数最多的两个扇区。扇区 3 和 4 都只经过了一次。 分析 这道题的意思就是统计所有经过的块，然后输出经过次数最多块的列表。但其实这道题还可以进行化简，因为每转一圈，圈上的每一块都加一，这跟不加是一样的（因为所有的都一起加了），所以之用考虑开头和结尾经过的块即可。
代码 Python class Solution: def mostVisited(self, n: int, rounds: List[int]) -&amp;gt; List[int]: tmp_l = rounds[0] # 最左边的数字 tmp_r = rounds[-1] # 最右边的数字 if tmp_l == tmp_r: return [tmp_r] # 相等则返回该数字 elif tmp_r &amp;lt; tmp_l: # 如果两边数字不相等，则可化简为从左数字到右数字的一轮 return [n for n in range(1, tmp_r + 1)] + [m for m in range(tmp_l, n + 1)] # 如果右边的数字比左边的小，即 [左到最大] + [1 到最右] 的数列 else: return [n for n in range(tmp_l, tmp_r + 1)] # 反之就是 [左到右] 的数列 C++ class Solution { public List&amp;lt;Integer&amp;gt; mostVisited(int n, int[] rounds) { int start = rounds[0]; int end = rounds[rounds.</description>
    </item>
    
    <item>
      <title>LeetCode Weekly Contest 202 Review</title>
      <link>/posts/2020/20200816-leetcode-weekly-contest-202-review/</link>
      <pubDate>Sun, 16 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/20200816-leetcode-weekly-contest-202-review/</guid>
      <description>第一题：存在连续三个奇数的数组 给你一个整数数组 arr，请你判断数组中是否存在连续三个元素都是奇数的情况：如果存在，请返回 true ；否则，返回 false。
示例：
输入：arr = [2,6,4,1] 输出：false 解释：不存在连续三个元素都是奇数的情况。 分析 直接写一个判断就解决了。
代码 Python class Solution: def threeConsecutiveOdds(self, arr: List[int]) -&amp;gt; bool: count = 0 for n in arr: if not n % 2: count = 0 elif count == 2: return True else: count += 1 return False C++ class Solution { public: bool threeConsecutiveOdds(vector&amp;lt;int&amp;gt;&amp;amp; arr) { int count = 0; for (int n = 0; n &amp;lt; arr.</description>
    </item>
    
    <item>
      <title>LeetCode Weekly Contest 201 Review</title>
      <link>/posts/2020/20200809-leetcode-weekly-contest-201-review/</link>
      <pubDate>Sun, 09 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/20200809-leetcode-weekly-contest-201-review/</guid>
      <description>第一题：Make The String Great 给你一个由大小写英文字母组成的字符串 s 。
一个整理好的字符串中，两个相邻字符 s[i] 和 s[i + 1] 不会同时满足下述条件：
0 &amp;lt;= i &amp;lt;= s.length - 2 s[i] 是小写字符，但 s[i + 1] 是相同的大写字符；反之亦然。 请你将字符串整理好，每次你都可以从字符串中选出满足上述条件的两个相邻字符并删除，直到字符串整理好为止。
请返回整理好的字符串。题目保证在给出的约束条件下，测试样例对应的答案是唯一的。
注意：空字符串也属于整理好的字符串，尽管其中没有任何字符。
示例：
输入：s = &amp;#34;leEeetcode&amp;#34; 输出：&amp;#34;leetcode&amp;#34; 解释：无论你第一次选的是 i = 1 还是 i = 2，都会使 &amp;#34;leEeetcode&amp;#34; 缩减为 &amp;#34;leetcode&amp;#34; 。 分析 这一题的意思就是说，遍历整个字符串，然后如果当前的字符和下一个字符大小写不同，字母相同的时候，则删除两个字母，直到整个字符串满足条件为止。
所以就遍历然后写一个判断条件判断即可。可以通过每次匹配到之后遍历指针归零的方式，来减少每一次的遍历长度；同时，考虑到归零也有可能出现无意义的匹配，所以可以在匹配到字符串之后指针减一（即从上一个字符继续匹配），这样就可以进一步减少无意义的匹配。
这样的题需要用到自己构建的指针遍历，所以要注意 out of range 的问题。
代码 Python class Solution: def makeGood(self, s: str) -&amp;gt; str: if not s: return &amp;#34;&amp;#34; # 非空继续 i = 0 # 初始化指针 while i &amp;lt;= len(s) - 2: # 指针范围 if s[i] == s[i + 1]: # 如果相等就下一个 i += 1 elif abs(ord(s[i]) - ord(s[i + 1])) == 32: # 不相等则判断是否满足条件 s = s[:i] + s[i + 2:] # 删除两个字符 i = max(0, i - 1) # i -= 1 else: i += 1 return s C++ class Solution { public: string makeGood(string s) { int i = 0; while (i &amp;lt; s.</description>
    </item>
    
    <item>
      <title>LeetCode Weekly Contest 200 Review</title>
      <link>/posts/2020/20200802-leetcode-weekly-contest-200-review/</link>
      <pubDate>Sun, 02 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/20200802-leetcode-weekly-contest-200-review/</guid>
      <description>第一题：Count Good Triplets 给你一个整数数组 arr ，以及 a、b、c 三个整数。请你统计其中好三元组的数量。
如果三元组 (arr[i], arr[j], arr[k]) 满足下列全部条件，则认为它是一个 好三元组 。
0 &amp;lt;= i &amp;lt; j &amp;lt; k &amp;lt; arr.length |arr[i] - arr[j]| &amp;lt;= a |arr[j] - arr[k]| &amp;lt;= b |arr[i] - arr[k]| &amp;lt;= c 其中 |x| 表示 x 的绝对值。
返回好三元组的数量。
示例：
输入：arr = [3,0,1,1,9,7], a = 7, b = 2, c = 3 输出：4 解释：一共有 4 个好三元组：[(3,0,1), (3,0,1), (3,1,1), (0,1,1)] 。 分析 这一道题可以直接穷举，然后遍历出所有符合的条件即可。但是直接穷举的话还是比较慢，需要剪枝提高效率。剪枝的方法是先判断第一个条件，满足之后再进行下面的循环，这样可以在测试集中减少接近一半的时间。
代码 Python class Solution: def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -&amp;gt; int: length = len(arr) token = 0 for i in range(length - 2): # 第一个数 for j in range(i + 1, length - 1): # 第二个数 if abs(arr[i] - arr[j]) &amp;lt;= a: # 在满足第一个条件之后再取第三个数 for k in range(j + 1, length): # 第三个数 if (abs(arr[j] - arr[k]) &amp;lt;= b and abs(arr[i] - arr[k]) &amp;lt;= c): # 继续判断后两个条件 token += 1 # 满足则 +1 return token C++ class Solution { public: int countGoodTriplets(vector&amp;lt;int&amp;gt;&amp;amp; arr, int a, int b, int c) { int length = arr.</description>
    </item>
    
    <item>
      <title>LeetCode Weekly Contest 199 Review</title>
      <link>/posts/2020/20200726-leetcode-weekly-contest-199-review/</link>
      <pubDate>Sun, 26 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/20200726-leetcode-weekly-contest-199-review/</guid>
      <description>第一题：Shuffle String 给你一个字符串 s 和一个长度相同的整数数组 indices。请你重新排列字符串 s ，其中第 i 个字符需要移动到 indices[i] 指示的位置，返回重新排列后的字符串。
输入：s = &amp;#34;codeleet&amp;#34;, indices = [4,5,6,7,0,2,1,3] 输出：&amp;#34;leetcode&amp;#34; 解释：如图所示，&amp;#34;codeleet&amp;#34; 重新排列后变为 &amp;#34;leetcode&amp;#34; 。 分析 这道题的算法比较简单，有两种解法。
第一种是在不能新建字符串空间的情况下，可以通过从开头遍历，然后根据 indices 循环交换字符串，直到 indices 正好为该位置的指针时，转到下一个继续进行循环交换。
第二种是可以新建字符串空间的情况，这样子就比较简单了，直接新建或复制出一个同等长度的字符串，然后根据 indices 遍历原字符串，然后放到新数组的对应位置即可。
很明显，第一种的时间复杂度为 $O(n^2)$，第二种的时间复杂度为 $O(n)$，所以最终提交的为第二种方法的代码。源码如下：
class Solution: def restoreString(self, s: str, indices: List[int]) -&amp;gt; str: m = [0] * len(indices) # 新建一个列表 for i,n in enumerate(indices): m[n] = s[i] # 按照 indices 为指针，把字符放到新列表中的对应的位置 return &amp;#34;&amp;#34;.join(m) # 用 join 把列表合成字符串 因为 Python 语言本身不支持字符串的枚举，所以只能生成列表进行操作，最后再合起来。而 C++ 可以直接枚举操作字符串，所以代码相对简单一些：</description>
    </item>
    
    <item>
      <title>索尼 1000XM3 一个月使用体验</title>
      <link>/posts/2020/20200720-%E7%B4%A2%E5%B0%BC-1000xm3-%E4%B8%80%E4%B8%AA%E6%9C%88%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C/</link>
      <pubDate>Mon, 20 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/20200720-%E7%B4%A2%E5%B0%BC-1000xm3-%E4%B8%80%E4%B8%AA%E6%9C%88%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C/</guid>
      <description>为什么会买这么贵的耳机 虽然次数很少，但是每当入手价格比较高的数码设备时，我都会产生很强的负罪感。
所以一开始，我并没有打算买这么贵的耳机，但我的确需要一款耳机，并且最好附带着主动降噪的功能——小区楼上的装修实在太吵了，上网课的我直接就给物理屏蔽了。因此我把目光放在了 500 左右价位的降噪耳机上面，但后来随着 1000XM3 降到了史低，久经考虑，还是咬咬牙上了 1000XM3。
买回来后，除了有些肉疼之外，整体的体验还是十分满意的。接下来就从几个方面来分享一下我的使用体验。
外观和佩戴 外观不用说，出街必备的神器之一（虽然我并不会佩戴像耳机这样的配饰出街）。黑色的主调加上部分古铜色的金属部件装饰，整体的高端感够味儿。
佩戴起来很舒适，但是待久了会压头，需要时常进行一下调整（可能是我头比较大的原因），并且耳罩内不透气，很容易把耳朵捂出汗。冬天可当暖耳神器，一机多用，我突然感觉这 1599 大洋又值了很多（误）。
声学体验 声音这一方面之所以被称为玄学，不是因为这一块真的“玄学”，而是每一个人耳朵的差异十分普遍，所以很容易导致同一款耳机在不同人耳中效果大相径庭。
我的大学老师在教声学传感器的时候就跟我们说过，人耳对于不同频响的灵敏度是有差异的，有的人可能对高频敏感，有的人可能对低频敏感；同时随着时间的流逝，骨膜部分会发生硬化，对于中低频的感知会有减弱。这直接导致后来我看一些老法师的时候，就有种看神棍的感觉。
简单来说，听音乐的感受因人而异，最好还是自个儿能够实际听一下感受效果。
在我的感受，这大耳机比我之前的 199 漫步者要好到不知道哪里去了。不同部分层次丰富，低音轰头，听歌有一种听家里的飞利浦音响的感觉。同时之前的耳机蓝牙和插线的音质是有很大区别的，而 1000XM3 上两者的差距就会比较小，但是数据传输并没有使用 LDAC 协议，似乎是耳机本身播放的时候能够进行一定的处理。
一句话总结，1000XM3 的音质可以说是属于第一梯队了，基本上不会出现什么大问题。
降噪 降噪还是十分优秀的，毕竟 Top1 水平，同时还能够通过 APP 进行场景切换，说白了也就是根据不同的场景调整不同频率的降噪效果。静坐的时候降噪是属于一个全开的状态，而走路或者跑步的时候，为了确保人身安全，中频反而会被放大。
除了 APP 上面进行调整外，耳机也可以利用加速度传感器进行判断当前是走路还是跑步，从而智能切换状态，但是这个状态监测不太准，有时候会出现误判的情况。除此之外，耳机左侧还有一个额外的按键可以快速切换不同的降噪方案，但是我很少用。
在这一个月的使用中，我也遇到了降噪的一个 bug，就是左耳风声的问题。这个问题不是个例，贴吧有很多人都有这个问题，目前最快速有效的解决方法就是在 APP 里面降噪设置部分中，把降噪效果给调低一档。
NFC 和固件 耳机上带有 NFC 感应器，所以能进行一些骚操作。我最喜欢的一个操作就是用手机轻轻贴一下耳机上的 NFC 处，就能够快速连接和断连设备，并且开关机后也能够记住上一次的连接状态。
并且经过我在索尼贴吧的浏览，我发现最新的的耳机固件相比于之前版本的降噪功能有负优化，中频的降噪被大幅削弱了。当然也可以通过特殊的手段将耳机的固件版本恢复回原来的，降噪效果也会有一定程度的改善。
总结 索尼 1000XM3 这一款耳机的体验还是十分优秀的，优秀到让我基本上能够认可这样高昂的价格。加上今年的 618 优惠，这款耳机还是十分具有性价比的。
如果是价格敏感的用户，其实把价位放低一些，也有很多音质不错的耳机，但是降噪水平就可能不会这么优秀；相反，如果把价格再往上提，价位段上的耳机也不会比这款优秀很多。</description>
    </item>
    
    <item>
      <title>DHT11 温湿度传感器在树莓派上的通信</title>
      <link>/posts/2020/20200614-dht11-%E6%B8%A9%E6%B9%BF%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8%E5%9C%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%8A%E7%9A%84%E9%80%9A%E4%BF%A1/</link>
      <pubDate>Sun, 14 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/20200614-dht11-%E6%B8%A9%E6%B9%BF%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8%E5%9C%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%8A%E7%9A%84%E9%80%9A%E4%BF%A1/</guid>
      <description>最近因为嵌入式的课程设计，买了一些硬件，显示屏跟着官方文档可以基本上没有问题完成所有的设置并正常使用；可是到了 DHT11 这儿就出现了问题，我在网上找了好几个版本的代码，都没有办法能够直接正常从传感器那儿获取数据。
比如下面这个，原地址在这儿：
#!/usr/bin/python #-*- coding:utf-8 -*- import RPi.GPIO as GPIO import time channel = 7 #引脚号Pin7 data = [] #温湿度值 j = 0 #计数器 GPIO.setmode(GPIO.BOARD) #以BOARD编码格式 time.sleep(1) #时延一秒 GPIO.setup(channel, GPIO.OUT) GPIO.output(channel, GPIO.LOW) time.sleep(0.02) #给信号提示传感器开始工作 GPIO.output(channel, GPIO.HIGH) GPIO.setup(channel, GPIO.IN) while GPIO.input(channel) == GPIO.LOW: continue while GPIO.input(channel) == GPIO.HIGH: continue while j &amp;lt; 40: k = 0 while GPIO.input(channel) == GPIO.LOW: continue while GPIO.input(channel) == GPIO.HIGH: k += 1 if k &amp;gt; 100: break if k &amp;lt; 8: #通过计数的方式判断是数据位高电平长短，以置0或1。（此方式有待商榷） data.</description>
    </item>
    
    <item>
      <title>树莓派系统安装及配置（无网线、显示屏和键鼠）</title>
      <link>/posts/2020/20200527-%E6%A0%91%E8%8E%93%E6%B4%BE%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE%E6%97%A0%E7%BD%91%E7%BA%BF%E6%98%BE%E7%A4%BA%E5%B1%8F%E5%92%8C%E9%94%AE%E9%BC%A0/</link>
      <pubDate>Wed, 27 May 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/20200527-%E6%A0%91%E8%8E%93%E6%B4%BE%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE%E6%97%A0%E7%BD%91%E7%BA%BF%E6%98%BE%E7%A4%BA%E5%B1%8F%E5%92%8C%E9%94%AE%E9%BC%A0/</guid>
      <description>为啥要折腾？ 因为最近有课程设计需要使用到树莓派，所以我花了好大的精力联系学姐和辅导员，把板子从学校给寄了回来。
寄回来之后，我发现没有显示器和额外的键盘，完全没办法直接使用（哭）。然后我就尝试 SSH 连接树莓派，但是似乎连接设置出现了问题无法连接，所以最后只能够重新安装树莓派的系统了。
我之前安装树莓派的时候是有显示器和额外的一套键鼠的，整体安装过程十分简单直观。这一次因为没有这些额外的硬件，所以我也是查了许多的教程，才摸索出了一个比较正常和方便的安装过程，而且全称可以完全无头，即无网线、显示屏和键盘，只用一条电源线即可。
开始前的软件准备 系统镜像，可以去官网的下载页面下载，我是用的是 Buster Lite； SD Card Formatter 工具 Win32 Disk Imager 安装系统 将下载下来的系统镜像 .img 文件解压出来； 使用 SD Card Formatter 工具格式化 SD 卡； 使用 Win32 Disk Imager 工具将系统镜像写入 SD 卡； 至此系统已经安装完成，但还需要两步操作，使树莓派在上电开机后能够自动连接上 WiFi 网络。
在电脑上打开 SD 卡的 /boot 分区（Windows 系统上只能够看到这个分区），在根目录下新建一个名字为 ssh 的空文件；
再新建一个 wpa_supplicant.conf 文件，写入如下内容：
country=GB ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev update_config=1 network={ ssid=&amp;#34;WiFi 名称，注意大小写&amp;#34; psk=&amp;#34;WiFi 密码&amp;#34; } 这个文件会写入树莓派系统中的 /etc/wpa_supplicant/wpa_supplicant.conf，所以一般设置一次，后面就不用设置了，可以开机自动接入网络。 这一个配置文件的 network 还有其他的配置项，详情可以见这篇博客。
搞定上述操作之后，就可以把 SD 卡插入树莓派，然后上电开机了。
远程连接树莓派 远程连接树莓派这一步简单一些，直接找到树莓派的 IP，然后 SSH 连接即可。</description>
    </item>
    
    <item>
      <title>图像相似度的比较算法</title>
      <link>/posts/2020/20200423-%E5%9B%BE%E5%83%8F%E7%9B%B8%E4%BC%BC%E5%BA%A6%E7%9A%84%E6%AF%94%E8%BE%83%E7%AE%97%E6%B3%95/</link>
      <pubDate>Thu, 23 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/20200423-%E5%9B%BE%E5%83%8F%E7%9B%B8%E4%BC%BC%E5%BA%A6%E7%9A%84%E6%AF%94%E8%BE%83%E7%AE%97%E6%B3%95/</guid>
      <description>最近花了些时间研究了一下图像相似度算法，感觉还是挺有趣的，也解决了我以前的一些疑惑。
目前的识别算法主要有几种，第一个是感知哈希算法，其中包括均值哈希（aHash）、感知哈希（pHash）和差异值哈希（dHash）；第二种是 SIFT。而目前主要使用的是 SIFT 和 pHash。
下面简单介绍一下这几种算法的原理和优势。
均值哈希（aHash） 原理 缩放图片：将图片进行下采样至 8*8 的像素矩阵，共 64 个像素； 灰度图片：将图片转化为 256 阶的灰度图； 灰度算法有很多: 心理学灰度 $Gray=0.299\times R+0.587\times G+0.114\times B$ 平均值算法 $Gray=(R+G+B)/3$ 绿色值算法 $Gray=G$
二元化图片：将图片进行二元化转换； 这一步简单来说，就是先计算灰度均值，然后依次遍历原像素值，高于灰度值记为 1，低于记为 0，最后生成了一个 64 bits 的数列。
构造哈希：对 64 bits 的数列进行哈希，生成“感知指纹”； 对比指纹：对两幅图片的“指纹”计算汉明距离，距离越小则相似度越高。 算法特点 aHash 的算法简单粗暴，速度快。但是由于对图片进行了下采样和二值化，所以自然丢失了非常多的数据，精确度也就很低。
感知哈希（pHash） 原理 缩放图片：将图片进行下采样，生成正方形的图片（图片一般大于 8*8，3*32）； 灰度图片：该步骤与上同； 计算 DCT（离散余弦变换）：DCT 计算将图片按照频率分布进行分解； 裁剪 DCT：经过 DCT 操作后，会生成一个 32*32 的频域矩阵，我们只需要保存左上角的 8*8 即可，这一部分是图片的低频； 二元化矩阵：对上一步的矩阵进行处理，算法同样是计算平均值然后二元化； 构造哈希：对 64 bits 的数列进行哈希，生成“感知指纹”； 对比指纹：对两幅图片的“指纹”计算汉明距离，距离越小则相似度越高。 DCT 的算法相较复杂，主要用于数据或图像的压缩，能够将空域的信号转换到频域上，具有良好的去相关性的性能。 一维 DCT 变换： $$ F(u)=c(u)\sum_{i=0}^{N-1}f(i)cos[\frac{(i+0.</description>
    </item>
    
    <item>
      <title>谈谈我所认为的主流编程语言</title>
      <link>/posts/2020/20200422-%E8%B0%88%E8%B0%88%E6%88%91%E6%89%80%E8%AE%A4%E4%B8%BA%E7%9A%84%E4%B8%BB%E6%B5%81%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/</link>
      <pubDate>Wed, 22 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/20200422-%E8%B0%88%E8%B0%88%E6%88%91%E6%89%80%E8%AE%A4%E4%B8%BA%E7%9A%84%E4%B8%BB%E6%B5%81%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/</guid>
      <description>呆在家里的时间越来越长了，这也给了我很多时间去做一些以前没有想过的思考。
所以趁着目前的学习阶段，我想谈谈我所认为的三种主流编程语言——C++、Java、Python。这三种语言有着不同的运行方式、不同的运用场景和不同的使用目的，也是我目前主要使用的三个编程语言。
C++ C++ 是我最早接触的语言之一了，早期的 C++ 更多地是 C 的一个不严谨的“超集”，你甚至可以在 C++ 的语法环境下编写 C 程序，两者相互兼容。后来的 C++ 17 / 18 反而越来越像“Python”，这也足以显示目前语言的一个发展方向。
的确如今的 C++ 复杂度已经过分高了，从而让开发者把更多的时间花在了指针以及内存管理等本可以自动处理的部分。这对于如今互联网企业的“敏捷开发”潮流来说十分不友好，如果贯彻 C++ 就需要花费大量时间搭建脚手架。
优点 优点显而易见，程序运行效率极高，接近于机器语言，并且相比于 C 有 OOP 的能力。所以这能够让 C++ 开发者在硬件层次上考虑问题，从而最大化利用硬件的性能。
所以这就特别适用于对运行速度要求很高，与系统底层相关的程序。
缺点 那它还有什么缺点呢？首当其冲的就是在开发过程中，工程师需要花费远超算法实现的时间（至少对于我来说是这样）去解决硬件资源管理和内存管理的问题，而这些问题往往与目前解决的问题无关。
第二点便是代码量和复杂的设计。这大概是历史原因，因为 C++ 一直在鼓励复杂的、精致的设计，导致了庞大的代码体积。
Java Java 是我最近学习的一种语言。期初我学习 Java 的兴趣并不高，但是后来的作业中用了一下，便继续深入了一点，现在大概还是初学者阶段吧。（笑）
因为我的 Java 经验并不是特别足，所以就简单对比一下 Java 与其他语言的优劣。
优点 优点很直观，就是“Write once, run anywhere”，这也是当初 Java 被设计出来的原因。因为 Java 需要先将代码编译成可供 JVM 运行的字节码，所以这也意味着程序可以完全不依赖与运行的平台，只要有 runtime 的运行环境即可。
其次便是 Java 的编程过程相较于 C++ 就轻松了很多，不仅比 C++ 小巧简单，而且有 GC，OOP，强类型，与 C 结合比较好。</description>
    </item>
    
    <item>
      <title>【瞎扯 3】互联网精神</title>
      <link>/posts/2020/20200418-%E7%9E%8E%E6%89%AF-3%E4%BA%92%E8%81%94%E7%BD%91%E7%B2%BE%E7%A5%9E/</link>
      <pubDate>Sun, 19 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/20200418-%E7%9E%8E%E6%89%AF-3%E4%BA%92%E8%81%94%E7%BD%91%E7%B2%BE%E7%A5%9E/</guid>
      <description>PanDownload 突然就倒了。
看到消息的时候我其实并没有太大波浪，我平时极少使用百度网盘，少到每一次想下东西的时候才发现自己已经卸载了它。
随着事件开始发酵，细节也浮出了水面：
某刘姓网友举报 PanDownload 存在隐私泄露的问题，然后警方出击逮捕了这个软件的作者（有人说这个作者年仅 17 岁），作者涉嫌非法获利 30 万。而另一面言论说作者完全是处于免费的意图搭建了服务器和软件，所获得的钱均来自于网友的捐助，而这所有的资金全部用于了服务器维护上。
这件事上实在无法盖棺定论，毕竟灰色地带，哪怕被抓了也不能够判定哪一方是绝对正确的。这一次的 PanDownload 事件就像是昨日快播的重蹈覆辙，引起了很大的争议，“技术无罪”的声浪依然此起彼伏。
不过网上更多地是讨伐百度作恶的，毕竟不是一天两天了，更何况这一次的“刘某”的确很像是百度摆的一个局。毕竟正常的情况下单纯的隐私泄露事件，是不会有警队迅速跨省办案的。
技术真的无罪吗？我一开始觉得是的，至少技术是没有国籍的，它不应该因为政治问题而在某些国家或者地区被禁止。所以之前的 GitHub 封禁伊拉克等国家的程序员，阻止相关地区的登录，我是对其抱有批判态度的。
当然，后来的我见识的多了，才开始意识到这其实是个伪命题，“技术无罪”这般的纯洁性只能存在于众多技术人所搭建出来的“伊甸园”之中。当它面向了大众，面向了企业，技术就开始带了目的。
互联网精神 我是一个互联网的原住民，在我很小的时候父亲买回来了一台电脑，一台近万元的设备让我第一次接触到了数字世界的魅力。父母为了不让我出门，便每天晚上让我玩会儿电脑，于是我就每天打开蜘蛛纸牌和三维弹球，度过了一段懵懂的时光。
后来，我上了小学，好奇心让我开始探索互联网世界。那时候有许许多多的站长在做着免费的主机和网站服务，我在这些主机网站下建立了自己的第一个网站，内容很简单，我却折腾了一个晚上。当时兴奋地我发现只有谷歌能够搜索出来，而百度不行，因此百度在我的心中一直都是二流搜索引擎——如今看来的确讽刺。
零几年的时候上网的人不是特别多，大家在网上一团和气，贴吧博客好不热闹。不管是什么圈子，都是在最初人少的时候有着极高的平均素质，我开始接触到各行各业的人，和各个方向的大佬。无论是装机论坛还是个人博客，无数人把自己领域努力的成果无偿奉献出来，网友们亦或是争论亦或是讨论，最后都不会忘了发一句“谢谢楼主，楼主一生平安”。
那时候的电驴啥都能下；
那时候的番茄花园一键重装的可深度定制的 Windows 系统；
那时候的 1 个月 5 元 30MB，还有很多人用的珊瑚虫 QQ 外挂；
那时候的 CS 十分的火，谁都在玩；
那时候的“呵呵”真的是开心的笑。
在互联网上偷了几年的菜，玩了几年摩尔庄园后，我开始学起了计算机技术，接触到了许多老牌程序员的博客，当时的博客质量一水得高，比现在的 CSDN 套娃不知道高到哪里去了。
互联网精神，大概就是如此吧。
后互联网时代 如今当然还存在着“互联网精神”，但是随着互联网产业的发展，网民井喷式增加，资本潮水式涌入。那时候的互联网就像是风口，一头猪也能飞起来。
老实说，当时的我也错过了好几次发展的红利。第一次是微博，我作为早期用户打算和朋友一起建立一个以科技资讯为主的微博，但是随着学业繁忙也没有做下去，粉丝也只有四五百停滞不前；第二次是知乎，我同样也是早期用户，本来想着能够通过自己的知识来经营一个账号，但我怂没敢去做。知道后来看到一个互关的好友靠着自己和男朋友的故事成功接到广告，列表里一个个渐渐都成了大 V，我才觉得错过了什么。我不敢说自己多有远见，毕竟我也没想到如今的微博和知乎随着大量用户涌入已经今非昔比，而且我的确没有额外的时间去追随风口。
一句话，太年轻。
后来我对互联网的印象开始慢慢改变，最终成了如今这副模样。大量资本入场，互联网开始因为版权而大量封禁不合规内容；限于内容审核也有大量的数据和信息被删除，整个互联网似乎在渐渐变得“健康”，但似乎也丢掉了什么东西。
这就像是从以前的田园生活发展到了现在的城市生活，一切服务都更加便利了，但是为了适应更多地人群，限制多了，围墙也高了。
互联网的秩序以及发展已经让它丢了很多东西，互联网精神也只能成为少数社区的桃花源遗风。我十分怀念那样的环境，可惜已经大不复存了。
但这并不代表我十分崇尚互联网精神下的那段日子，我依然认为互联网如今的发展趋势是合理的，它能让整个环境更加健康，利益最大化。</description>
    </item>
    
    <item>
      <title>字符编码：ASCII、UTF8 和 Unicode</title>
      <link>/posts/2020/20200416-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81asciiutf8-%E5%92%8C-unicode/</link>
      <pubDate>Thu, 16 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/20200416-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81asciiutf8-%E5%92%8C-unicode/</guid>
      <description>字符的编码格式有很多种，互联网上广泛存在着不同种类编码方式编码的文本文件。肯定有很多人在编程的时候遇到过读取文件出现乱码的问题，这很大程度上就是文件编码格式和读取时使用的编码格式不一致造成的，所以就经常需要根据文本编码类型来选择相应的编码格式读取文件。
字符编码是计算机技术的基石，所以了解编码格式的一些皮毛还是十分重要的。我再网络上查阅了相关的几篇文章，总结了主流编码格式 ASCII、UTF-8、Unicode 的相关知识点信息。
字节与编码 在了解不同的编码格式之前，我们还需要知道计算机是如何进行存储和编码的。
计算机内部处理和存储信息时，所有的信息都可以描述为一串特定的二进制信息流，其最小的单位为一个比特 $bit$ ，每一个比特都存在 $0$ 和 $1$ 两种状态；而 8 个比特便是一个字节 $byte$，可以表达出 $2^8=256$ 种状态。通过读取不同的状态，计算机就可以执行对应的操作，而这个把特定的一个状态对应到特定操作上的这个过程，就是编码。
下面贴一个比较官方的描述：
编码是信息从一种形式或格式转换为另一种形式的过程，也称为计算机编程语言的代码简称编码。用预先规定的方法将文字、数字或其它对象编成数码，或将信息、数据转换成规定的电脉冲信号。
所以，有了编码，我们就可以通过这样的方式写一套编码表，将不同的字符用对应的字节码来表示，从而让计算机“读懂”文字，并且显示在屏幕上，形成这一篇文章（笑）。
ASCII 编码 ASCII 码是最早的编码方式之一，早在上个世纪 60 年代，美国就制定了相关的一套字符编码表，并一直沿用至今。
ASCII 码中一共规定了 128 个字符，每一个字符通过 1 个字节来表示，但这 128 个符号只占用了一个字节的后 7 位，最前一位规定为 0。
对于英语国家来说，128 个字符就足够使用了，但是表示其他的语言是远远不够的——比如法语、希腊语等。（因为当时主要是在欧洲国家和北美洲国家使用，所以没有考虑到庞大的汉字系统）
因此后来 ASCII 码的标准被广泛使用，为了适应非英语语系国家以及数学家（误）的使用需求，码表还需要添加其他的非英语字符和符号，于是之前空出来的 1 比特就派上了用场，扩展 ASCII 问世。
非 ASCII 编码 不同的国家有不同的字母，128 个字符是囊括不完的。所以实际上高位的 128 个字符在不同的国家编码对应着不同的符号。比如 ASCII 码中，130 号字符在法语里是 é，而在希伯来语里是 ג，在其他的语言又会是另一个符号。
但是无论怎么改，都是高 128 位（128-255）不同，而低 128 位（0-127）所表示的符号全是一样的。
汉字由于是另一个语系，使用的符号十分之多，汉字就 10 万往上语法符号还和英文不一样，所以肯定需要更更多地字节去编码表示。例如简体中文常见的编码方式是 GB2312，每一个汉字需要两个字节来表示，理论上最多能够表示 $2^8\times2^8=65536$ 个符号。</description>
    </item>
    
    <item>
      <title>AC 自动机的原理及实现</title>
      <link>/posts/2020/20200412-ac-%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Sun, 12 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/20200412-ac-%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</guid>
      <description>在最近水论坛的时候，我发现了一个网友友问的这样一个问题：
数千万篇文章，寻找其中包含成语的句子。成语有数万条。 目前没有对文章内容建立过全文索引，鉴于这个事情是一次性的，为此搞个索引可能也成本过高。暂时的解决方案是，把成语都放在一条 re.compile(&amp;lsquo;乌合之众|鸡犬相闻|&amp;hellip;&amp;rsquo;)里面去搜索文章，但效率总觉得不理想。 求教，是否可能有更高效的解决方案。
我写过爬虫，也做过相关的一些算法，对于数据匹配无非就是正则表达式了，毕竟爬的数据量都还不大，效率方面的感知不强。
但是正则的缺点就是效率低，所以这个有大规模数据匹配需求的网友就遇到了低效的问题。这时，底下的一条评论靠着简单的一个词解决了这个问题：
“AC 自动机。”
AC 自动机是什么？ AC 自动机的原理简单来说，就是根据输入的多个模式串去建立一个树模型，然后再根据这个模型作字符串匹配。那它具体是什么呢？
在聊 AC 自动机之前，我们还需要了解两个基本算法：KMP 和 trie 树。
KMP KMP 算法是一种改进的字符串匹配算法，能够高效地进行串匹配。
传统的一种字符串匹配算法是类似于滑窗一样地进行逐个比对，如下：
T: b a a b a b c x W: a b a Wrong. T: b a a b a b c √ x W: a b a Wrong. T: b a a b a b c √ √ √ W: a b a Right. 后来有人发现了，这样匹配多没效率啊，不如匹配错误的时候，跳过一些字符，可以减少匹配计算量。</description>
    </item>
    
    <item>
      <title>数据压缩和信息熵</title>
      <link>/posts/2020/20200409-%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9%E5%92%8C%E4%BF%A1%E6%81%AF%E7%86%B5/</link>
      <pubDate>Thu, 09 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/20200409-%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9%E5%92%8C%E4%BF%A1%E6%81%AF%E7%86%B5/</guid>
      <description>压缩的原理及有限性 在计算机导论中简要介绍过几种压缩的算法，原理十分简单，便是利用更短、熵更高的字符串来代替一些重复率高，熵较低的字符串，从而实现缩短字节量，减小文件的体积的目的。步骤大致如下：
得到文件的概率分布，统计频次高的以及频次低的部分； 结合统计结果对源文件重新编码，用短字符代替重复的长字符。 举个例子：
AAAAAAAAAA =&amp;gt; 10A // 用 3 个字符代表 10 个字符，压缩比 30% ABCABCABCABCABCABCABCABC =&amp;gt; 8ABC // 用 4 个字符代表 24 个字符，压缩比 16.7% 显而易见，越是重复率高的文件，就意味着能够压缩的量就越大，体积也自然能够越小；反之，如果一个文件的重复率低，也就越难压缩。所以每一个文件的熵不同，压缩比率也会不尽相同。
那么，压缩有一定的限度吗？ 当然，在信息论中我们学到过，无损压缩实现的前提是输出和输入必须要严格一一对应，也就是不能够出现多对一的映射。我们可以假设任意文件都能够压缩到 $n$ bits，那么就能够产生 $2^n$ 种可能的压缩结果。这便意味着如果有 $2^n+m$ 个不同的文件，就会导致有 $m+1$ 个文件出现了重复，所以压缩一定存在着极限。
压缩的极限 一个文件的压缩极限可以通过计算文件的平均信息熵大小，从而推导出来。当然这个最小值仅仅是理论最小值，并不一定能够达到，下面我将用浅显的方式做一些推导。
在不同的文件格式中可能存在着不同的计算方法，比如文本文件可能就会根据文本中的字符计算信息熵，图片会使用 RGB 排列来计算信息熵等。我这里使用了一个通用的方法——将任意文件按字节的形式进行读取，统计不同字节的信息熵。
计算平均信息熵的公式为：
$$H(X)=\sum P_n * \log(\frac{1}{P_n})$$
$P_n$ 为每一个字节在文件中出现的概率，计算方法如下：
$$P_n=\frac{N_{freq}}{N_{all}}$$
$N_{freq}$ 为该字节在文件中出现的次数，$N_{all}$ 文件的总字节量。
其中的 $log$ 在信息论中是默认以 2 为底的（在通信原理中是默认以 10 为底），通常会做省略处理。
最后求出来的 $H(X)$ 是文件每一个字节的平均信息熵，如果乘以总字节数就可以得到理论的压缩极限大小：
$$Size_{min}=H(X) * N_{all}$$
信息熵的含义 信息熵只反映内容的随机性，与内容本身无关。不管是什么文件，服从同样的概率分布就会得到同样的信息熵。 信息熵越大，表示占用的二进制位越长，可以表达更多的符号。即信息熵越大，信息量就越大，但这并不代表所获得的的信息越大。 代码实现 (Python) import sys from math import log from argparse import ArgumentParser from os.</description>
    </item>
    
    <item>
      <title>将自己的轮子部署到 PyPI</title>
      <link>/posts/2020/20200405-%E5%B0%86%E8%87%AA%E5%B7%B1%E7%9A%84%E8%BD%AE%E5%AD%90%E9%83%A8%E7%BD%B2%E5%88%B0-pypi/</link>
      <pubDate>Sun, 05 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/20200405-%E5%B0%86%E8%87%AA%E5%B7%B1%E7%9A%84%E8%BD%AE%E5%AD%90%E9%83%A8%E7%BD%B2%E5%88%B0-pypi/</guid>
      <description>自己写了一个效率高，功能简单易用的轮子，如何把它分享给其他人呢？部署到 PyPI 是一个不错方法。
包结构 一个正常的包结构如下（以 oneline 为例）：
- Folder - oneline - __init__.py - README.md - LISENCE - setup.py oneline 文件夹就是自己写的库了，为必须项； README.md 是库的文档介绍； LISENCE 是这个包所使用的协议； setup.py 是这个包的配置脚本，为必须项。 虽然 README.md 和 LISENCE 不是必须的，但有这两个文件能方便使用者使用。
setup.py setup.py 类似于一个配置的脚本，在生成和配置轮子的时候都会使用到。结构如下：
import setuptools with open(&amp;#34;README.md&amp;#34;, &amp;#34;r&amp;#34;, encoding=&amp;#34;utf-8&amp;#34;) as fh: long_description = fh.read() setuptools.setup( name=&amp;#39;one-line&amp;#39;, version=&amp;#39;0.1.31&amp;#39;, description=&amp;#39;Make every step oneLine.&amp;#39;, long_description=long_description, # 没有 README 这一项可以不要 long_description_content_type=&amp;#34;text/markdown&amp;#34;, install_requires=[ # 该包的依赖包，安装时会检查是否满足依赖要求 &amp;#39;pandas&amp;#39;, &amp;#39;seaborn&amp;#39;, &amp;#39;scipy&amp;#39;, &amp;#39;scikit-learn&amp;#39; ], packages=setuptools.find_packages(), # 该库中含有的包，一般就自动搜索 author=&amp;#39;Zeesain Tsui&amp;#39;, author_email=&amp;#39;clarenceehsu@163.</description>
    </item>
    
    <item>
      <title>使用 exe4j 打包 Java 程序</title>
      <link>/posts/2020/20200318-%E4%BD%BF%E7%94%A8-exe4j-%E6%89%93%E5%8C%85-java-%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Wed, 18 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/20200318-%E4%BD%BF%E7%94%A8-exe4j-%E6%89%93%E5%8C%85-java-%E7%A8%8B%E5%BA%8F/</guid>
      <description>上回说到，因为要提交一个加密算法的作业，我用 Java 写了加密程序以及用 Python 写了文本比较程序做校验。因为老师需要提交一个工程项目，所以为了测试方便我们需要将这些程序打包成可执行文件。对比了那么多的 Java 打包软件，我最终使用了 exe4j 软件进行 Java 程序的打包。
JRE 因为 Java 程序的运行需要 JVM，所以我们需要一个 jre 的包去给 exe 文件提供环境。一般在 JDK 的文件夹里会带有一个 jre，如果没有的话可以网上找资源下载或者直接通过 JDK 生成，方式如下：
以管理员身份运行 CMD，并且 cd 到电脑的 JDK 的目录里面（没有管理员身份可能会失败）； 执行 bin\jlink.exe --module-path jmods --add-modules java.desktop --output jre 生成 jre，已生成相关目录会报错； 生成完毕，可以复制到项目文件夹 生成 jar 程序 jar 程序就不多介绍了，因为我目前使用的 JetBrains 全家桶，所以直接用 IDEA 生成 jar 程序，复制出来供后续打包使用。
exe4j exe4j 可以从官方渠道下载，软件本身是免费的，如果不使用 Lisence 就会在运行的时候弹出一个警告窗口。此时我们可以在网上去找 Lisence 码来用，软件本身没有其他的检查机制，都是可以使用的。在主界面的下方填入序列号（其他的随便填）即可生成纯净的程序。
这一部分的步骤基本上可以参考其他的教程，但是这里面会出现一些问题，列在下方：
路径问题 这是一个老生常谈的问题了，路径中不能够出现中文，否则会出现 jre 无法使用的问题。
都 2020 年了，现代编译器都已经支持中文了，这属实有点说不过去。
jre 路径问题 在生成程序的 JRE → Search sequence 设置项中，是 jre 的索引顺序，它会按照这个顺序去搜索引用 jre 程序作为 Java 程序的运行环境，在这里我们直接把这个设置为项目文件夹里的 jre 目录，这样只要文件夹完整，在别人的电脑里面也能直接使用。</description>
    </item>
    
    <item>
      <title>使用 pyinstaller 打包程序及路径问题</title>
      <link>/posts/2020/20200317-%E4%BD%BF%E7%94%A8-pyinstaller-%E6%89%93%E5%8C%85%E7%A8%8B%E5%BA%8F%E5%8F%8A%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Tue, 17 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/20200317-%E4%BD%BF%E7%94%A8-pyinstaller-%E6%89%93%E5%8C%85%E7%A8%8B%E5%BA%8F%E5%8F%8A%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</guid>
      <description>最近有一门课的小组任务要求完成 AES 加密算法，语言不限，并且提交一个完整的工程和测试程序，还要附上 README。因为对我来说难度稍微低一些，我就直接把这个给做完了。（微笑）
为了锻炼一下我的 Java 水平和能力，所以我一开始打算全部用 Java 来写，但后来因为偷懒不想写为了展现我们灵活而全面的技术栈，所以我就用 Python 写了一个文件对比的脚本。
pyinstaller 的安装 考虑到 Windows 各种各样的使用环境，我们直接发一个 .py 的脚本是不一定能够在其他电脑上正常运行的。因此为了方便就必须要给程序做打包，把 Python 的环境全部打包到一个二进制文件里面，这样就能够做到独立运行了。
pyinstaller 是一个专门用来做 Python 脚本打包的库，如果没有可通过 pip install pyinstaller 进行安装。
这里建议使用虚拟环境去安装 pyinstaller，它会根据环境中的库情况进行打包，如果使用的库多了会导致打包出来的程序会特别地大。如果在虚拟环境中做库的删改都会更加方便。
开始打包！ 完成安装后就可以开始打包的操作了，首先需要 cd 到 .py 文件对应的目录文件夹，这样就可以保证生成出来的文件都在目录里面，整理比较方便。
pyinstaller 常用的命令有两个：
pyinstaller -D app.py pyinstaller -F app.py 其中的 app.py 为要打包文件的相对地址，-D 是默认命令，即生成一个目录文件，里面包含了一个启动程序和一系列的依赖文件；-F 是生成单个可执行文件的命令，它生成 build 和 dist 文件夹，其中 dist 文件夹里面的可执行文件是可以单独使用的，其余项可以删掉。
它的原理很简单粗暴，就是将 Python 复制出来，连着脚本一起打包进去，执行的时候再全部解压到缓存文件夹里执行脚本文件。
路径问题 打包完成之后就可以拿出来使用了，因为里面集成了 Python 的 runtime 环境，所以不管电脑里面有没有装 Python，各种姿势使用都不会影响。
正当我以为完成之时，打开程序直接闪退。从 CMD 打开才发现程序出现了错误，要访问的文件访问不到，这时我才发现程序执行的目录（一个在 Roaming 中的缓存目录）和这个程序放的目录不是一致的，所以直接用相对地址根本访问不到所需要的文件。</description>
    </item>
    
    <item>
      <title>ASC20 比赛记录 - 3</title>
      <link>/posts/2020/20200303-asc20-%E6%AF%94%E8%B5%9B%E8%AE%B0%E5%BD%95-3/</link>
      <pubDate>Tue, 03 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/20200303-asc20-%E6%AF%94%E8%B5%9B%E8%AE%B0%E5%BD%95-3/</guid>
      <description>ASC20 比赛因为疫情的原因，proposal 的提交延期了一个多月，所以中间我也休息了一段时间。最近随着诸多工作的完成，ASC 20 的比赛之旅也渐渐到了尾声。
题目 这一次的赛题是有关 NLP 方向的，要在只使用 Pytorch 框架的情况下完成 Cloze 下游任务的设计，并且以准确率作为最终的分数计算。
主办方并未提供 baseline，只提供了数据集，格式为 json，具体如下：
{ &amp;#39;article&amp;#39;: &amp;#39;...&amp;#39;, &amp;#39;options&amp;#39;: [[words * 4] * 20], &amp;#39;answers&amp;#39;: [&amp;#39;A&amp;#39;,&amp;#39;B&amp;#39;... * 20] } 目前的进展及思路 在之前的训练的过程中出现了一个比较恼人的问题，最早我采用的是 4 分类，但是网络会出现不收敛的问题，我尝试了许多的手段（正如之前所提到的那样）也是没有办法去解决。后来经过检查和与师兄的讨论才发现作 4 分类本身就比较难作拟合——可能根本就没有拟合，毕竟样本太少，每一部分的文字又太多，导致 embedding 出来的矩阵差距较小。
后来采用了 2 分类效果就好了很多，因此目前训练的成果已经成功追上了 1 队。而且由于 Transformers 在训练的时候能够自动判断 GPU 的环境使用分布式训练，所以还是很顺畅地做了分布式训练。</description>
    </item>
    
    <item>
      <title>这世界需要有人平淡地活着</title>
      <link>/posts/2020/20200302-%E8%BF%99%E4%B8%96%E7%95%8C%E9%9C%80%E8%A6%81%E6%9C%89%E4%BA%BA%E5%B9%B3%E6%B7%A1%E5%9C%B0%E6%B4%BB%E7%9D%80/</link>
      <pubDate>Mon, 02 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/20200302-%E8%BF%99%E4%B8%96%E7%95%8C%E9%9C%80%E8%A6%81%E6%9C%89%E4%BA%BA%E5%B9%B3%E6%B7%A1%E5%9C%B0%E6%B4%BB%E7%9D%80/</guid>
      <description>20 岁，老大不小了，记录下简单的想法，我平时很少写文章，所以各位凑巧看到这篇文章，娱乐就好，也没必要当真。
我这个人平常不太喜欢收集名人名言，一是我读的书少胸无点墨，没这兴趣；二来有很多名言需要联系上下文思考，而非单拎出来摘头去尾。不考虑作者心境地捯饬，结果往往自相矛盾——王小波在前文写着“强忍悲痛，活在这个世上”，后文又写着“生活是天籁，需要凝神静听”——对我这样不常写文章的人来说毫无裨益。
但为了引入想法，我还是查了查最近几年的网络语录。
罗振宇在奇葩说里面说，成长的本质就是变复杂；成长就是主观世界遇到客观世界之间的那条沟，掉进去叫挫折，爬出来叫成长。说白了一句话，“成长复杂而曲折”。
插个题外话，我不太喜欢奇葩说这个节目，罗振宇更甚。节目里辩手辩论 + 观众投票的结构根深蒂固，专业辩手们为了博得选票而常常采用 mindfuck 的形式输出观点，少了很多硬性的理论支撑。最后采访时只能摇头说上一句“没办法观众喜欢这个”，硬生生把调性降了格。
那么什么是成长？很多人更偏向把成长等同为思维境界的提升，是修为的结果。我觉得这并不准确，成长并非每天一点一滴积累而成——类似一种“一天提升一分，一百天提升一百分”的状态——而是一大段时间我可能都呆在原地，但某一刻顿悟了些道理，整个人便有了多方面的提升。这和玩王者荣耀是相通的，玩了很久都是青铜，可有一天明白了铭文的作用，就上了铂金；突然懂了出装，就上了星耀；突然懂了配合和节奏，就上了王者。成长的过程必然重要，但我依然认为引发质变的顶点更为关键。
而成长的过程，就是活着。世界那么大，五十六个民族五十六枝花，活法儿各不相同，自然有的人光鲜亮丽，有的人平平无奇。毕竟这世界需要有人平淡地活着，像我这样的人也一定不少，甚至可称平平无奇的标准模板。
出身普通而平凡，随大流上了就近上了小学、初中和高中，成绩一般，该贪玩时贪玩，该闹腾时闹腾。高中生活充满了考卷和知识点，奈何天资一般，但勉强还有学上。电影里面那些美好和动人都没遇见过，没有心动的女生，也没有遇见爱情；唯一一次和女生牵手是在游戏上，牵的还是袖套；走大街上没人在意，丢人堆里就是沉默的大多数；查资料费心思写了篇知乎回答，一个赞也没有，评论还有两个怼我的。这样的经历让我骨子里便带着平凡。
罗素曾经说过，“人的情绪起落是与他对事实的感知成反比的，你对事实了解得越少，就容易动感情”，所观世界，的确炎凉。
因为在这个世界上，还有人通过知识或者父母关系一路保送世界知名学府；还有像孙宇晨这样的人，通过高考移民和钻空子上北大还能够正常毕业。如今各式各样的大企业家，背后都少不了慷慨的资产扶持。这个世界总是再告诉我们只要努力就能成功，但无奈现实就是普通人想成功会比有家室有背景的人难上很多——在国外更难，因为中国有高考这样公平的机制，还允许阶级流动，一代一代往上爬——雷军大概就是普通人所能够达到的顶峰，这也是我十分佩服他的原因。
由此，在我们年轻人这个群体之中，便始终蔓延着一股“佛系”的潮流，所谓“不争不抢爱谁谁，百舸争流我腾地儿”的姿态。这样的态度在一开始可能会有着些许的豁达，或者与世无争的高山流水之感，但长久看来这其实不好。因为我觉得所谓的佛系心态其实更多地是一种对社会发展快速，人才内卷竞争加重这一普遍社会现象的自我逃避。还有当代年轻人在阶级固化的背景下，逐渐成为社会主力军的无奈——阶级固化不会那么明显，但一定存在。
李诞是我挺喜欢的一个站立喜剧演员，他就是典型的“佛系青年”，典型到我怀疑“佛系”这个词就是从他那儿传出来的。显然他并不是真正的“佛系”，毕竟行业翘楚，有谁是不争不抢也能遍地拥趸，饭碗就给送到手上的呢？这反而更像是他作为一个喜剧演员自然带着的一种人设或者调侃的包袱。周围很多人喜欢这样的“佛系”心态，学得好的人把这样的心境当成自我安慰或者生活调剂的手段，学不好的可真就废在了家里，啥也不干凑合凑合过日子，活脱一个西欧国家吃福利的吸血鬼。
当然我并没有去批判任何一种生活方式，因为我觉得这些是社会经济发展下的必然产物，只是碰巧不太符合我自己的价值观罢了。我个人是非常喜欢价值观之间的碰撞的，这样往往能够带来很多思考和有趣的观点。
写了这么多，也算是了结了我最近的一些想法，一个朴素的人，一行朴素的字。这个世界需要有人平淡地活着，20 岁的我，也该瞧瞧这个世界了。</description>
    </item>
    
    <item>
      <title>【瞎扯 2】疫情之下</title>
      <link>/posts/2020/20200218-%E7%9E%8E%E6%89%AF-2%E7%96%AB%E6%83%85%E4%B9%8B%E4%B8%8B/</link>
      <pubDate>Tue, 18 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/20200218-%E7%9E%8E%E6%89%AF-2%E7%96%AB%E6%83%85%E4%B9%8B%E4%B8%8B/</guid>
      <description>相信对于很多人来说，这个新年并不好过。开年便碰到了几十年难一遇的全国乃至全球性的疫情，就连我们的 ASC 比赛也被迫暂停了脚步，延期到了 4 月中旬提交 proposal。所以，趁着这段时间，我也是做了一些思考，以此作为记录；文章中的内容仅代表我此时的观点和立场。
本人思维可谓浅薄，所言之物只供娱乐，如有雷同不胜荣幸。 （后记：此文之前写的不够完整，所以后期经过了修改）
回顾 让我们来简单回顾一下这一次的疫情经历（这一部分参考了这篇博客，并做了简化）：
2019.12.08 | 武汉市民就诊，疑似 27 例感染； 2020.01.01 | 8 名网民在未经过核实的情况下发布肺炎的不实信息； 2020.01.09 | 确定病原体为“冠状病毒”； 2020.01.11 | 出现首例死亡病例； 2020.01.13 | WHO 正式将其命名为“2019 Novel Coronavirus 新冠状病毒”； 2020.01.20 | 钟南山团队确认存在“人传人”；湖北省应急管理厅成功举办春节联欢晚会； 2020.01.21 | 武汉实施进出管制； 2020.01.23 | 武汉参考“小汤山”，开始建立专门医院；口罩已经开始脱销； 2020.02.01 | 上海药物所：双黄连可以抑制病毒（存疑），双黄连脱销；武汉红十字会存在调拨物资不及时等问题； 2020.02.02 | 火神山医院完工，医院交付部队； 2020.02.03 | 确诊病例家中门把手检测出病毒核酸；火神山接诊首批患者； 2020.02.04 | 正式开学前禁止网上教学；武汉领导被问责，福建170名官员被查处； 2020.02.06 | 样式春节元宵晚会取消观众设置；李文亮医生去世。 这个时间表我只取出了网络上广泛讨论的部分，看着下来这两个月，前线的医护人员和部队战士，特别是“敲钟人”李文亮医生，他们值得在这个时代被铭记。
当然，在外网上我也看到了许多其他的言论，听到了不一样的声音。有的虽然合理，但很快被辟谣，有的天花乱坠，连玄幻小说都不敢这么写；“造谣一张嘴，辟谣跑断腿”，我们作为新时代的顶梁柱，除了对这些言论客观性看待外，能做的还真只有相信政府~~（还有待在家）~~。
对于学生群体的影响 对我们学生群体来说，这个寒假格外地长。我个人因为要比赛和学习，所以整个疫情期间还要忙里偷闲，不至于太无聊。因为要远程上课和远程办公，对着电脑的时间倒是明显增多，玩游戏的时间也多了不少。疫情的这段时间的活动安排其实一句话就可以总结——我一直在起床—吃饭—电脑—吃饭—电脑—楼下散步—电脑—睡觉这样的一个节奏中度过，当然这并不无聊，因为网络的世界还是在的，甚至因为时间安排显得有点忙。
当然我只是一个个例，对于大部分学生群体，尤其是大学生群体，因为禁足没有办法出门聚会游玩，自然也是少了很多兴致，朋友圈里哭诉“无聊的家里蹲生活”的人也比比皆是。不过大多数人还是能够耐得住性子的，毕竟在哪儿不是学啊，哪怕在家里作业一天也不能晚交，课一节也不能旷。
在我看来，这一次疫情影响最小的便就是我们这些生活在象牙塔下的学生群体。没有来自各方面的压力，所以自然也没有什么特别大的感受——当然有的家庭因为父母职业原因会有很大影响——只是平时要多注意防止感染。
那么这次影响最大的群体，又是谁呢？
疫情之下的经济冲击 这一块的内容部分参考了老蒋的视频，他从泛财经自媒体这样的一个角度分享了他的很多观点。
影响最大的莫过于小微型企业了，他们承担着小几百万的现金流，这样长达一个季度的停工必定会对现金流和生产造成巨大的影响。
对于大企业来说，这样的“黑天鹅事件”影响并不是致命的。一是有着强大的资金流，他们亏得起，顶多是裤袋掏空，小企业无异于截肢（有的甚至眉毛以下截肢）；二是有着庞大的线上业务，比如腾讯网易这样的线上巨头，他们所承受的冲击自然会比实体经济为主的企业来的要小，甚至因为全民禁足，在线上娱乐方面反倒有了盈利增长（参考王者荣耀）；第三个便是大企业有着一定的海外业务，这些并不会随着国内疫情的进一步蔓延而受到影响。
视频中采访了 11 位小微企业的老板，除了一开始的专注于东南亚在线音频服务的互联网公司，其余的影视、婚庆、旅游、租房等行业都遭到了不小的影响，已经基本停业，线下教育的机构也因此扩展了线上教学的运营方式；餐饮行业不仅仅是小企业，大企业也处于停摆边缘；</description>
    </item>
    
    <item>
      <title>ASC20 比赛记录 - 2</title>
      <link>/posts/2020/20200208-asc20-%E6%AF%94%E8%B5%9B%E8%AE%B0%E5%BD%95-2/</link>
      <pubDate>Sat, 08 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/20200208-asc20-%E6%AF%94%E8%B5%9B%E8%AE%B0%E5%BD%95-2/</guid>
      <description>ASC20 比赛已经到了中段，是时候给最近的工作做一下总结了。
题目 这一次的赛题是有关 NLP 方向的，要在只使用 Pytorch 框架的情况下完成 Cloze 下游任务的设计，并且以准确率作为最终的分数计算。
主办方并未提供 baseline，只提供了数据集，格式为 json，具体如下：
{ &amp;#39;article&amp;#39;: &amp;#39;...&amp;#39;, &amp;#39;options&amp;#39;: [[words * 4] * 20], &amp;#39;answers&amp;#39;: [&amp;#39;A&amp;#39;,&amp;#39;B&amp;#39;... * 20] } 目前的进展及思路 之前所尝试过的预先填词的方法可行性不高，所以只能够将所有的词填进去。我们的算法是以每个空的四个选项去生成四句话，如果出现了一句话多个空的情况，则留空不填，然后以此生成了总共空数 * [ 4, 预填空句子 ] 的矩阵。
然后就得提取特征了，用 BERT 的预训练模型 bert-base-uncased 生成向量矩阵，其中每一句话都会生成一个 [1, 768] 的向量，然后存入 .npy 文件中。把答案的 ABCD 转换为 [1, 4] 的 onehot 向量，也存入另一个 .npy 文件中，供后面训练使用。
训练我们使用的是 BiLSTM + Attention Net，通过注意力机制来提高准确率。
存在问题 目前训练了几波，存在这一些问题：
out of memory 这个是老生常谈的问题了，主要的原因是 batch_size 设置得过大，从而导致显存使用过高。第二个是未终止之前的训练过程，之前通过 nohup 等手段运行的训练不会自动退出，需要主动 kill 掉。</description>
    </item>
    
    <item>
      <title>【瞎扯 1】《爱情公寓 5》和盗版</title>
      <link>/posts/2020/20200201-%E7%9E%8E%E6%89%AF-1%E7%88%B1%E6%83%85%E5%85%AC%E5%AF%93-5%E5%92%8C%E7%9B%97%E7%89%88/</link>
      <pubDate>Sat, 01 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/20200201-%E7%9E%8E%E6%89%AF-1%E7%88%B1%E6%83%85%E5%85%AC%E5%AF%93-5%E5%92%8C%E7%9B%97%E7%89%88/</guid>
      <description>我打算开一个坑，就叫瞎扯，这个名字一听就知道是瞎起的。
本来想以语音的形式去记录的，但是由于录音的质量和存储等问题，我便把语音转成文字，然后简单编辑一下保存成了文档。
那么这样的分类是为了什么呢？主要是想法的表达地，然后希望能够就是记录一下我自己的想法，然后分享给大家。因为第一篇没有什么好的点子，所以主题便定为瞎聊。
爱情公寓 5 大家都知道，最近有一部非常火的电视剧——《爱情公寓 5》正式完结了，然后 VIP 就可以多花 25 块钱享受超前点播直通大结局，和《庆余年》一样一口气看完整一部剧；如果不想花这个钱就只有两种选择，一种是等着，另一种就是出门右拐看盗版。而盗版的问题，我们一会儿再聊，我们先来聊一聊《爱情公寓》。
相信《爱情公寓》是很多人的童年回忆，毕竟出的比较早。大概是 09 年的时候第一季播出，那个时候我大概十岁，而我接触到爱情公寓的时候，我并不知道它抄袭。所以当时看的话还好，后来在 B 站有一个 up 主叫做残狼之卑，他在自己的频道里发了非常非常多的关于《爱情公寓》的剧情、场景布置等等方面的抄袭史。在那个时候我才发现爱情公寓前几季中有相当多的抄袭美剧英剧里面的各种桥段，然后瞎捯饬到了一起。这样导致的结果就是它会在剧情上面产生非常多的割裂，毕竟是从不同的来源拼凑的剧情。
而第五部的话，导演韦正本人也说不会再有所谓的“致敬抄袭”的桥段了。在我目前看来的话抄美剧的现象的确少了很多，但很多梗也依然是抄袭了网上的知乎、豆瓣上面的那些经典的帖子。
除开剧情之外，我最印象深刻的便就是诸葛大力这个角色了。抛开炒作、营销方面的因素，诸葛大力这个角色及演员成果这个人本身，在网络上也是引起了非常广大的讨论，特别是虎扑、知乎这些社交地。
正如我在日志中写的那样，我会觉得这种角色——不论是诸葛大力，还是其他的的那种类似于全知全能的角色——存在的本身应该就是为了去填坑，或者说是完成一些“擦屁股”的剧情桥段推进（很多的不合理放在这个角色上就合理了，比如会开挖掘机还会开飞机），这种类型的角色其实更像是一种万金油。
盗版 说到盗版，在《爱情公寓 5》当天解禁，可以花钱付费点播到大结局那一段时间，盗版资源立马就出来了，资源也是非常的多，网上一搜到处都是。
对于这些盗版行为，我一开始对优爱腾，就是优酷，腾讯，爱奇艺这些视频服务提供商有着一些倾向。因为我自己本身也是从事互联网行业的，然后对这里面的细节也比较清楚，做视频服务非常烧钱。第一个就是带宽费，中国带宽费很贵，成本很高，然后视频流的存储以及维护也是非常的烧钱。因此，这些老牌的视频厂商想通过价格歧视的手段分层多捞一些油水也在情理之中。
但后来随着社会舆论的发酵，我了解到了其中的更多的细节，然后也对这些事情有了许多不同的看法。说白了，视频服务方作为一个提供服务的资本方，他坏就坏在他没有事先说明，从而导致许多人“大呼上当”，消费者们怨声载道。其实这两者之间并没有谁对谁错，都是在不停地在探底线。
当然我觉着这样子的冲突也是挺好的，反而能够督促这个市场走向透明化，合理化，也能够尽早让视频服务这个常年亏损的行业走向正轨。
韩国欧巴 最近看到一则新闻，某一个正在服役的韩国明星生日，国内的一些饭圈女孩因此就给韩国部队送物资。这件事情在网络上也是发酵了非常久，引发了很多人的不满。这种所谓应援到底说不说得过去呢？
我觉得这些女生有追求偶像，给偶像送礼的自由，送礼无可厚非，但是姿势水平不够。说白了就是涉世太浅，并没能够很好地把握尺度，尤其是在如今这样的社交发达的社会条件下，如此之举必然会引起口诛笔伐；哪怕这些女孩并没有其他的想法，就是像给一个他们喜欢的偶像过过生日，也会被扣上一个不忠不义不仁不孝的帽子。
之后我看到了一个兵哥哥的评论。他在海南服役，他说自己在海南部队，没有人送礼，而送给了远在他乡的外国部队。乍一听我感觉到了一些难受，但仔细一想——这倒有点道德绑架之嫌。</description>
    </item>
    
    <item>
      <title>记一次服务器的维护</title>
      <link>/posts/2020/20200129-%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BB%B4%E6%8A%A4/</link>
      <pubDate>Wed, 29 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/20200129-%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BB%B4%E6%8A%A4/</guid>
      <description>最近因为某些不可言说的原因，我趁着农历春节优惠，用 8.88 $ / 年的价格购了一台国外服务器。
在搭好了所有环境之后，已经可以正式地部署使用了，于是我开始愉快地玩耍起来。但后来我逐渐发现，在登录服务器的时候，SSH 时 Authentication 过程相当地漫长；毕竟服务器地处遥远，我也没当回事。
直到后来服务器密码被改掉了，我才发现原来服务器被人黑了。
破解密码 我一开始设置的初始密码为 12345678（当时也不知道网络上坏人竟然这么多），所以也十分容易被暴力破解。
怎么解决呢？难道就这样把自己的服务器拱手让人了吗？不，我赵铁柱是不会这么容易屈服的，于是我很快找到了解决办法。
入手点就在于服务器的提供商在后台也给我们了一系列的运维选项，以方便我们做一些服务器以外的操作，如重装系统，更改 IP 等。我好不容易搭好了环境，不想就这么重装了，所以我打算通过 VNC 来解决。
VNC 是虚拟网络控制台的缩写。它是一款优秀的远程控制工具软件，由著名的 AT&amp;amp;T 的欧洲研究实验室开发。VNC 是基于 UNIX 和 Linux 操作系统的免费开源软件，远程控制能力强大，高效实用，其性能可以和 Windows 和 MAC 中的任何远程控制软件媲美。
VNC 的好处在于它会完全显示服务器当前所显示的画面，就相当于是一个远程的显示器。所以通过内网的 VNC 连接到服务器，然后点击右上角的按键重启：
然后便是熟悉的启动界面，在 boot 状态下点击 esc 键，打断 GNU GRUB 引导，此时可以对启动项进行更改设置等操作。这个时候的操作 CentOS 6 和 CentOS 7 是不一样的，我是 CentOS 7，所以直接进入配置文件，设置为单用户模式，重新引导启动。
此时已经可以进入 root 用户了，然后使用 passwd 命令字改密码即可。
设置了强密码后，SSH 的速度还是很慢，正当我找不到原因时，SSH 连接服务器后系统提示我有 4000 多次失败的登录。
还在搞我？ 我用 lastb 命令看了一下，有两个来自江苏连云港的电信 IP 一直在试 root 密码暴力破解服务器，大量占用 22 端口的资源导致我连接过程缓慢。</description>
    </item>
    
    <item>
      <title>如何利用 BERT 提取句向量</title>
      <link>/posts/2020/20200118-%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8-bert-%E6%8F%90%E5%8F%96%E5%8F%A5%E5%90%91%E9%87%8F/</link>
      <pubDate>Sat, 18 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/20200118-%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8-bert-%E6%8F%90%E5%8F%96%E5%8F%A5%E5%90%91%E9%87%8F/</guid>
      <description>BERT 在 NLP 方向中是一个十分具有里程碑的模型，那么如何通过 BERT 提取一个句子的句向量呢？
网络上的资料还是很多的，由于比赛要求只使用 Pytorch 框架，所以很多基于 TF 的教程和库就没办法用了。在查询了部分资料后，我终于总结出了一个提取的方法：
这一篇总结我会尽力写得通俗易懂，一读就明白。
算法解释 import torch from pytorch_pretrained_bert import BertTokenizer, BertModel, BertForMaskedLM 导入 torch 和 pytorch_pretrained_bert 库，站在巨人的肩膀上，直接缩短大量的训练时间。
tokenizer = BertTokenizer.from_pretrained(&amp;#39;bert-base-uncased&amp;#39;) # 导入预训练模型 tokenized_text = tokenizer.tokenize(text) # tokenize 输入的文本 indexed_tokens = tokenizer.convert_tokens_to_ids(tokenized_text) # 向量化 这一部分的代码主要是将输入的文本转化为 tokenized 的文本，然后再把该文本给向量化。
问题来了，什么是 tokenized 和向量化？ tokenized 即标记化，把输入的句子进行标记划的操作，举个小例子：
tokenized_text = tokenizer.tokenize(&amp;#39;Hello world !&amp;#39;) &amp;gt;&amp;gt;&amp;gt; [&amp;#39;hello&amp;#39;, &amp;#39;world&amp;#39;, &amp;#39;!&amp;#39;] 大家可能注意到了，为什么字母全部为小写了？这是因为我们使用的模型 bert_base_uncased 是不分大小写的，所以输出的 tokenized_text 会全由小写表示。
其实 BERT 还支持输入两个句子，但是需要放在同一个字符串中，并通过一个标记来表示一个句子的开始和结束，再举个小例子：
tokenized_text = tokenizer.tokenize(&amp;#39;[CLS] Hello world!</description>
    </item>
    
    <item>
      <title>ASC20 比赛记录</title>
      <link>/posts/2020/20200116-asc20-%E6%AF%94%E8%B5%9B%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Thu, 16 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/20200116-asc20-%E6%AF%94%E8%B5%9B%E8%AE%B0%E5%BD%95/</guid>
      <description>ASC20 比赛在 1 月 6 号正式开始了，我在 1 月 10 号也正是接题开始了比赛的相关工作。因为这是我第一次以学校的名义参加全球性的赛事，所以特地记录下这段时间内的学习历程和思路。
题目 这一次的赛题是有关 NLP 方向的，要在只使用 Pytorch 框架的情况下完成 Cloze 下游任务的设计，并且以准确率作为最终的分数计算。
主办方并未提供 baseline，只提供了数据集，格式为 json，具体如下：
{ &amp;#39;article&amp;#39;: &amp;#39;...&amp;#39;, &amp;#39;options&amp;#39;: [[words * 4] * 20], &amp;#39;answers&amp;#39;: [&amp;#39;A&amp;#39;,&amp;#39;B&amp;#39;... * 20] } 学习 这一次的路线就非常直观了，需要走 NLP 方向，而 NLP 目前最为热门的网络模型就是 BERT。类似 ResNet 之于图像识别的网络，这是一个 NLP 中炙手可热，同时也十分常用的模型，而我们可以通过这个模型达到 word2vec 的效果，提取出文字中的向量信息，并输送到下层网络以完成下游任务。
所以我就打算使用 BERT 作为网络中的 embedding 部分，然后下层在进行 Cloze 的填空操作。在网上简单查找并且学习了 NLP的一些实现细节，我发现了 transformer 这个网红模型，并且有了许多的预训练模型，所以我便选择了以 transformer 为基础去完成题目。
目前的进展及思路 目前我已经基本看完了 transformer 中的 example 代码文件，并且对其工作原理有了基础的了解，可以开始准备数据集进行训练了。
我此外则有着以下的一些不成熟的小想法：
以我在观摩别人打比赛和自己比赛的经验，我会偏向于直接使用 pretrained 模型或者以其为底作迁移学习； 通过 BERT 提取特征并且进行猜词，然后与选项进行比对，如果不存在于选项中则需要通过比对 similarity，然后比较取最为相似的单词作为选择。 把选项放入原句中，然后通过 MRPC 下游任务计算句子的连贯性，取连贯性最高者。 考虑到上下文（比如 He or She 性别判断之类的选择），可能还需要通过另一个网络提取关键信息。 我针对第 2 点完成了基本的代码工作，但是目前就成果和效率来看，还是存在一定的不足，后续会对其进行改进，同时也会往多个方向进行探索~~，毕竟现在时间还多~~。</description>
    </item>
    
    <item>
      <title>2019 年度总结</title>
      <link>/posts/2020/20200115-2019-%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</link>
      <pubDate>Wed, 15 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/20200115-2019-%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</guid>
      <description>2019 年过去了，努力了一个年头，完成学业，精进自我，有过遗憾和泪水，也有过成就和欢笑。这一次的年度总结，我想从几个关键词开始。
双学位 我主修读电信专业，同时还是一名翻译专业的学生，而这也是我权衡之后的选择。在 1 年半之前，我斩钉截铁地选择了这一条路；而如今这条路也让我觉得，这么久的付出，十分值得。
在这一年里，我没有了双休日，考试周的进程从一个月变成了两个月；不仅修读了许多翻译的项目，也更新了我很多的理解。如今双学位的旅程已经接近尾声了，希望以后能够继续努力，多多加油。
比赛 一个是数据挖掘比赛，这类型比赛没有什么经验，不过当时一位商学院大佬拉我一起，于是便上了车。因为经验较少，用 Python 做出了一个模型，然后一顿分析写了一篇论文交了上去。没想到最后拿到了全国二等奖和省级一等奖，这也算是有了一个小小的成果。
其实我在后来的复盘发现，我当时的水平一般（当然这也是因为比赛时间仓促，做到哪儿写到哪儿），还有许多提升空间，而这也间接地提醒了提高自己的代码水平和算法能力。
第二个便是 ASC，全球大学生超级计算机大赛，这个比赛我还是挺想参加的，而经过面试之后我也是成功加入了校队，现在还在为模型头疼中。
项目 这一年里我也参加了许多的项目，无论是大创还是挑战杯，亦或是研究所中的项目。我再其中也担当了许多的角色，不过最多的是算法实现，所以这也成为了我以后的学习方向。
尾巴 这一年做了许多的事儿，我也希望以后能够继续努力，并多多督促自己，完成更多目标。</description>
    </item>
    
    <item>
      <title>Photobash 练习 - 赛博朋克钟楼</title>
      <link>/posts/2020/20200110-photobash-%E7%BB%83%E4%B9%A0-%E8%B5%9B%E5%8D%9A%E6%9C%8B%E5%85%8B%E9%92%9F%E6%A5%BC/</link>
      <pubDate>Fri, 10 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/20200110-photobash-%E7%BB%83%E4%B9%A0-%E8%B5%9B%E5%8D%9A%E6%9C%8B%E5%85%8B%E9%92%9F%E6%A5%BC/</guid>
      <description>每当我抬头望着学校，后面的高楼映着前面的钟楼，一股赛博与静谧的相交融感油然而生。于是，作为一名赛博朋克的爱好者，我突然来了灵感。
前期 考完试，我便拿着相机登上宿舍楼顶，在之前探过的机位，找了不同的景别去拍了底图。
导入 LR，选出了其中最符合我想象的一张：
调色 基于图片的内容，我选择了蓝紫调作为调色方向，然后加上了一些绿色作为底色，以提供一些胶片感：
调光 此时的图缺少了一些氛围感，并且整体光线比较平，所以压低底部的高光和钟楼的反光：
添加赛博朋克元素 我按照我的想象（一位僧侣站在钟楼上，正在被无人机追杀），添加上了相应的元素并做一定的调整：
除此之外，在楼群背景上的赛博朋克元素比较少，所以继续往上加：
这个时候，已经有内味儿了。
稍加修饰 因为赛博朋克的一个重要标签就是环境污染严重 + 下雨，所以再调整光效，并加上一些烟雾、雨水去修饰，不仅氛围感就有了：
对比 最后来一个原图和现图的对比：
原图 后期 </description>
    </item>
    
    <item>
      <title>防止过拟合和提高泛化能力的技巧</title>
      <link>/posts/2019/20191124-%E9%98%B2%E6%AD%A2%E8%BF%87%E6%8B%9F%E5%90%88%E5%92%8C%E6%8F%90%E9%AB%98%E6%B3%9B%E5%8C%96%E8%83%BD%E5%8A%9B%E7%9A%84%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Sun, 24 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/20191124-%E9%98%B2%E6%AD%A2%E8%BF%87%E6%8B%9F%E5%90%88%E5%92%8C%E6%8F%90%E9%AB%98%E6%B3%9B%E5%8C%96%E8%83%BD%E5%8A%9B%E7%9A%84%E6%8A%80%E5%B7%A7/</guid>
      <description>深度学习是一个很奇怪的过程，有人说它是“深度炼丹”，有人说它是一个黑盒，超参调整就是玄学。
事实上，我们不可能在深度学习中寻找到所谓的“最优解”，我们只能够在自己的能力范围之内寻找到局部的最优解，而如何提高自己网络模型的分类或者生成能力也自然有着许多的技巧。
数据 深度学习最需要的，就是数据，一个好的数据集可以让神经网络的训练事半功倍。在我看来，数据在保证质量的前提下多多益善，样本数据越多，模型拟合的效果就会越好。因此首先，尽可能多地寻找优质数据集。
Data Augmentation 而如果在数据集不够时，对数据的预处理就显得十分重要，对原先数据的处理扩增被称作 data augmentation，方法主要是下面的几种：
对于语音或者图像，可以在原本的数据上加噪声，或者进行缩放，镜像等操作； 对于数值类向量，可以在原先的数据基础上进行随机； 文字类数据，我觉得并不会缺少数据集（笑）。 在数据中添加噪声，或者平移缩放等操作在很多比赛以及网络中已经证明了，可以很好地提高模型的泛化能力。
数据归一化 这是一个老生常谈的问题了，提前把数据进行归一化可以很好地防止梯度爆炸。在网络中，我们也可以设置激活函数（sigmoid、tanh等）对数据进行归一化。而激活函数也容易造成梯度消失的问题，我们可以更换激活函数，或者进行 normalize，这会在另一篇文章里面讨论。
数据本身 最后还有一个方法，就是从数据本身寻找问题。举个例子，老师职位和性别有关吗？车速和天气有关系吗？答案是否定的，所以要检查数据集中的某些特征是不是与我们要预测或分类的特征毫无关联，如果是的话就尽量抛弃。
另外，如果有其他的特征或者更加适合的方法，也需要对数据进行调整。
算法 其实在我的很多情况下，当无法采取某种特定的算法去进行数据处理的时候，便会采用深度学习其训练拟合（笑）。
选择算法 什么算法对于特定的问题效果最好，我们是没有办法也不可能知道的，只能取范围内最优，即当前使用的算法并不一定适合当前的问题。
如果没有头绪的话，可以从下面几点进行尝试：
线性算法，如逻辑回归和线性判断分析 树模型，如 CART、随机森林等 SVM 或 KNN 等算法 神经网络模型，如 CNN、RNN、LSTM 然后根据经验和结果综合判断，选择目标模型进行调参或者优化，从而进一步提升效果。
之前比赛的时候有一个大佬的解法是训练两个网络进行对抗，这个算法拿了准确率第一，当时印象挺深刻的。
算法调优 调参是一个算法调优的必经之路，主要分为以下几点：
模型可诊断性，模型总是处于两种状态，即欠拟合和过拟合之间，只是程度不同罢了。我们可以把 accuracy 和 loss 输出在图表中，从而作为一个有价值的诊断工具。 权重的初始化，用小的随机数初始化权重。 学习率，学习率决定了梯度下降时的范围，如果添加了更多的神经节点和网络层，就可加大学习率。这一点并不是独立的，与 batch size 等都有关系。 激活函数，激活函数其实有很多种，而且每一种激活函数都有一段流行的时间，如今一般都会使用 ReLU 函数，但 ReLU 本身存在着死神经元的问题，然后又诞生了 Leaky ReLU。尝试不同的激活函数可能会有不同的效果。 网络结构，网络的结构设计也会很大程度影响性能，在一般情况下，最好使用成熟的网络，或者尝试发表论文中的网络。 batch size 和 epoch，batch size 决定了梯度值以及权重的更新频率，一般设置的越大计算的速度就越快，反之越慢；epoch 则是样本参与训练的循环次数。 正则项，这可以很好地解决过拟合，如 dropout。 优化方法和损失函数，现在在梯度下降的过程中有许多优化器。默认的梯度下降方法是得到一个结果，然后调整动量值、学习率进行优化，而复杂的优化器则会有更多的参数设置，这需要多尝试去积累经验。 提早结束训练，一旦效果变差了，可以及时停止优化训练。而这一部分可以直接通过 TensorFlow 或者 Pytorch 框架中的 checkpoint 功能，自动选择和保存相应的模型训练点。 宏观调整 最后边是调出神经网络这个视角，从宏观的角度出发，把神经网络作为一个个体去看待问题。</description>
    </item>
    
    <item>
      <title>Docker Cheatsheet</title>
      <link>/posts/2019/20191112-docker-cheatsheet/</link>
      <pubDate>Tue, 12 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/20191112-docker-cheatsheet/</guid>
      <description>该版本的 Cheatsheet 由其他版本精简而来，旨在提供一个日常使用 Docker 时的速查手册。
目录 检查版本 安装 容器(Containers) 镜像(Images) 网络(Networks) 仓管中心和仓库(Registry &amp;amp; Repository) Dockerfile 层(Layers) 链接(Links) 卷标(Volumes) 暴露端口(Exposing Ports) 安全 小贴士 检查版本 时刻关注你当前正在使用的 Docker 版本是十分重要的，这能够帮助你了解可用的特性。同时，可以让你在查找镜像时选择使用的版本。接下来让我们看看如何操作。
docker version 查看你正在运行的 Docker 版本。 获取 Docker 服务版本：
docker version --format &amp;#39;{{.Server.Version}}&amp;#39; 你也可以输出原始的 JSON 数据：
docker version --format &amp;#39;{{json .}}&amp;#39; 安装 Linux Docker 官方提供了快速、易用的安装脚本：
curl -sSL https://get.docker.com/ | sh 如果你不想执行一个不明不白的 Shell 脚本，那么请看 安装说明，选择你在用的发行版本。
如果你是一个 Docker 超新手，那么你应当先去看看 系列教程。
容器 (Container) 生命周期 docker create 创建容器但不启动它。 docker rename 用于重命名容器。 docker run 一键创建并同时启动该容器。 docker rm 删除容器。 docker update 调整容器的资源限制。 通常情况下，不使用任何命令行选项启动一个容器，该容器将会立即启动并停止。若需保持其运行，你可以使用 docker run -td container_id 命令。选项 -t 表示分配一个 pseudo-TTY 会话，-d 表示自动将容器与终端分离（也就是说在后台运行容器，并输出容器 ID）。</description>
    </item>
    
    <item>
      <title>最近的一些工作小结</title>
      <link>/posts/2019/20191105-%E6%9C%80%E8%BF%91%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B7%A5%E4%BD%9C%E5%B0%8F%E7%BB%93/</link>
      <pubDate>Tue, 05 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/20191105-%E6%9C%80%E8%BF%91%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B7%A5%E4%BD%9C%E5%B0%8F%E7%BB%93/</guid>
      <description>有好一段时间没有写博客了，主要是在搞项目和学习，自然就少顾及了这一方面。所以我想在博客里写一写总结，算承上启下吧。
正如这个网站，我还是从 Django 跳回了 Hexo 的怀抱，即使我之前在 Django 的系统搭建上面花费了极大的功夫。
Django 我最近用 Django 的频率挺高的，因为大创的项目需要部署云服务做接口，所以我自然而然地在博客系统里面接了一个功能。在开始搭建的时候我把这个系统的耦合度做的挺高，因此接上额外功能不费事儿，从部署功能，写接口到测试完毕所花的时间也不长。
后面更多是优化博客的速度和数据的结构，因为我希望的是多端部署，就是写一个 Markdown 文档，能够同时应用到 Django 博客和 Hexo 静态博客之中，因此我希望的便是脱离数据库。加之本身我的博客访问量不是特别高，所以就用了普通的 IO 模式，访问网站的时候就读 Markdown 文件然后渲染，但是速度喜人，Django 和 Nginx 有缓存的时候还好，没缓存的时候就会等待个 5-6 秒，非常难受。
为了基本的可维护性和方便迁移，所以最后还是选择了 Hexo。
OneLine 这个是我一直课余时间在做的一个小项目，说白了就是平时想到什么可以抽象的就往里面写。这几天也想在深度学习方面写一些方便的高度封装的接口，让我以后可以通过更简单的代码轻松部署神经网络，但代码上还是存在些问题。
ASC 2020 ASC 世界大学生超级计算机竞赛，是一项国际的大学生赛事。不知道这个比赛的名头和历史怎么样，反正去年我们学校力压清北，成绩可人，所以我还是十分想参加的，也做了很多的准备，希望自己能够进入校队吧。
尾巴 感觉这个学期的压力是四年中最大的，一个是双学位的课开始硬核了起来，对我的英语要求也非常大；一个是做的项目也多了，如何自如行走于课内课外也十分考验耐性。学期末又是一番苦战，度过了，便就有了双休日，然后也能更加自由安排时间了。
还是要多努力呀，磨练自己的水平比任何事儿都来得重要。</description>
    </item>
    
    <item>
      <title>穷旅日志 - 广州行</title>
      <link>/posts/2019/20191006-%E7%A9%B7%E6%97%85%E6%97%A5%E5%BF%97-%E5%B9%BF%E5%B7%9E%E8%A1%8C/</link>
      <pubDate>Sun, 06 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/20191006-%E7%A9%B7%E6%97%85%E6%97%A5%E5%BF%97-%E5%B9%BF%E5%B7%9E%E8%A1%8C/</guid>
      <description>到了国庆小长假，我这个图宅于家中的人也不得向往起外面的风景。
得嘞，立马订上票，国庆第一天出发去广州。游途中的美景轶事记下来，便是这篇穷旅日志，穷的是钱包，旅的是广州。
乘着校车，一大早便到了校本部，拿着相机在校内遛弯儿，顺带拍拍景色。
我喜欢建筑，尤其是规整的建筑，既有一种庄严之感，也不乏和谐。朝霞映在石柱上，四根石柱架起上方的榫卯结构，然后便直接撑起整个建筑的中干部分。
进入教学楼，找了个合适的位置按下快门。
走在教学楼旁的林间小道，看到了高楼一角。
石牌校区相比于珠海校区，更多了一丝大学的气息，红砖百瓦，教学楼共宿舍一色。我们校区与之相比倒是少了几分学院气息，多了些小家碧玉，也倒不太像是一所大学了。
半晌，朋友到了北门，我赶忙骑行过去。相互认起，交流寒暄，解决午餐，规划路线，坐上地铁，一气呵成。
由于来广州之仓促，所以我很多事情并没有解决，导致后面的旅程颇具磨难。
第一站，中山纪念堂。
地方不大，中间一个纪念堂，四周立着柱子，入门便可看见一座孙中山雕像，周围坐落着零星凉亭，大爷大妈扇着蒲扇，纳凉消暑。
花钱买票，进入堂中。堂中间是一个会堂大厅，放映着一轮轮的关于孙中山的影片，大唐周围有着两层楼的走廊，陈列着一系列的展品。
简单浏览过后，也拍了片，就走到了一旁的越秀公园。这是一座不高的山，却爬得我腿生生酸疼，顿时少了几分游玩山水的兴致。正值国庆，人也多，有独来独往的，也有成群结队的，拿着小红旗，带着小黄帽。
上了山，便是著名的五羊像。
这和我小时候想的差别很大，由于坐落山上，五羊像的广场十分小，恰逢十一，人多便显得更挤。五羊像取景的绝佳位置被有意得空了出来，旁边架了个架子，上面写着“15 元一位”，偶尔有人站在里面拍游客照。而这些照相馆拉客也是别有一套，碰到一群游客便“大哥大姐”地叫，好不亲近；一遇到我们这些拿着相机周游的人，便如空气一般至于无物。想想也对，谁会拿着相机让别人拍照呢？
走出公园，简单歇息了一会儿，下一站定在广州老城区。
老城区商业化气息浓重，但也没有完全掩去历史的气息，建筑大多有着上世纪的感觉，老式电车融合于现代交通之中。
在城区中走走转转，逛了许多条商业街，也参观了许多有名的弄堂和坊市，路边有装修，有老法师扫街，有讨价还价，到处充斥着老街坊的气息。
走出城区，最后一站便是——广州塔。
徒步加骑行近十公里的路程，我们到达了对岸，初窥广州塔一角。
在公园歇息片刻，我走到河边找了个方便的点实拍一下：
日色渐淡，之前听说有烟火，人流也多了起来，大抵也是因此。随着人越来越多，安保人员也开始逐渐派进。
广州的夜生活是极其舒服的，少了三线城市的慵懒，也自然多了些年轻气盛的括噪，无数年轻人不断涌入，就像是火堆，众人拾柴火焰高。晚上和白天在这座城市仿佛没有了分割点，不过天色暗淡，汽车依然连轴转，天空也映得通亮。
由于当晚有烟火表演，所以许多人聚集在广州塔对面的公园中，最后也引发了一次大拥堵，干线全部飘红，地铁封站。无奈只得走去广财。
在广财，见到了几个高中同学，唠唠家常，整理下行装。由于自己的脚磨出泡了，只得取消第二天的计划。
穷旅广州，结束。</description>
    </item>
    
    <item>
      <title>让代码 Pythonic</title>
      <link>/posts/2019/20190828-%E8%AE%A9%E4%BB%A3%E7%A0%81-pythonic/</link>
      <pubDate>Wed, 28 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/20190828-%E8%AE%A9%E4%BB%A3%E7%A0%81-pythonic/</guid>
      <description>在 Python 中打上 import this，就会出现熟悉的 The Zen of Python。
&amp;gt;&amp;gt;&amp;gt; import this The Zen of Python, by Tim Peters Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren&amp;#39;t special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced.</description>
    </item>
    
    <item>
      <title>低俗小说：讲故事的手法本身就是一个故事</title>
      <link>/posts/2019/20190826-%E4%BD%8E%E4%BF%97%E5%B0%8F%E8%AF%B4%E8%AE%B2%E6%95%85%E4%BA%8B%E7%9A%84%E6%89%8B%E6%B3%95%E6%9C%AC%E8%BA%AB%E5%B0%B1%E6%98%AF%E4%B8%80%E4%B8%AA%E6%95%85%E4%BA%8B/</link>
      <pubDate>Mon, 26 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/20190826-%E4%BD%8E%E4%BF%97%E5%B0%8F%E8%AF%B4%E8%AE%B2%E6%95%85%E4%BA%8B%E7%9A%84%E6%89%8B%E6%B3%95%E6%9C%AC%E8%BA%AB%E5%B0%B1%E6%98%AF%E4%B8%80%E4%B8%AA%E6%95%85%E4%BA%8B/</guid>
      <description>这是以前的一篇文章，贴到博客上。
[摘要]：1994 年昆汀的《低俗小说》横空出世，其作为美国独立电影的代表以其先锋的叙事结构打败基耶斯洛夫斯基的《红》一举拿下戛纳金棕榈大奖。与之同时的奥利弗·斯通的《天生杀人狂》以及曼彻夫斯基的《暴雨将至》、王家卫的《东邪西毒》以及随后刘镇伟的《大话西游》在这一两年内同时涌现，他们基本都采用了非线性叙事结构，拼贴的电影语言等典型的后现代主义手法。而《低俗小说》作为个中翘楚，其叙事的断裂性、拼贴性，思想的平面化无深度，多中心的布局以及对宏大叙事的消解等等典型的后现代主义特征尤为值得我们对它的电影叙事结构以及电影语言进行分析。
[关键词]：后现代主义；拼贴；环状互补结构；多视角立体叙事；复调
导语 1994 年可算是电影史上的黄金年，在那一年，《阿甘正传》、《肖申克的救赎》、《低俗小说》、《暴雨将至》、《东邪西毒》、《天生杀人狂》等诸多足以流传影史的影片同时涌现，无论是影片内容的精彩程度，抑或其先锋的叙事结构，20 年后回头再看依然算是影史经典。 《肖申克的救赎》以其深刻的精神内涵高居 IMDB 榜单第一，被誉为“无冕之王”。内容上的东西总是易于理解，而作为在影片形式结构上做了极其先锋探索的《低俗小说》可就没那么好运气了。
1919 年格里菲斯继《一个国家的诞生》大获成功后拍出了他的心血之作——最早的非线性叙事影片《党同伐异》，然而这部电影带给他的是无限凄凉和负债累累的晚年，当时的观众根本无法理解四个毫无关联的故事就这么跳来跳去。
几十年后，人们从思维上逐渐接受了这种非线性的叙事模式，1994 年昆汀的《低俗小说》这类对于非线性叙事结构探索的影片逐渐得到人们的肯定与赞扬。
下面我们主要从叙事结构的角度来理解一下这部电影。
拼贴 如果看过昆汀的另一部影片《杀死比尔》，可能会对这部电影多样化的风格印象深刻。在这部电影里，昆汀首先按线性结构将其分为十章，然后以非线性的方式重新排列组合，再在每一章中揉合进不同的类型片风格，如香港六七十年代的功夫片、意大利黑帮电影、西部片、日本武士电影和日式动画片。这样一来，故事还是那个紧凑到极其简单的故事，但观众在欣赏时感受到的却是变化多端的乐趣。
这实际上就是对影片风格的拼贴，同样类型的还有《天生杀人狂》《罗拉快跑》。
而至于《低俗小说》，则是对于电影叙事序列的拼贴，我们先按照正常的线性发展顺序理一下《低俗小说》的叙述脉络。
《低俗小说》一共讲了三个互有关联的故事：
（故事一）索脏：
Vincent 和 Jules 去一家旅馆索脏，两人一路闲谈，拿到赃款，枪杀藏脏人； 意外被枪击，发现毫发无伤，Jules 认为是“神迹”； 回程路上闲谈，Jules 因为“神迹”决定洗手不干，误杀活口，成功处理麻烦； 快餐店两个小痞子打劫； Jules 因为“神迹”开始反省，以拯救者身份解决麻烦； 两人回去交差，碰见老大和 Butch 做交易； 谈论 Vincent 的新任务——陪老大夫人 Mia 出去玩； （故事二）Vincent 和老大夫人 Mia 的晚餐:
Vincent 到毒贩家购买毒品； Vincent 和 Mia 晚餐； Mia 吸毒过量，Vincent 抢救成功，告别； （故事三）Butch 的金表:
Butch 做梦，回忆了金表的来历； Butch 耍花招潜逃； Butch 回家取金表，打死 Vincent，开车回家路上撞晕老大； Butch 和老大误入黑店，老大遭爆菊； Butch 救出老大，两人和解； 昆汀把这三个故事打散拆碎，将这15个序列进行拼贴，重新组合：
快餐店两个小痞子打劫； Vincent和Jules去一家旅馆索脏，两人一路闲谈，拿到赃款，枪杀藏脏人； 字幕：Vincent和老大Wallace的妻子 两人回去交差，碰见老大和Butch做交易。 谈论Vincent的新任务——陪老大夫人Mia出去玩； Vincent到毒贩家购买毒品 Vincent和Mia晚餐 Mia吸毒过量，Vincent抢救成功，告别。 一阵黑屏，狗叫声开启另一个故事：金表 Butch做梦，回忆了金表的来历 Butch耍花招潜逃 Butch回家取金表，打死Vincent，开车回家路上撞晕老大 Butch和老大误入黑店，老大遭爆菊 Butch救出老大，两人和解 字幕：邦尼的处境（接故事一） 意外被枪击，发现毫发无伤，Jules认为是“神迹”； 回程路上闲谈，Jules因为“神迹”决定洗手不干，误杀活口，处理麻烦； 快餐店两个小痞子打劫； Jules因为“神迹”开始反省，以拯救者身份解决麻烦； 现在故事的序列变成了：</description>
    </item>
    
    <item>
      <title>车辆驾驶行为分析——比赛复盘（二）</title>
      <link>/posts/2019/20190822-%E8%BD%A6%E8%BE%86%E9%A9%BE%E9%A9%B6%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%9B%98%E4%BA%8C/</link>
      <pubDate>Thu, 22 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/20190822-%E8%BD%A6%E8%BE%86%E9%A9%BE%E9%A9%B6%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%9B%98%E4%BA%8C/</guid>
      <description>这一部分是比赛的思路复盘，由于时隔两个多月，只能够写个大概。
数据预处理 在前面简单地抽出了一些文件进行了人工分析，我们发现数据出现了不同程度的遗漏，并且经纬度的值也会有着很大的偏差。于是乎现在就需要将所有的数据进行预处理，从而方便后面的分析。
缺失值。缺失值我们采用常规的处理手段，即缺失值中的速度值和角度值等全部继承上一个点的数据；经纬度用上一个点的经纬度、速度和角度进行计算。 经纬度漂移。这个地方其实比较玄学，因为经纬度可以通过算法结合速度、角度进行计算，然而这两个参数所给的数据也存在误差。所以导致一段路上的经纬度利用算法修正也会存在一定量的漂移；后来我们尝试使用高德地图的绑路 API ，但是由于数据的限制以及调用次数的限制也存在瓶颈；再后来我们尝试动态修复，即经纬度出错的地方用速度和角度修正，速度角度出错的地方我们用经纬度修正（在第一步实现的情况下），但判断阈值很难敲定。于是最后我们选择相信速度角度数据的准确性，然后找出漂移的区块进行修正。 预处理后，丢弃一部分无用数据，然后送入分析算法之中分析。
分析维度 一级指标 阈值界定 疲劳驾驶 采用驾驶人连续驾驶时间不得超过 4 小时，每次停车休息时间不少于 20 分钟的标准界定疲劳驾驶 急加速 设定急加速行为的加速度阈值为 3m/s² ，为避免误差，计算加速度时间间隔取为 3s 急减速 设定急加速行为的加速度阈值为 -3m/s² ，为避免误差，计算加速度时间间隔取为 3s 怠速预热 怠速预热的条件：行驶速度 v = 0；ACC 状态为 on； 超长怠速 超长怠速的条件：行驶速度 v = 0；ACC 状态为 on；怠速预热时间 t ≥ 60s 熄火滑行 熄火滑行的条件：ACC 状态为 off；速度 0 &amp;lt; V &amp;lt; 5km/h；持续时间 t ≥ 3s 超速 条件：速度 ≥ 60km/h；持续 3s 或以上 急变道 短时间内的角度变化范围在 (20°, 70°) 之间；持续时间 3-5s 上文中所有的阈值以及判断标准均是采用了国家标准或者行业规定及习惯，从而确保准确性。超速那一部分需要读取到每一个经纬度所对应的地理位置，由于调用 API 的次数有限，加之大部分的行驶路段为城市公路，所以定位了 60km/h。</description>
    </item>
    
    <item>
      <title>Advice and Definition of Data Science</title>
      <link>/posts/2019/20190820-advice-and-definition-of-data-science/</link>
      <pubDate>Tue, 20 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/20190820-advice-and-definition-of-data-science/</guid>
      <description>This article was written after a related course, which includes my comments and notes.
Definition of Data Science Data Science, which was called the sexiest job in the 21st century, is widely regarded as the process of using data to analyze different things, even the world. And the definition or the name came up in the 80s and 90s when some professors were looking into the statistics curriculum, and they thought it would be better to call it Data Science.</description>
    </item>
    
    <item>
      <title>如何不让 Hexo 渲染 Markdown 和 HTML 文件</title>
      <link>/posts/2019/20190819-%E5%A6%82%E4%BD%95%E4%B8%8D%E8%AE%A9-hexo-%E6%B8%B2%E6%9F%93-markdown-%E5%92%8C-html-%E6%96%87%E4%BB%B6/</link>
      <pubDate>Mon, 19 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/20190819-%E5%A6%82%E4%BD%95%E4%B8%8D%E8%AE%A9-hexo-%E6%B8%B2%E6%9F%93-markdown-%E5%92%8C-html-%E6%96%87%E4%BB%B6/</guid>
      <description>最近想用 Hexo 搞一个测试页面和 Cheatsheet，用作日后的快捷参考和查询，而这个时候我发现了一个问题：
我尝试着把 html 页面单独放到 source 文件夹里面，因为在 source 文件夹里面的内容会被全部放到 public 里面部署。而这个时候，我发现了我原本放的 html 页面排版完全错了，打开文件发现多了很多重复的无关内容。
于是我发现了，可能我的 html 页面又被 Hexo 渲染了一遍。
后来查了一下，发现 Hexo 的确会将 source 里面的 html 以及 md 文件渲染一遍形成新的 html ，并找到了其解决方法：
防止渲染 Markdown 在站点配置文件 _config.yml 中找到 skip_render 参数，地址以 source_dir 为基准，一般为 source 文件夹。
防止渲染 HTML 在 html 文件添加以下代码：
--- layout: false --- 以上便可以保留原本放置于 source 文件夹中的文件。</description>
    </item>
    
    <item>
      <title>为什么我觉得要拥抱碎片化阅读</title>
      <link>/posts/2019/20190813-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E8%A7%89%E5%BE%97%E8%A6%81%E6%8B%A5%E6%8A%B1%E7%A2%8E%E7%89%87%E5%8C%96%E9%98%85%E8%AF%BB/</link>
      <pubDate>Tue, 13 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/20190813-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E8%A7%89%E5%BE%97%E8%A6%81%E6%8B%A5%E6%8A%B1%E7%A2%8E%E7%89%87%E5%8C%96%E9%98%85%E8%AF%BB/</guid>
      <description>“不是实体经济不行了，而是你的实体经济不行了。”这是马云在对待实体经济时候说的话。
在我刷刷算法之余，看到了一些关于碎片化阅读的文章，着笔立场皆是弊大于利，或是批判或是嘲讽，仿佛这就是一头乘着互联网之风的洪水猛兽，扰乱了几千年来人们习得知识的方式，不可谓不坏。
可事实真的是这样吗，碎片化的阅读真就这么不堪？我倒觉得不尽然，因为学习的主体在与人而非方式。千百年前用竹简，如今用纸张，未来更有电子化阅读的趋势。碎片化阅读的目的便是满足人们日常在碎片化时间区间的阅读需求，而拥抱和正视碎片化阅读是十分必要的。
正如开头所言，放在这儿也同样适用：“不是碎片化阅读不好，而是你的碎片化阅读不好”。自己的阅读习惯不好，非但不改正，反而转而批判碎片化阅读，这与当年不从自己的教育方式找问题，反而一直说游戏、小说害人的父母又有何区别？
我在那篇文章里面总结了一下碎片化阅读的弊端：
它让我的大脑不再善于深度独立思考。 它让我们通过“低效率的勤奋”，获得虚假的自我满足感和自我成就感，由此陷入恶性循环。 它让我的时间变得更加碎片化，做事效率更低。 它常常会混淆我已有的价值观体系。 看似字字诛心，实则毫无意义。
它让我的大脑不再善于深度独立思考。
在我看来，碎片化阅读只能够成为大脑不善于独立思考的催化剂，但它从来都不会是主由。
我在路上时常常进行碎片化阅读，但在阅读之后，我也常常会进一步对其中的观点或者现象进行进一步的思考，有时头脑风暴出来的观点过多我甚至会写下来形成文章，比如这篇。深度独立思考并不是坐在安静的地方傻愣，走在路上，听着音乐，也不影响大脑中自由地思考。
文章中比喻成快餐没错，我也觉得碎片化思考很类似于“文化快餐”，也自然存在其弊端，文章中由此引来的结论是这样的：
所以“标题党”大行其道，有用色情擦边球型的，有用惊悚焦虑型的等各种“博眼球”的方式，吸引读者们点进去，下滑，再点进去，再下滑&amp;hellip;&amp;hellip;而作为读者的我们，通常也乐在其中，因为读这些文章，不需要费脑筋，数分钟就可以了解到一些自己以前不知道的事情，而且还可以获取多领域的资讯，让人轻易就可以产生成就感，自我感觉良好。这比自己读书去获取知识轻松容易多了。
标题党的存在纯粹是因为先看标题再阅文章的传统阅读习惯让有心之士钻了空子，根本与碎不碎片化阅读无关，读书的时候就没有了吗？我也曾看过一些书和文章标题惊人，实则毫无营养。“标题党”是阅读行为所无法避免的，与深浅度和时间长短毫无干系。
小知识点，碎片化阅读可以直接掌握；陌生知识点，便是起入门引导之用，能引起阅读书籍查找资料的兴趣。又有谁会觉得自己读了五分钟的文章就高别人一等呢，“现代孔乙己”罢了。
它让我们通过“低效率的勤奋”，获得虚假的自我满足感和自我成就感，由此陷入恶性循环。
人总是会在两点间所有的路径中执行最懒的那个，遇到一些内容多的文章甚至有着“收藏了就是懂了”这样的调侃。但还是如前面所说，正常的阅读习惯中，碎片化阅读并不是也不可能占主流。大部头不可能在短时间内看完，所以分成单元（分段）看；利用零碎时间掌握一下个别知识点，所以碎片化的阅读反而成了提升自己，充足利用时间的利器，间接提升了效率。碎片化阅读只能是在闲暇时间或者碎片化时间中的阅读方式，这并不与深度阅读相悖，也不是非黑即白，两个对抗阵营；它们更像是一种并行的关系。
它让我的时间变得更加碎片化，做事效率更低。
这句话不用再多说，强行诡辩。利用碎片化时间进行阅读何时变成了让时间变得碎片化呢？为了鞭笞碎片化阅读而无所不用其极，为了充实自己的观点而不惜遣词造句建歪理。
它常常会混淆我已有的价值观体系。
这位作者可能平时除了碎片化阅读就极少看书。因为书看得多了就会发现，不同的作者往往有着不同的价值观体系，这点在阅读量大的时候更甚。
混淆只能证明自己不能够构建自己明确的价值观体系，随波逐流，看见一就是一，看到二便是二，无主次对错之分。在我看来，阅读（无论深度阅读还是碎片化阅读）的时候，都难免有相当多的价值观碰撞，有的点会很认同，有的点完全不能接受。而这很正常，毕竟择长而学，择短而弃，各取所需便是阅读的目的。
碎片化阅读在很大程度上也增加了全民的阅读量，这有利也有弊，有人因此而获得了学习的乐趣，也有人会因此而沉沦其中不为所动。
我其实十分排斥以阅读书籍的本数来衡量国民阅读度的标准，首先是因为书的质量参差不齐，日本的阅读量之高有目共睹，但是日本的书有很多是轻小说性质（字大书薄），而且也有大量的“教你如何如何 / 什么什么的方法”之类的所谓热门方法论书籍通篇讲故事，真正有用的不过寥寥几页。要说读这类书籍能够很有效地提升自己，我是不相信的；其次，在阅读相同类目的书时存在边缘效应，每读一本新书获得的知识会随读的书增加而递减（我并不是说这样不好，因为很多领域精进就需要这样接近天花板）。所以这种严重偏科的评判标准并不能衡量一个人所获得的知识的多少。
综上，我的观点如下：
碎片化阅读是一种在碎片化的时间中发散阅读的手段，它不会改变时间的碎片性，也不与深度阅读相悖。 从老庄哲学中我们可以了解到，思考的深度与阅读方式无关，甚至与肉体也无关。 碎片化阅读的利弊取决于读者自己对于阅读行为的掌控度。 无论何种阅读都一定会存在作者与读者之间的价值观体系乃至知识体系的碰撞，而这也正是阅读的目的。 如果对我的看法有异议，欢迎提出，我会进行碎片化阅读并给上深度思考的结果。（滑稽）
最后，还是希望人们能够把心思放在如何提高自己的碎片化阅读的效率上面，而不是见到了就强烈的反对和唾弃它，毕竟认真了，量变就会有质变。把碎片化阅读作为自己辅助阅读的手段，何乐而不为之？</description>
    </item>
    
    <item>
      <title>朋友的创业败局有感</title>
      <link>/posts/2019/20190810-%E6%9C%8B%E5%8F%8B%E7%9A%84%E5%88%9B%E4%B8%9A%E8%B4%A5%E5%B1%80%E6%9C%89%E6%84%9F/</link>
      <pubDate>Sat, 10 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/20190810-%E6%9C%8B%E5%8F%8B%E7%9A%84%E5%88%9B%E4%B8%9A%E8%B4%A5%E5%B1%80%E6%9C%89%E6%84%9F/</guid>
      <description>时间往前倒五年，会是怎样？
我连忙打开了浏览器，搜索了我所关注的科技行业和产品五年前的样子。
五年前的手机市场还是逐鹿群雄，指纹识别还是高端机的标配；红米等大厂的子品牌深耕千元机市场，OV 依旧在靠着信息不对称赚钱；各家的高端旗舰也还是 16:9 的屏幕比例，尺寸在一步步上探，屏占比在一点点抬高；锤子也是新的入局厂商，发布了坚果子品牌；酷派等中华酷联还活跃着。显然，在那个时候对于手机的主流审美与如今存在着些许的偏差。
后来大家也知道了，18:9 作为安卓新的全面屏标准横空出世，屏占比进一步提高，伴随的便是同质化愈发严重。位于屏幕一面的传感器逐个放到了屏幕下面，在短短两年，就已经实现了诸多的商用科技进步。
五年前的我在读高一。当时的我打初二起就开始看电脑报、电脑爱好者、大众软件之类的科技方面的报纸杂志，对于科技产品有着强烈的兴趣。
当我拿到我的第一台安卓寨板的时候，我就开始 root、改系统底层、刷机、逛论坛去解决问题；高一的时候我拿到了人生中的第一台 iPad，不顾保修在第二天就越狱了，然后也是捣鼓系统，改底层配置，申请了一个 Apple Developer，搞了些事情。
如今想想，以前的我还真的能折腾，而如今的我也很少刷机，自诩“早已过了那个年纪”。
然后我又翻了翻知乎，五年前的知乎是那么纯粹，我关注的物理学和科技板块每天都有着许多学术性的讨论和时事新闻，信息和知识的密度远大于如今。就在我不停翻阅过去时，我又想起了一位以前有过萍水之交的好友。
五年前他刚刚创业，做的是彩石手机——一个专门针对老年人的细分领域产品。那时候的他在知乎上一直回答者相关的问题并适度推销自己的彩石手机，也有时候邀请我去回答他的一些问题。
在那个时候我的想法便是，这不一定能成。因为我知道，老年人这个方向真的十分窄，很容易被大厂的一条产品线甚至一个 APP 直接压死；而且考虑到一代一代下去，以后的老年人一定会是已经熟练使用智能手机的一代，只做老年手机终究会没了市场。所以这是一个非常渺茫的机会，而如今的结局也像图里那样，“对不起，失败了”。
江郎是一个十分厉害的人，做过产品经理，也做过总监和产品负责人。如今的失败不由得让人唏嘘，同时也展露了一个现象：如今虽说是大众创业，万众创新，但在互联网这样的多寡头行业，创业相较要困难很多。新锐公司中很多会因为竞争惨烈暴毙，角度立异的优秀公司要么被大的寡头（如腾讯，阿里）收购，要么也会被寡头的相同产品逐渐占去市场份额，只有极少数（如字节跳动）能够把握住当代的潮流逆势上涨，成为一线公司。
他的这个创业败局也不由得让我对于创业的这件事情多了份谨慎和思考。我是一个不安于现状的人，我喜欢那种从事自己喜爱事物的感觉，这也直接让我对创业有了一份憧憬，觉得自己一定能够闯出一片天；但如今我变得更加现实，每当我的一个点子冒出，我都会开始评估可行性，然后再结合目前的行业趋势进一步完善和思考。
于是结果无非三种——有了现成的方案、行不通、貌似可行——最后一个基本不存在，这也让我一直对互联网创业保持着敬畏之心和五味陈杂之感。</description>
    </item>
    
    <item>
      <title>那些略荒唐却真实的名言</title>
      <link>/posts/2019/20190807-%E9%82%A3%E4%BA%9B%E7%95%A5%E8%8D%92%E5%94%90%E5%8D%B4%E7%9C%9F%E5%AE%9E%E7%9A%84%E5%90%8D%E8%A8%80/</link>
      <pubDate>Wed, 07 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/20190807-%E9%82%A3%E4%BA%9B%E7%95%A5%E8%8D%92%E5%94%90%E5%8D%B4%E7%9C%9F%E5%AE%9E%E7%9A%84%E5%90%8D%E8%A8%80/</guid>
      <description>该文章摘录于 喜洋洋的知乎专栏文章 - 世界名人10大名句，秒杀一切段子手！，并在该文基础上加以评论和删改。
马克 • 吐温 美国作家、演说家，也是美国批判现实主义文学的奠基人，幽默和讽刺是他的写作特点。代表作品有小说《百万英镑》、《哈克贝利 • 费恩历险记》、《汤姆 • 索亚历险记》等。
有时候真实比小说更加荒诞，因为虚构是在一定逻辑下进行的，而现实往往毫无逻辑可言。
保持身体健康的唯一办法，就是吃点你不想吃的，喝点你不想喝的，以及做点你不愿做的事情。
每当你发现自己和大多数人站在一边，你就该停下来反思一下。
有皱纹的地方只表示微笑曾在那儿呆过。
不要把事实告诉不值得的人。
即使闭起嘴看起来像个傻瓜，也比开口让人家确认你是傻瓜来得强。
人类是唯一会脸红的动物，或是唯一该脸红的动物。
如果你收养了一只饥饿可怜的狗，并且让它舒适顺利，它将不会咬你，这便是一个人与一只狗之间最主要的差别。
如果你的朋友们开始夸你看上去多么年轻，那就是你正在变老的确据。
如果我生下来就是八十岁，而慢慢长到十八岁的话，人生会更加快乐无穷。
奥斯卡 • 王尔德 出生于爱尔兰都柏林，19 世纪英国最伟大的作家与艺术家之一，以其剧作、诗歌、童话和小说闻名，唯美主义代表人物，19 世纪 80 年代美学运动的主力和 90 年代颓废派运动的先驱。
人生有两个悲剧，第一是想得到的得不到，第二是想得到的得到了。
做你自己，因为别人都有人做了。
生活是世上最罕见的事情，大多数人只是存在，仅此而已。
过自己想要的生活不是自私，要求别人按自己的意愿生活才是。
很多东西如果不是怕别人捡去，我们一定会扔掉。
年轻的时候我以为钱就是一切，现在老了才知道，确实如此。
什么是离婚的主要原因？结婚。
爱，始于自我欺骗，终于欺骗他人。这就是所谓的浪漫。
人生就是一件蠢事追着另一件蠢事而来，而爱情则是两个蠢东西追来追去。
逢场作戏和终身不渝之间的区别只在于逢场作戏稍微长一些。
罗曼 • 罗兰 思想家，文学家，批判现实主义作家，音乐评论家，社会活动家，1915 年诺贝尔文学奖得主，是 20 世纪上半叶法国著名的人道主义作家。他的小说特点被人们归纳为“用音乐写小说”。
大部分人在二三十岁上就死去了，因为过了这个年龄，他们只是自己的影子，此后的余生则是在模仿自己中度过，日复一日，更机械，更装腔作势地重复他们在有生之年的所作所为，所思所想，所爱所恨。
一个人的性格决定他的际遇。如果你喜欢保持你的性格，那么，你就无权拒绝你的际遇。
认识的人多了，我就更喜欢狗了.
有些事情是不能告诉别人的，有些事情是不必告诉别人的，有些事情是根本没有办法告诉别人的，而且有些事情是，即使告诉了别人，你也会马上后悔的。
人生就像一条抛物线，幸运的顶点，往往也是厄运的开端。
不要为过去的时间叹息！我们在人生的道路上，最好的办法是向前看，不要回头。
人生不售来回票，一旦动身，绝不能复返。
世界上只有一种真正的英雄主义，那就是在认清生活的真相后依然热爱生活。
从来没有人读书，只有人在书中读自己，发现自己或检查自己。
真正的光明决不是永没有黑暗的时间，只是永不被黑暗所掩蔽罢了。真正的英雄决不是永没有卑下的情操，只是永不被卑下的情操所屈服罢了。
弗里德里希 • 威廉 • 尼采 德国哲学家、语言学家、文化评论家、诗人、作曲家、思想家。主要著作有《权力意志》、《悲剧的诞生》、《不合时宜的考察》、《查拉图斯特拉如是说》、《希腊悲剧时代的哲学》、《论道德的谱系》等。
其实人跟树是一样的，越是向往高处的阳光，它的根就越要伸向黑暗的地底。
我感到难过，不是因为你欺骗了我，而是因为我再也不能相信你了。
一个人知道自己为什么而活，就可以忍受任何一种生活。
与怪物战斗的人，应当小心自己不要成为怪物。当你远远凝视深渊时，深渊也在凝视你。
不能听命于自己者，就要受命于他人。</description>
    </item>
    
    <item>
      <title>如何解决 selenium 的退出问题？ - 关于 Python 函数的运行机制</title>
      <link>/posts/2019/20190806-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-selenium-%E7%9A%84%E9%80%80%E5%87%BA%E9%97%AE%E9%A2%98-%E5%85%B3%E4%BA%8E-python-%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Tue, 06 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/20190806-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-selenium-%E7%9A%84%E9%80%80%E5%87%BA%E9%97%AE%E9%A2%98-%E5%85%B3%E4%BA%8E-python-%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</guid>
      <description>最近在搞爬虫，然后顺便写了写基于 selenium 框架的模拟登陆脚本供以后需要时用，然而在这时我发现了一个问题：
代码一开始是这样的：
from selenium import webdriver driver = webdriver.Chrome() driver.maximize_window() driver.get(&amp;#39;http://mail.163.com&amp;#39;) driver.find_element_by_id(&amp;#39;switchAccountLogin&amp;#39;).click() iframe = driver.find_element_by_xpath(&amp;#39;//*[@id=&amp;#34;loginDiv&amp;#34;]/iframe&amp;#39;) # 使用Xpath选定位到iframe driver.switch_to.frame(iframe)　# 切换iframe # iframe = driver.find_element_by_xpath(&amp;#34;//iframe[contains(@id, &amp;#39;x-URS-iframe&amp;#39;)]&amp;#34;) # 使用Xpath提供的contains定位 # driver.switch_to.frame(iframe) driver.find_element_by_name(&amp;#39;email&amp;#39;).send_keys(&amp;#39;name&amp;#39;) driver.find_element_by_name(&amp;#39;password&amp;#39;).send_keys(&amp;#39;password&amp;#39;) driver.find_element_by_id(&amp;#39;dologin&amp;#39;).click() 然后进行了简单的改造：
from selenium import webdriver class Mail163: def __init__(self, name, password): self.name = name self.password = password self.driver = webdriver.Chrome() def run(self): # driver.maximize_window() self.driver.get(&amp;#39;http://mail.163.com&amp;#39;) self.driver.find_element_by_id(&amp;#39;switchAccountLogin&amp;#39;).click() iframe = self.driver.find_element_by_xpath(&amp;#39;//*[@id=&amp;#34;loginDiv&amp;#34;]/iframe&amp;#39;) # 使用Xpath选定位到iframe self.driver.switch_to.frame(iframe) # 切换iframe # iframe = driver.</description>
    </item>
    
    <item>
      <title>如何配置 VS Code 进行远程调试</title>
      <link>/posts/2019/20190806-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE-vs-code-%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/</link>
      <pubDate>Tue, 06 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/20190806-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE-vs-code-%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/</guid>
      <description>从前，我还在用 Putty 艰难地连接服务器，用命令行敲着 ftp 去与服务器互传文件；
后来长大了，开始用 XShell 进行交互，传文件直接用 XFtp，效率陡增；但是由于我用不惯 Vim，每一次改内容都需要把文件先下下来，用 VS Code 改好，然后再用 Xftp 给传上去。
再后来，VS Code 的官方 Remote 插件推出，如今的我可以直接在 VS Code 里面操作服务器进行开发和调试，简直不要太舒服。
那么如何配置 VS Code 并实现远程开发呢？
安装 VS Code 和插件 VS Code 下载地址
首先下载安装 VS Code。以前只有 Insider 版本才有 Remote Development，现在已经下放到正式版本了。
然后打开扩展页面，搜索 Remote Development，选择第一个安装，在安装完成后左栏会出现一个 Remote 的小图标。
配置 Remote Development 如图，点击配置一个 SSH Host：
这是编辑器会打开一个文件，格式如下：
# Read more about SSH config files: https://linux.die.net/man/5/ssh_config Host CentOS HostName 111.111.111.111 User admin Host 后面填服务器名称（可随意填）；HostName 后面填服务器的IP地址或域名；User 后面填服务器用户。</description>
    </item>
    
    <item>
      <title>极速入门 Go 语言</title>
      <link>/posts/2019/20190729-%E6%9E%81%E9%80%9F%E5%85%A5%E9%97%A8-go-%E8%AF%AD%E8%A8%80/</link>
      <pubDate>Mon, 29 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/20190729-%E6%9E%81%E9%80%9F%E5%85%A5%E9%97%A8-go-%E8%AF%AD%E8%A8%80/</guid>
      <description>Go 语言可以称为是 21 世纪的 C 语言了，其不仅具有诸多十分优秀的特性，而且也保持了简洁干练，运行效率也与 C++ 看齐。那么再有其他的语言基础下，如何快速入门 Go 呢？
这篇文章其实更多地是 Go 与其他语言之间的对比，并由此初探 Go，从而达到快速入门的目的。 本文只是 Go 语言入门，其他的 Go 特性操作还需要多加学习。 语言基础要求：C、Python（入门即可）
首先是一个正常的 Hello World 代码
package main import &amp;#34;fmt&amp;#34; func main() { var a string = &amp;#34;Hello, World!&amp;#34; b, c := 2, 3 if(b &amp;gt; c &amp;amp;&amp;amp; b &amp;lt; c) { fmt.Println(a) } } package：该文件的包名，同样报名的文件会划归为同一个包，且一个文件夹里面（除去子文件夹）只允许有一个包存在 import：Python 中的 import func：定义 function 函数的关键词，与 def 类似 main：主程序，作用和地位与 C 相似，传参也和 C 相似 var a string：定义一个类型为 string 的变量 a，这是 Go 语言中的格式 &amp;amp;&amp;amp;：Go 的运算符和 C 类似 fmt.</description>
    </item>
    
    <item>
      <title>Django 所踩过的坑</title>
      <link>/posts/2019/20190722-django-%E6%89%80%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/</link>
      <pubDate>Mon, 22 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/20190722-django-%E6%89%80%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/</guid>
      <description>目前市面上流行着两个基于 Python 的 Web 框架，一个是 Django，一个是 Flask。（当然还有其他的如 Pylon 等，只是我没有接触过所以不做讨论）
由于 Hexo 博客系统的机制以及诸多的限制，我计划将我的博客从原本的基于 Hexo 静态框架转为基于 Django 框架的博客系统。
总所周知， Django 的架构比较适合于大型项目的开发，Flask 则是轻量级的 Web 框架，适合于小型项目开发。处于学习目的，我这次的框架选择十分的干脆——直接上 Django，所以我就直接开始了 Django 的学习。
当然，在建立这个博客系统的时候，作为一个接触 Web 较少的菜鸟，我也是踩了非常多的坑的。
端口开放 这个错误就非常初级了，当时我一直以为阿里云的服务器和腾讯云的服务器一样是端口全开的，所以我就直接把开发服务器放到了 8000 端口，结果什么都没有。所以后来在阿里云控制台打开了 8000 端口的监听才成功看到 Hello World 页面。
Django 不同版本之间的区别 由于 Django 迭代了很多次，它也像 Python 一样存在着版本之间的兼容性问题。Django 1 与 Django 2 之间就存在着非常多的语法以及参数上的区别，下面这个问题就困扰了我很久。
在 Django 2.0 之后，定义外键和一对一关系的时候需要加 on_delete 选项，此参数为了避免两个表里的数据不一致问题，否则就会报错： TypeError: __init__() missing 1 required positional argument: &#39;on_delete&#39; 所以要将 category = models.ForeignKey(Category) 改为 category = models.</description>
    </item>
    
    <item>
      <title>赛博朋克金沙湾后期过程</title>
      <link>/posts/2019/20190710-%E8%B5%9B%E5%8D%9A%E6%9C%8B%E5%85%8B%E9%87%91%E6%B2%99%E6%B9%BE%E5%90%8E%E6%9C%9F%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Wed, 10 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/20190710-%E8%B5%9B%E5%8D%9A%E6%9C%8B%E5%85%8B%E9%87%91%E6%B2%99%E6%B9%BE%E5%90%8E%E6%9C%9F%E8%BF%87%E7%A8%8B/</guid>
      <description>考完了期末考试，闲来无事写一下赛博朋克金沙湾的后期过程以及修图的思路。
首先还是看一下原图：
选择它的原因是这张图的结构较简单而且元素较少。我们需要在此基础上进行图像整体的设计（就是知道要怎么进行后期），并以此为依据寻找素材图。
于是找到了一张赛博朋克风格的图片，然后把它放到了画布中：
接着把空白处填充满，改善一下光影效果：
此时我觉得整个画面的上方有点空，所以我又找了几张图，添加了一些未来感的细节：
然后背景部分就基本上完成了，接下来把原图的城市部分抠出来放到下面：
此时我调整了两幅图之间的透视，从而使得前后景透视关系正确。但是此时色调还不统一，所以接下来统一一下色调：
最后一个步骤，加上光效，这一步不仅可以完善画面，风格进一步向赛博朋克靠近，也能够遮瑕，把处理不好的地方遮住：</description>
    </item>
    
    <item>
      <title>建立并连接到 Ubuntu 服务器的远程桌面</title>
      <link>/posts/2019/20190707-%E5%BB%BA%E7%AB%8B%E5%B9%B6%E8%BF%9E%E6%8E%A5%E5%88%B0-ubuntu-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2/</link>
      <pubDate>Sun, 07 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/20190707-%E5%BB%BA%E7%AB%8B%E5%B9%B6%E8%BF%9E%E6%8E%A5%E5%88%B0-ubuntu-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2/</guid>
      <description>建立一个远程桌面，把 Ubuntu 服务器当成远程电脑使用。
水开头 在经历了很久的命令行交互之后，突然想这把与服务器间的交互给图形化，从而可以方便地搞一些其他的操作，比如像 Windows Server 那样即连即用的云电脑。
为此我查了一些资料和教程，也算是成功实现了可视化：
怎么做 下面是自己的经历记录：
首先安装必要的包：
sudo apt-get install xrdp sudo apt-get install vnc4server sudo apt-get install xubuntu-desktop echo “xfce4-session” &amp;gt;~/.xsession sudo service xrdp restart
如果没有的话，就 sudo apt-get update 更新一下再安装。
这样子的话就已经完成了，Windows 系统通过远程连接，输入自己的服务器 IP。
然后可以连接到服务器：
输入自己对应的用户名和密码就可以进入界面了。
问题 在我进行到最后一步的时候，遇到了 problem connecting 的问题，后来查到还需要安装一个包。
sudo apt-get install tightvncserver
成功连接后，我又发现界面只有灰屏和叉型的鼠标，没有图形界面，后来查了许多的资料才发现问题。
原来 gnome 桌面在 Ubuntu 14.04 之后就已经不支持远程连接了，所以要用 xfce 界面来代替。
sudo apt-get install xubuntu-desktop echo xfce4-session &amp;gt;~/.xsession vim /etc/xrdp/startwm.sh
在./etc/X11/Xsession前插入xfce4-session。
cd /etc/init.</description>
    </item>
    
    <item>
      <title>数字图像处理 - 双线性插值</title>
      <link>/posts/2019/20190702-%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E5%8F%8C%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC/</link>
      <pubDate>Tue, 02 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/20190702-%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E5%8F%8C%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC/</guid>
      <description>双线性插值是一种数字图像中实现缩放的方法，相较于近邻差值和平均差值有着更好地缩放效果。
原理 在图像进行缩放时，有着不同的缩放方法，最常见的一种是根据缩放大小比例，计算每一个像素位置所对应的原大小的像素大致位置，然后把相对应的未知的像素值套入缩放后的图片中。算法如下图所示：
这种算法的不足之处在于，其在放大比例过大等情况下会导致明显失真。而双线性差值算法则有效地减少了这一问题，它根据距离上下左右的距离对不同的像素值（RGB 数值的大小）进行了加权相加，从而算出一个更接近的值代替。
算法 算法如下图：
例子 下面是一个简单的运算例子。进行计算后，得出的放大后的图某像素对应的原图的位置 P 以及周围的四个像素点：
有 203.941 - 203 = 0.941
所以先对上面两个像素进行加权相加：
f(R1) = (1 - 0.941) * f(104, 203) + 0.941 * f(104,204)
同理对下面两个像素进行运算：
f(R2) = (1 - 0.941) * f(105, 203) + 0.941 * f(105, 204)
又有 104.615 - 104 = 0.615
所以上下算出来的值对应 y 轴再进行一次加权运算：
f(P) = (1 - 0.615) * f(R1) + 0.615 * f(R2)
最终所算出来的 f(P) 便是大图像素的值。
这个算法主要是通过加权来减轻由于均值或者直接代替所产生的误差，从而减小失真，在图像处理领域也十分常用。</description>
    </item>
    
    <item>
      <title>为网站设置域名并且添加 SSL 证书</title>
      <link>/posts/2019/20190617-%E4%B8%BA%E7%BD%91%E7%AB%99%E8%AE%BE%E7%BD%AE%E5%9F%9F%E5%90%8D%E5%B9%B6%E4%B8%94%E6%B7%BB%E5%8A%A0-ssl-%E8%AF%81%E4%B9%A6/</link>
      <pubDate>Mon, 17 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/20190617-%E4%B8%BA%E7%BD%91%E7%AB%99%E8%AE%BE%E7%BD%AE%E5%9F%9F%E5%90%8D%E5%B9%B6%E4%B8%94%E6%B7%BB%E5%8A%A0-ssl-%E8%AF%81%E4%B9%A6/</guid>
      <description>最近域名备案了，所以我把自己的博客从 GitHub 搬到了自己的服务器上，以提升访问的速度。其中因为前期准备不足，所以再添加 SSL 的时候踩了许多坑，所以特地写下来作参考之用。
安装前 在进行操作前，我们需要确保自己的网址已经解析到服务器 IP 上了，以方便后面的操作。
安装 Nginx 首先由于我用的是 Nginx，所以我们现需要安装 Nginx。
sudo apt-get install nginx
等待安装，在安装完成后，Nginx 会默认监听 80 端口，所以输入服务器的 IP 地址进行访问，会出现 Welcome to Nginx! 的字样。
这一步和 Hexo 的安装互不干涉，先后顺序随意。 但是安装完之后 80 端口会被 Nginx 占用，hexo server 命令可能会无作用。
Nginx 配置 在 Nginx 安装完成之后，我们还需要进行 Nginx 的配置，我们才能正常用自己的域名登入网站。
首先进入 /etc/nginx/ 目录，其中我们需要修改的文件是 nginx.conf 和 /sites-avaliable 和 /sites-enabled 中的 default 文件。而这两个文件实际上是相关联的，所以只需要修改一个文件就好。
在 default 中的 server 模块改成下列代码：
listen 80 default_server; listen [::]:80 default_server; //设置 80 端口为监听端口 root /root/blog/public; //网站存放的地址 # Add index.</description>
    </item>
    
    <item>
      <title>Hexo 博客如何添加图片</title>
      <link>/posts/2019/20190619-hexo-%E5%8D%9A%E5%AE%A2%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87/</link>
      <pubDate>Sun, 09 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/20190619-hexo-%E5%8D%9A%E5%AE%A2%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87/</guid>
      <description>如何在自己写的 Markdown 博客中添加自己的图片？在多词的寻找和使用后，我找到了如下的几种插入图片的方法。
利用 OSS （对象存储） 如果网站是托管在 GitHub、Coding 之类的平台上的话，直接将图片存在上面速度会比较慢，而且大陆内陆的网络访问起来可能不是特别顺畅。
所以我们可以购买 OSS 去存储图片，并且给图片文件添加外链，然后直接在 Markdown 文章中添加外链即可。阿里云、腾讯云都提供了解决方案，价格再优惠后也在可接受范围内。
利用免费图床 如果不想用收费的存储方案，网络上也有免费图床可以使用，但大多数的免费方案都有时间限制，少则 24 小时，多则 7 天，付费方案还不如自己开一个 OSS 来得实惠。
img.onl 是一个没有固定期限的免费图床网站，当然数据的安全也没法得到保证，大家谨慎使用。
自有服务器 如果是自己有服务器的话，那就好办了，这也是我现在所使用的方案。
首先要将 Hexo 安装到服务器上，一切都准备好后，在 blog 层级的 _config.yml 中修改 post_asset_folder: true，之后每一次创建新的文章都会另外生成一个同名文件夹，我们可以把文章所需的素材放到里面。
文章中假如如果要引用 1.jpg 的话，在图片地址中只需要写成 ./1.jpg 即可。 （因为 Hexo g 的时候，文件夹中的图片会与该文章页放在同一个目录里面）
我跳过的坑 我以前曾经想过，如果存放在社交网络上然后把图片的链接贴在文章里不就可以了吗？
然而现实是大多数的社交网站都不支持外链，图片根本无法显示。下面分享一下我所踩过的坑：
微博：微博外链理论上是可以的，发的微博图片的链接基本上都能够用一段时间，如果不能用的话把链接中的 s1 或 s2、s3 换一下就能用了，但这在文章很多的时候修改会很麻烦，所以并不特别推荐。
QQ 空间：有次数限制，多次以后被查出来用外链就不能够使用了。
微云：可以通过分享文件然后提取预览图的连接，不过需要一定的 web 基础去寻找链接，也不推荐。
Unsplash：Unsplash 的外链目前没有翻过车，我的摄影作品都是放在上面，然后外链过来的，但仅限于摄影方面的图片并且 CC0 协议。</description>
    </item>
    
    <item>
      <title>桌面 - 我的工作环境（三）</title>
      <link>/posts/2019/20190609-%E6%A1%8C%E9%9D%A2-%E6%88%91%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E4%B8%89/</link>
      <pubDate>Sun, 09 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/20190609-%E6%A1%8C%E9%9D%A2-%E6%88%91%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E4%B8%89/</guid>
      <description>作为一个极简主义者，我的所有设备都会一切从简，并且用最少的设备满足最多的需求。
所以接下来是一个极简主义者打造的电脑。
我的硬件配置：New Surface Pro 128GB / 8GB
桌面 先放一下桌面截图：
这就是我的桌面，在一般的情况下，桌面上都只会有一个回收站。而当我有工作或者作业时，我才会把临时需要频繁使用的文件放在桌面上（比如 doc、psd、项目文件夹等）。
任务栏隐藏在右端，当鼠标移上去时就会弹出：
我觉得电脑的桌面就像现实生活中的桌面一样，要保持干净齐整。图标快捷方式这些我一般都会放在 Start 里面，频繁使用的会绑定快捷键，使用起来不比双击图标来得慢。
所以，桌面这么简单，就一定会有一套交互逻辑来支撑它，我对于桌面的调整都围绕着这个方面展开。
Auto HotKey (AHK) 第一个便是 AHK：
AHK 是一个热键（快捷键）小体量程序，我们可以通过编辑脚本绑定快捷键，从而通过键盘快速打开文件或者程序，甚至执行一段脚本程序。
我习惯上会通过热键设置将 Win 键绑定各种系统的软件及操作，而 Alt 键绑定自己常用的软件。
网上有很多教程，基本的设置操作也十分简单容易上手。
PicPick 第二个是一个截图软件 —— PicPick，可以设置快捷键对应全屏截图、区域截图、矩形截图等等不同的截图操作，而且也可以进行一定程度的图像编辑。
这个软件比官方的截图工具要好用，而且相对于其他的截图软件体量要小。
Quick Look 这是一个在 GitHub 开源的预览软件，它支持非常多的格式的预览。选中文件并按下空格键便可以用 Quick Look 打开，速度也是十分的快，十分适合简单的预览。
JetBrains ToolBox 这个在前文中介绍过，我用它来管理我的一部分项目以及 J 系的 IDE。
日常使用优缺点 通过多个软件的相互配合，我能够在十分便捷地打开各种软件的同时也能够保持桌面的齐整，并随着我自己的需求不断改进，最终形成了我自己的一套系统的操作逻辑以及风格。
当然这也会导致一个不好的后果，不熟悉的人可能会像在使用另一个操作系统一样，效率直线下降。（借给同学请谨慎）
终于填完了一个坑，感觉十分舒适。
Peace.</description>
    </item>
    
    <item>
      <title>车辆驾驶行为分析——比赛复盘（一）地图生成</title>
      <link>/posts/2019/20190607-%E8%BD%A6%E8%BE%86%E9%A9%BE%E9%A9%B6%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%9B%98%E4%B8%80%E5%9C%B0%E5%9B%BE%E7%94%9F%E6%88%90/</link>
      <pubDate>Fri, 07 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/20190607-%E8%BD%A6%E8%BE%86%E9%A9%BE%E9%A9%B6%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%9B%98%E4%B8%80%E5%9C%B0%E5%9B%BE%E7%94%9F%E6%88%90/</guid>
      <description>最近比赛结果出来了，所以我打算对比赛做一个复盘，作日后参考之用。
我们的队伍有幸拿了全国二等奖，我在其中负责的是算法以及编程实现。
因为整个比赛时长只有七天，算法没有时间做特别多的优化，所以代码的质量可能不是特别高。
本人水平有限，若有缺漏之处欢迎指正。
研究问题 利用附件 1 所给数据，提取并分析车辆的运输路线以及其在运输过程中的速度、加速度等行车状态。提交附表中 10 辆车每辆车每条线路在经纬度坐标系下的运输线路图及对应的行车里程、平均行车速度、急加速急减速情况。
利用附件 1 所给数据，挖掘每辆运输车辆的不良驾驶行为，建立行车安全的评价模型，并给出评价结果。
综合考虑运输车辆的安全、效率和节能，并结合自然气象条件与道路状况等情况， 为运输车辆管理部门建立行车安全的综合评价指标体系与综合评价模型。
附表
序号 1 2 3 4 5 6 7 8 9 10 车牌号 AA00002 AB00006 AD00003 AD00013 AD00053 AD00083 AD00419 AF00098 AF00131 AF00373 数据说明 附件 1 给出 450 辆运输车辆的行车轨迹采集数据，由于采集设备精度，实际采集数据可能存在某些异常。 序号 指标名称 指标说明 说明 1 vehicleplatenumber 车牌号码 2 device_num 设备号 3 direction_angle 方向角 范围：0-359（方向角指从定位点的正北方向 起，以顺时针方向至行驶方向间的水平夹角） 4 lng 经度 东经 5 lat 纬度 北纬 6 acc_state ACC 状态 点火 1/熄火 0 7 right_turn_signals 右转向灯 灭 0/开 1 8 left_turn_signals 左转向灯 灭 0/开 1 9 hand_brake 手刹 灭 0/开 1 10 foot_brake 脚刹 无 0/有 1 11 location_time 采集时间 12 gps_speed GPS 速度 单位：km/h 13 mileage GPS 里程 单位：km 附件 2 给出 2018 年 7 月 30 日至 2018 年 10 月 10 日全国主要城市的自然气象数据。 序号 指标名称 指标说明 说明 1 province 省/自治区/直辖市 2 prefecture_city 地级市 3 county 县级市/县 4 wind_direction 风向 5 wind_power 风力 6 high_temp 最高温度 7 low_temp 最低温度 8 conditions 天气状况 如：多云、晴、雨、雪 9 relative_humidity 相对湿度 10 precipitation 降水量 单位：mm 11 record_date 采集日期 在车辆运输过程中，不良驾驶行为主要包括疲劳驾驶、急加速、急减速、怠速预热、超长怠速、熄火滑行、超速、急变道等。 数据类型样例 下面附上数据的样例截图：</description>
    </item>
    
    <item>
      <title>hacker-laws 的中文版本</title>
      <link>/posts/2019/20190606-hacker-laws-%E7%9A%84%E4%B8%AD%E6%96%87%E7%89%88%E6%9C%AC/</link>
      <pubDate>Thu, 06 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/20190606-hacker-laws-%E7%9A%84%E4%B8%AD%E6%96%87%E7%89%88%E6%9C%AC/</guid>
      <description>hacker-laws 是一系列对开发人员有用的定律、理论、原则和模式，目前已有 6.8k stars，我参与翻译和编写了中文的版本，目前已有 2.8k stars。
感觉这个 repo 对于开发人员还是挺有用的，能够避免很多的坑。当然这些是理论性的内容，作锦上添花之用，更多的还是要靠开发人员本身的编程水平。
项目地址</description>
    </item>
    
    <item>
      <title>IDE 套件 - 我的工作环境（二）</title>
      <link>/posts/2019/20190604-ide-%E5%A5%97%E4%BB%B6-%E6%88%91%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E4%BA%8C/</link>
      <pubDate>Tue, 04 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/20190604-ide-%E5%A5%97%E4%BB%B6-%E6%88%91%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E4%BA%8C/</guid>
      <description>简单地和大家分享一下我的电脑的工作环境以及配置。这一部分是主要对应的是开发的工作环境选择。
我的硬件配置：New Surface Pro 128GB / 8GB
JetBrains 全家桶 JetBrains 全家桶是我目前主要使用的 IDE 系列之一，我主要用的是 Pycharm、CLion、IDEA、Goland 这四个 IDE。我选择它们有以下原因：
对学生免费，只要拥有 edu 邮箱就能够一直免费续用许可证；（一般大学里面都会有，如果没有也可以通过淘宝或者其他网站激活，价格会比官方便宜） IDE 套件多，而且使用体验非常统一，不同的 IDE 之间可以同步用户设置； 环境设置方便，上手难度不是特别地高； 功能较为全面。 虽然 J 系的软件挺好，但是缺点也非常明显——IDE 全部基于 JAVA，所以十分占用内存，对性能也有一定的要求（Surface Pro 在播放视频时使用 J 系软件就会有明显的卡顿）。
在日常的使用中，配合 JetBrains Toolbox 软件可以有效率地管理项目（不同 IDE 的项目也可以）和 J 系 IDE，十分方便。
VS 2019 当然，我平时开发也少不了宇宙级 IDE —— Visual Studio 2019，我其实以前一直在用 VS，并且本着用新不用旧的原则（当然我知道这要考虑到兼容性的问题），毕竟新版本的 VS 新增的功能都非常好用，能增加开发效率，而且对于老项目的兼容性还能够接受。
VS 2019 不是跨平台的 IDE，这也就意味着在 Linux、OSX 等平台是不可用的。
VS Code Insider 最后一个便是 VS Code Insider，这本质上并不是一个 IDE，而是一个扩展十分丰富的编辑器（参考 Vim）。在配置完自己想要的插件之后，它能实现非常多的功能，同时也能兼顾轻便。要知道，带着 Surface （或者其他的笔记本）去图书馆，VS Code 能够比 J 系节省出几个小时的电量。</description>
    </item>
    
    <item>
      <title>写了一个腾讯 AI 开放平台 SDK</title>
      <link>/posts/2019/20190528-%E5%86%99%E4%BA%86%E4%B8%80%E4%B8%AA%E8%85%BE%E8%AE%AF-ai-%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0-sdk/</link>
      <pubDate>Tue, 28 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/20190528-%E5%86%99%E4%BA%86%E4%B8%80%E4%B8%AA%E8%85%BE%E8%AE%AF-ai-%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0-sdk/</guid>
      <description>最近打算把 Jarvis 的部分外接功能从百度 AI 平台转到腾讯 AI 平台，但是腾讯 AI 并没有提供 SDK，所以自己写了一个分享出来。
这里面与百度 AI 平台之间主要的区别是腾讯的平台有一个鉴权机制，在调用 API 时除了一些基本参数之外，还需要提供一个根据 API 所需所有参数字典算出来的一个 MD5 码。格式以官方的 DEMO 作为参考并做了一定的改动，可读性相比 DEMO 有一定提高。
项目地址：Tencent_aiplat_SDK
源码如下：（与最终版本可能会有差别，以 GitHub 上的项目内代码为主）
# _*_ coding:utf-8 _*_ import hashlib import urllib.parse import urllib.request import urllib.error import json import time import base64 import os # 接口api url_prefix = &amp;#39;https://api.ai.qq.com/fcgi-bin/&amp;#39; class AiPlat(object): def __init__(self, app_id, app_key): self.app_id = app_id self.app_key = app_key self.data = {} def genSignString(self, parser): uri_str = &amp;#39;&amp;#39; for key in sorted(parser.</description>
    </item>
    
    <item>
      <title>Office 365 - 我的工作环境（一）</title>
      <link>/posts/2019/20190525-office-365-%E6%88%91%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E4%B8%80/</link>
      <pubDate>Sat, 25 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/20190525-office-365-%E6%88%91%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E4%B8%80/</guid>
      <description>简单地和大家分享一下我的电脑的工作环境以及配置。这一部分是主要对应的是日常的学习笔记整理以及工作场合。
序 因为以前收到过一些关于电脑方面的问题，所以我想着写几篇文章来和大家简单分享一下我的工作环境以及一些配置。
初步设想的是分成下面三个部分：
日常，对应的是我日常学习以及在部门中的工作处理方面； 开发，对应着我在做开发工作的时候所使用的工作环境； 其他，这里主要分享一些除前两者之外的一些环境配置。 写这些文章目的是一来可以和大家的工作环境做一个对比，取长补短而提升自己，更好地提升自己的工作效率；二来为部分小白用户作指南之用，帮助提升工作效率以及体验。
我的很多观点见仁见智，不同的人有不同的情况，所以有误之处也希望各位能够明鉴，我会及时更改并虚心学习。
先贴上我的硬件配置：New Surface Pro 128GB / 8GB
办公套件 - Office 无论是学习还是工作，办公套件都是必不可少的一环，而这一类的软件定位不同方向不同，所以更多的是跟随着自己的需求做选择。
而对于这方面的选择我的看法是，如果你是一个以移动端文件编辑为主，或者对 WPS 情有独钟的话，WPS 是一个不错的选择；而如果平常电脑端工作较多，对多人合作编辑或者有着对文档的高级操作（宏，批处理等）的话，WPS 完全不够用，Office 才是王道（巨硬大法好）。
两者在普通的功能上基本上没有太大的差别，但最好是和一起工作学习的人用同一种套件，毕竟软件之间的兼容性也是十分重要的。
顺便吐槽一下 WPS 的兼容性是真的不行。
我目前使用的是微软的全家桶 Office 365，这就不用多解释了，还是熟悉的味道，高效简洁。
笔记软件 - OneNote OneNote 是一个让我又爱又恨的软件。以前的 OneNote 水土不服，网络同步非常糟糕，而现在 OneNote 的网络等方面的体验有了极大的改善，和其他的笔记软件相比各有千秋。
OneNote 软件本身是免费的，其可存储在本地，亦或是存储在 OneDrive 上作为类似于印象笔记的网络笔记本。
云存储 - OneDrive OneDrive是Office中的一个云存储产品，默认有5GB初始空间，而Office 365计划则包含着1TB的存储空间。
同时OneDrive也有Free up space功能，可以让文件存储在云端，而本地只有一个类似于快捷方式的文件目录，几乎不占本地空间，可谓小空间笔记本减负之神器。
当我需要使用某些文件的时候，和平常一样双击文件即可把文件拉回本地然后打开。（根据网络情况速度有所不同）
我的日常使用 在我的日常使用中，大部分的数据存在 OneDrive 云端，随时可以拉下来进行处理（不管是电脑还是手机）。手机与电脑之间没有隔阂，而且我也再也不需要依赖于设备，就算我的电脑暂时不在身边，我也可以用手机暂时代替工作（体验没有 WPS 好但够用）。
因为我的打字速度比手写的速度要快，所以在上课时合理利用 OneNote 的快速笔记功能去记录一些笔记会比手写来的方便，后期也便于整理。
尾巴 - 为什么是Office？ 为什么我选择了Office？
首先是体验的问题，微软的 Office 365 套件的体验十分舒服。其次让我们从价格来简单地理一下：</description>
    </item>
    
    <item>
      <title>从零开始做 Jarvis——基于 Python 的智能语音管家（二）语音识别</title>
      <link>/posts/2019/20190522-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%81%9A-jarvis%E5%9F%BA%E4%BA%8E-python-%E7%9A%84%E6%99%BA%E8%83%BD%E8%AF%AD%E9%9F%B3%E7%AE%A1%E5%AE%B6%E4%BA%8C%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/</link>
      <pubDate>Wed, 22 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/20190522-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%81%9A-jarvis%E5%9F%BA%E4%BA%8E-python-%E7%9A%84%E6%99%BA%E8%83%BD%E8%AF%AD%E9%9F%B3%E7%AE%A1%E5%AE%B6%E4%BA%8C%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/</guid>
      <description>让我们用Python去做一个Jarvis吧！
这一部分主要是语音识别部分的Python实现，而且由于这是我利用课余时间而作，所以相对于其他的项目而言进度可能并不会特别迅速，更新缓慢且随缘。
序 那我们就从前面的框架开始动手实现我们的 Jarvis，首先给大家看一下我的文件目录框架：
其中我把所有自己写的py模块统一归入_module文件夹，供main.py调取，_sounds文件夹存着因为语音识别以及TTS产生的音频文件。
因为目前的结构还不是特别庞大，可能后面会因为管理或者功能增加等等的原因进行修正。如果有改动我会在后面进行补充。
作为一个懒人程序员，并且本着不重复造轮子的原则，我决定先到网上搜一搜有没有现成的解决方案能够直接使用的。
Emmm&amp;hellip; 貌似没有，但这并不影响我们的功能实现。
我们把语音识别的问题拆分开来，便是：
麦克风录音 语音识别成文本 返回文本 然而幸运的是，百度在语音识别方面有着成熟的API以及SDK提供使用，所以在这个方面我们真正需要自己实现的部分只有录音方面了。
后期补充：目前我将这一方面的算法转用腾讯 AI 平台实现，并为此写了一套 SDK，如有需要的话可以参考我的项目。 这并不影响下面百度平台的实现。
语音录入生成.wav文件 我将语音录入的方法写在了recognition.py中，与语音识别等功能放在一起便于调用和管理，后续编辑也会方便一些。
在语音录入方面我们需要调用Pyaudio和wave模块，如果没有安装的话可以通过pip、conda或者Pycharm安装，方法这里就不赘述了。
然后首先我们需要导入这两个模块：
import pyaudio import wave 然后便是具体的方法实现，我写了一个def audio_record，这个部分的功能便完成了录音，并且会将录音保存为.wav格式。
def audio_record(out_file, rec_time): # out_file:输出音频文件名, rec_time:音频录制时间(秒) CHUNK = 1024 FORMAT = pyaudio.paInt16 # 16bit编码格式 CHANNELS = 1 # 单声道 RATE = 16000 # 16000采样频率 p = pyaudio.PyAudio() # 创建音频流 stream = p.open(format=FORMAT, # 音频流wav格式 channels=CHANNELS, # 单声道 rate=RATE, # 采样率16000 input=True, frames_per_buffer=CHUNK) print(&amp;#34;I&amp;#39;m listening.</description>
    </item>
    
    <item>
      <title>从零开始做 Jarvis——基于 Python 的智能语音管家（一）</title>
      <link>/posts/2019/20190521-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%81%9A-jarvis%E5%9F%BA%E4%BA%8E-python-%E7%9A%84%E6%99%BA%E8%83%BD%E8%AF%AD%E9%9F%B3%E7%AE%A1%E5%AE%B6%E4%B8%80%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Tue, 21 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/20190521-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%81%9A-jarvis%E5%9F%BA%E4%BA%8E-python-%E7%9A%84%E6%99%BA%E8%83%BD%E8%AF%AD%E9%9F%B3%E7%AE%A1%E5%AE%B6%E4%B8%80%E7%AE%80%E4%BB%8B/</guid>
      <description>让我们用 Python 去做一个 Jarvis 吧！
这一部分主要是先前的大体介绍，而且由于这是我利用课余时间而作，所以相对于其他的项目而言进度可能并不会特别及时，更新缓慢且随缘。
序 先简单地做一下项目介绍。
在一次比赛现场与朋友攀谈，并由此激发了一个一直存于我内心的想法——做出像钢铁侠的 Jarvis 一般的智能助手。它能够在日常生活和工作学习中为我及时提供建议以及我所需要的信息，还能够帮我管理我的社交网络以及我的各种数码设备等等。
当时与朋友聊完这个宏大愿景后，我便留下了不学无术的泪水（毕竟能力有限 TAT）。所以结合目前的状况，我简单地对其可行性进行了进一步的思考和完善。
其实，从技术上实现一个在生活辅助方面的智能语音助手并不难。而现有的产品之所以功能并非如此强大，更多是公司的商业考量和对用户隐私的保护。
所以，怎么做？ 迫于技术上的压力，我目前的暂时性目标，是做出一个“简易版”的 Jarvis。它离真正的“人工智能”有着一定的距离，定位是一个在日常的工作和学习中能够帮得上忙的（至少比我手机上的小爱要来的有用的）“智能程序”。
所以围绕着这个，我产生了以下的想法：
首先要做到的是我们的 Jarvis 能够对我们说的话有基本的反应行为，比如查查天气、问些问题、聊聊天，诸如此类。其次便是一些高级的操作，比如随时检索我们彼时工作或者学习等方面所需要的任何信息；根据我们的情况作出合理的决策；跨设备交互和智能的设备控制和管理等等。 然后便是怎么做？截至我写作的时间，由于我的 Python 方面做过的项目比较多，所以选择了 Python 作为主要语言。
从结构上来看，我们如果要实现一个闭环，就需要做到语音识别，NLP，信息处理和分析，语音（或者画面）反馈。由于我有着 Jarvis 情怀，所以我会倾向于先完成语音部分的反馈环节。 至此，我们完成了整个项目的大致框架，显然，我们后续的程序框架以及整体思路也会依照这个来展开。
下一个部分，我会介绍语音识别部分实现。
Peace.</description>
    </item>
    
    <item>
      <title>解决 Xshell 中 jobs 命令不显示后台任务</title>
      <link>/posts/2019/20190206-%E8%A7%A3%E5%86%B3-xshell-%E4%B8%AD-jobs-%E5%91%BD%E4%BB%A4%E4%B8%8D%E6%98%BE%E7%A4%BA%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1/</link>
      <pubDate>Wed, 06 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/20190206-%E8%A7%A3%E5%86%B3-xshell-%E4%B8%AD-jobs-%E5%91%BD%E4%BB%A4%E4%B8%8D%E6%98%BE%E7%A4%BA%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1/</guid>
      <description>在踩了很多坑后，分享一下我在XShell中用Nohup等命令执行后台操作之后将任务释放掉的方法。
之前在折腾服务器的时候，在服务器上挂了一个 Hexo 网站，后来因为网络原因 XShell 直接断连了。好不容易解决了网络问题之后，登录服务器，输入jobs发现 Hexo 并没有出现在列表里面。
后来差了一些资料发现，jobs 命令只能查看当前 XShell 连接服务器窗口创建的任务。由于我并没有用 nohup 去启动后台任务，所以控制台没有显示。
所以后来我采用的方法是使用ps aux命令，然后可以查看服务器的进程情况。
找到想要释放的进程名以及其对应的PID号，然后kill -9 pid号将进程杀死即可（也可以直接kill pid）。
Peace.</description>
    </item>
    
    <item>
      <title>2018 年度总结</title>
      <link>/posts/2019/20190129-2018-%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</link>
      <pubDate>Tue, 29 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/20190129-2018-%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</guid>
      <description>一九伊始，万象更新。在新的一年里我的愿望是——吃不胖！！！
辞旧迎新，简单地总结一下过去一年来所发生的事情。
接手了一个 06 年的老项目，有关图像压缩算法和防篡改数字图像水印嵌入。我在其中做了文档管理和研发（其实做的部分也不多，更多是学习了很多前沿的算法以及概念）。 做了一个深度学习的方言识别算法的项目，最后也做出了成果~~（成功混了学分）~~。 用 Hexo 做了博客，尽管当初十分简陋。 整理了一下 GitHub，因为以前都是 Fork 项目学习，不敢放上自己的垃圾代码，所以我的 GitHub 空空如也。最近 Microsoft 收购了 GitHub，开放了 Private 的权限，所以我打算把自己的代码都放到 GitHub 上面。 参与设计了几次大型的校级晚会，按照以往的经验以及时间安排，今年大概是我最后一年给学校做晚会设计了。 熬过了双学位的第一个学期，经受了无数的 Pre、paper 还有 deadline 的洗礼，感觉自己已经没有什么困难和折磨躲不过的了。
当然这一年还是有很多的遗憾的：
成功地申请通过了某站的特邀设计师，但是因为设计的要求太多，时间太紧，最后还是无奈放弃掉了。 没有申请参加超算比赛，后来才发现其实难度并没有我所想象得那么高。 想着在数模比赛找大佬一起好好努力，结果最后除了论文以外我一个人全包，白白浪费了一次机会。 没有好好地认真学习（日常抱怨）。 大学生活已经过去了一年半，心态已经发生了很大的改变。
对于今年的计划，我也有了大致的规划，也希望能够一切在我能力之内吧。
我去疯狂写算法了，回见。</description>
    </item>
    
    <item>
      <title>生日聚会</title>
      <link>/posts/2018/20180917-%E7%94%9F%E6%97%A5%E8%81%9A%E4%BC%9A/</link>
      <pubDate>Mon, 17 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/20180917-%E7%94%9F%E6%97%A5%E8%81%9A%E4%BC%9A/</guid>
      <description>一篇短篇，篇尾有对于剧情脉络的解释。
正文 一扇陈旧的门伴随着岁月婆娑的咔吱声被缓缓打开，男女相伴走了进来。
“什么破地方……不是说好的生日聚会吗，怎么就选到了这么偏的个地儿……”男子上下打量着，言语如同这周遭的环境一样散发着令人厌恶的气息。
“大华不是说了吗，要一起玩一些解谜游戏，所以挑了这样一个偏僻的地儿，顺便还要给我们个什么惊喜。”女子没管男子，径直走进房间中央细细观察着，狭窄的空间内只容有中央的木桌子，木桌子中间竖着摇摇欲坠的白色蜡烛。
“他还没来啊……那咱先等等吧。”男子顺着微弱的光亮找到座位坐了下来，顺势掏出口袋里的打火机。
“还好带着个打火机。”
嚓，伴随着火星，一串小火苗点燃了蜡烛，照亮了房子，集装箱般的封闭，甚至没有窗户，闷热而狭窄，二人对坐着，空气仿佛也凝固一般的沉寂。
“诶？这次是就咱们仨吗？”男子首先打破了这片刻的寂静。
“好像还有强子。”
“他不是出国了么，好像我们高二就没再见过他了。”
“对呀，五六年没见面了，不直到现在出落成什么样了。”
“他家好像是因为家里有事才出国的，我以前还听说是因为他爸。”男子仿佛打开了话闸子。
“他爸？”
“对，”男子挪挪身子凑近蜡烛，声音渐渐变轻。“他爸是我们那儿的钢铁厂厂长，赚得那叫一个盆满钵满。不知怎的，后来厂里有员工闹事，还打砸了几件大机器。听别人说好像他爸直接吞掉了员工的工资，卷着钱带着一家跑了。”
“好几个亿呢。”男子又凑近了点，火焰就快要燎着了他的头发。
“他以前还追过我，早知这样，我就跟他在一起了。”女子眼睛瞟向他方，小声说着。
“大华不也还追过你吗，”男子突然远离蜡烛，眼神渐渐落到蜡烛上。“大华人那么好，只可惜后来不知怎的，就转学了。能想起我们这些老朋友，也算是不忘当年朋友情啊。”
“其实吧，我知道大华为什么转学，”女子渐渐低下了头。“以前大华和强子都喜欢我。后来他们在校旁边的巷口打了一架，大华带着一帮人找强子算账，嘴巴里还一直喊着什么什么‘张弘亮’，像是一个人的名字。”
“后来大华一个人被带进警察局，然后过了那几天之后他就转了学……我一直觉着他们这么打架，肯定会出事情，所以我影响一直很深，也对此有些愧疚。”她补充道。
“唉，过去的就让它过去吧，都大学快毕业的人了，向前看，还有无数挫折等着你，抓着过去那不是自讨苦吃吗。”男子打趣道，似乎想缓和一下气氛。
“也许吧。”女子应付着笑了笑，然后问道：“那强子现在怎么样了？”
“他好着呢……上了哈佛，现在可是海归回国，进了家金融公司，底薪就是几十万。”男子说着，眼神突然黯淡下来。“这钱可是咱这些人几辈子也赚不来花不完的啊……”
突然，蜡烛的火焰剧烈摆动，门被轻轻地打开，一个衣冠楚楚的高瘦男子走了进来。
“哟，说曹操曹操到。强子，快来坐快来坐。”男子一眼就认出了他，连忙招呼他就近坐下。
“你们来这么早啊……诶？大华呢？”强子边找着位子坐下边问。
“他之前微信说要给我们个惊喜，可能会来晚一些，所以先让我们等一会儿。”女子答道。
强子点点头，也开始打量着四周的环境。
男子连忙将手搭在强子肩上，套近乎地说着：“想不到你这么多年过得挺好嘛。”
“好啥……糊里糊涂的就跟着我爸出国了，糊里糊涂的就上了大学，后来在美国待不下去了，回国混口饭吃。”
“哟……这还糊里糊涂考上了哈佛……我糊里糊涂参加高考，也就上个大专了。”男子戏谑地说道，语气带着一丝嫉妒。
“哪是考上的，我爸给哈佛捐了一大笔钱。这么说吧，”强子似乎也没丝毫遮掩，将自己心里话全盘托出。“毕竟，谁与钱过不去呢。你们的所谓公平，也不过是钱没到位。你也扔个几百几千万，好大学不随你挑？”
强子越说越激动，蜡烛的火苗也不停摇曳，房间突然陷入短暂的沉寂。
强子拿出根烟，刚想抽又放了下去。
“我想忘掉以前那些东西，但这就跟戒烟一样困难。”强子盯着蜡烛，火光似乎没有开始时那么跳跃了，宛如暮年一般。
“所以我今天来，也是想跟他道个歉。毕竟，他爸以前在我们厂里工作，也是个骨干职员，我爸也经常向我提起他。但后来，我也不知道怎么回事，我爸跟大华他爸好像是大吵了一架，然后他爸就开始带着人在厂子里打砸抢。后面事态愈加严重，工厂停摆，我爸赶紧处理完员工工资，带着我们连忙走了。”
“合着，你爸不是贪污逃到美国啊……”男子疑问道。
“你这都哪听说的怪消息……”强子乐了，拍了拍男子。“我爸还为了结工资还倒贴了几十万，剩下的钱都供我念书了。不过大华倒是一直以为是我们家贪了钱还让他爸失业，后来还找人扬言打我一顿。辛亏我当时及时报了警，最后也没什么大碍。”
“大华和他爸好像以前过得并不好，我在家长会上见到过他爸，瘦的皮包骨了都。”男子说着，头不自觉地又靠近了蜡烛。“就跟那吸毒的一模一样。”
“别，你注意一点，人大华待会儿就来了。”强子连忙打断。
“诶，对啊，这么久了，大华怎么还没到啊？”女子看了看门，疑问着说。
火苗越来越暗，已如迟暮。
男子盯着火焰，寻思着说：“这蜡烛，怎么越来越暗啊，质量太差了吧……”
“这么封闭的地方，空气也不流通，可不是越来越暗嘛，我去开门通风。”强子笑着说，然后便转身去开门，试图流通一下新鲜的空气。
“真不愧是海归才子，懂得挺多……”男子若有所思地附和。
“咦……这门怎么打不开了？”强子使劲拧着门把手，但门丝毫没有打开的迹象。
门外，一个黑影将钥匙扔到杂草中，然后匆匆离去，口中念念有词。
“张弘亮，儿子替你报仇了。”
“现在插播一条来自前方发来的报道，近日警方在我市钢铁场内发现并缴毁了一个巨大贩毒窝点，抓获了以张弘亮为首的小型贩毒集团，而厂长不知去向，具体情况还在调查中。”
稍微解释一下 当时我写这篇短篇的时候，为了丰富整个简单的故事框架，我嵌套了很多的线索，但是由于当时没注意，可能导致阅读起来会显得复杂，所以特此解释一下。
黑影是大华，他这次的生日聚会就是为了给其父亲（张弘亮）报仇。因为在他的心中，他的父亲是因为强子的父亲（老板）的剥削，最后生活经济困难自杀而死。
而事实上，大华的父亲是因为吸毒和教唆工厂里的其他工人吸毒，最后自己把自己引入了深渊。
强子的父亲其实为了工厂能继续运转，甚至倒贴了几十万给员工付工资。
而女子一直以为他们之间的矛盾是因为她所致。</description>
    </item>
    
    <item>
      <title>沙拉店</title>
      <link>/posts/2018/20180916-%E6%B2%99%E6%8B%89%E5%BA%97/</link>
      <pubDate>Sun, 16 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/20180916-%E6%B2%99%E6%8B%89%E5%BA%97/</guid>
      <description>找到了一篇以前写的短篇小说，当时纯粹是为了转折而写，剧情强行编凑，也不注重文字的质量，看看便好。
1 空街落下了小雨，我停在了这家沙拉店门口。
大病初愈后，来这家沙拉店的念头一直挥之不去，即便我对此从来没有印象。
9月28日，我的生日，这是我唯一能够记得的关于我的一切——就连我的名字，也是身份证告诉我的。
说来奇怪，在这条路上走了十几年，一草一木，擦肩而过的行人，栖于树下的流浪狗，书店传出来的布鲁斯蓝调……我的记忆里唯独缺了这间开张几年的沙拉店。
随意而坐，未等我从思绪中解脱，服务员便已来到身边，手上轻轻端着一盘新鲜的沙拉。
“这位女士，这是一位先生送给您的生日祝福，祝你生日快乐。”盘子中用蔬菜摆出了一个爱心的形状，如此精致而又熟悉。
我思索着并四处张望，一位附近的陌生的先生看着我，双手紧张地盘绕在胸前，眼神时不时掠过我的方向，他似乎想说什么，却又碍于情面。
素未谋面却如此慷慨大方，大概我们在往日的时光掠过几面罢。我知道我可能认识他，就像我可能曾来过这家沙拉店一样。
我走上前，换到了与他相对的位置，和他接起了话。大概是因为熟络了起来，他很乐意地诉说起了关于他的一切。
他说他的妻子失忆了，他说他的妻子曾痛苦地咬住他的手臂，他说他很对不起之前所发生的一切，他说他是一个可怜的人。
他挽起袖子，臂间的两道齿印清晰可见，黑得发紫，圈成了深深的椭圆。
他是个可怜的先生，至少当时我是这么想，也没流一滴泪。
几天后，我来到了一家新的沙拉店，坐了下来，服务员热情地上前招待，并送给了我一盘沙拉。
“这是旁边那位先生为您点的沙拉，请慢用。”
一位模样如此陌生的先生坐在窗前，我不曾记得我们有过四目相对。
他穿着短袖，阳光照在他的手臂上，映着两道清晰的伤痕。
我想，他大概也是一位可怜的先生罢。
2 星星点点，淅淅沥沥，春潮带雨晚来急，闲路无人车自横。
这是我第九十八次整齐地站在柜台前，第三十六次望着窗外小雨落地成花，第二十
七次遇见躲雨的她，我看了看墙上的挂钟，九月二十八日晚上九点零二十秒，刚刚好。
她总是喜欢坐在墙角的靠窗座位，把头搭在双手间，一言不发。我做好一份沙拉，她吃下，付钱，离开，宛如精心编排的无声电影。渐渐地，这似乎成了我们两人间早已存在的默契。
二十七岁后，我是这家沙拉店的厨师，也是老板。准确的说，我是艺术家，沙拉只是我的表现方式。每一份沙拉，都是手间雕琢的艺术品，而至于我是谁，这貌似并不重要，如果非要称呼我些什么——就叫我大柱吧。
自从去年的那次车祸开始，我就忘记了二十七岁以前的事，包括我的名字，和我的妻子。
“老板，帮我给那位女孩儿点一份沙拉，任意都行。”
“你们……认识么？”
“这倒不是，我只是想给与我同样可怜的人一丝宽慰罢了，但愿她能在享受沙拉时能忘掉不快吧。还有，今天是她的生日。”
他的手臂上两道伤痕依稀可见，我似乎从他的沧桑中看到了氐惆。他说这是他妻子的咬痕，但我不相信，如此深刻的印记，更像是钝器的猛烈袭击所致。
他付了三份的钱，然后回到了窗边的座位上。
手起，刀落，调味，装盘，摆放，我特意将食材摆成一个爱心。作为一个沙拉店老板，我觉得这也许能让她感受到世界的美好，忘却烦恼。
“这位女士，这是附近一位先生送给您的生日祝福，祝您生日快乐。”我将沙拉摆在她的面前，小心地说道。
她四周看了看，目光最终移到那位陌生男子身上。
她真是一个可怜的人，左手无名指带着一枚戒指，想必她曾有过一个幸福的家庭吧。
我曾经也有一个相似的戒指，但那次车祸之后，我什么都不再记得，便也丢了它。
这个晚上，他们俩聊了很久，我也听了很久，女生的故事让我想起了许多，有些场景甚至那么相似。
大概，我们在往日的时光掠过几眼罢，但很可惜，我却一点印象也没有。我只记得我的妻子爱吃沙拉，我就做给她吃，可我现在只记得了沙拉，忘了她。
我收拾好了桌面，擦净地上的雨水，关门，打烊，送走两位陌生的客人。
可我似乎在哪儿见过他们，我想。
这是我第九十九次整齐地站在柜台前，第三十七次望着窗外小雨落地成花，第二十八次遇见躲雨的她，嗯，九月二十八日晚上九点零二十秒，刚刚好。
“是旁边那位先生为您点的沙拉，请慢用。”我再一次把沙拉轻轻地放在她的桌前。
这一次，我仿佛想起了一切。
3 我始终忘记不了那天下午。
我一如往常走在路上，小鸟依行，心情平淡。一天忙碌后，没有什么能比一份沙拉更能舒缓城市快节奏的旋律了。
仿佛是天生自带着来自社会底层的自卑，熟悉地点一份沙拉，熟悉地慢慢咽下，熟悉地任由太阳从天空落到山头，这大概就是这个世界能给我这个可怜的人留下来的唯一的慰藉了罢。
霓虹灯光肆意洒在这钢铁森林间，灯红酒绿，沙拉店就在下一个路口。我站在红绿灯前，沙拉店老板驾着电动车从我身边驶过，我挥了挥手，和他们愉快地打了个照面。
突然，一辆轿车急行而过，如火箭般笔直冲过十字路口。一声巨响，车子和车子的撞击在天际线上擦出火光，我看到了预料之中却不能接受的一切。
我下意识奔了过去，却被路障绊倒在地上，手臂被刺下两道深深的伤痕。
我爸说过，可怜的人终究做着可怜的事，哪怕当个英雄，也只能在拯救世界的前一秒无情地摔倒。
我总以为我就是那个可怜的人，可后来才发现，我连可怜的人都不如。
车祸，流血，天空渐黑，警鸣声响。司机被定为酒后驾驶，车里还放着聒噪的音乐。
这司机真是个王八蛋。
四个月后，老板康复出院，大脑重创让他部分失忆，当我再一次站在他的面前时，他露出了我们第一次相见时的微笑。
我想把一切统统告诉他听，可却没能做到。
9月28日，我见到了阔别已久的另一个人，不同的是，彼时的她格外憔悴。
他们天生一对，可惜上帝给他们开了个玩笑，而死神又当真了。于是，他们活了身体，却死了回忆。
世界上最远的距离，不是什么说不说我爱你，而是连你都记不得了，就算有百分之九十九的回忆被拾起，就算面对面站着，我还是不能想起你。
他笑着说他只记得沙拉了，但我不这么觉得，毕竟他只在给他的妻子做的沙拉中才会摆出一个爱心的形状。</description>
    </item>
    
    <item>
      <title>Photobash 练习 - 大漠发射台</title>
      <link>/posts/2018/20180816-photobash-%E7%BB%83%E4%B9%A0_%E5%A4%A7%E6%BC%A0%E5%8F%91%E5%B0%84%E5%8F%B0/</link>
      <pubDate>Thu, 16 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/20180816-photobash-%E7%BB%83%E4%B9%A0_%E5%A4%A7%E6%BC%A0%E5%8F%91%E5%B0%84%E5%8F%B0/</guid>
      <description>Photobash的第二次练习。
最终效果：
最初图：
Peace.</description>
    </item>
    
    <item>
      <title>Photobash 练习 - 赛博朋克金沙湾</title>
      <link>/posts/2018/20180723-photobash-%E7%BB%83%E4%B9%A0-%E8%B5%9B%E5%8D%9A%E6%9C%8B%E5%85%8B%E9%87%91%E6%B2%99%E6%B9%BE/</link>
      <pubDate>Mon, 23 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/20180723-photobash-%E7%BB%83%E4%B9%A0-%E8%B5%9B%E5%8D%9A%E6%9C%8B%E5%85%8B%E9%87%91%E6%B2%99%E6%B9%BE/</guid>
      <description>Photobash的第一次练习。
最终效果：
最初图：
Peace.</description>
    </item>
    
    <item>
      <title>夏盛荷田田</title>
      <link>/posts/2018/20180723-%E5%A4%8F%E7%9B%9B%E8%8D%B7%E7%94%B0%E7%94%B0/</link>
      <pubDate>Mon, 23 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/20180723-%E5%A4%8F%E7%9B%9B%E8%8D%B7%E7%94%B0%E7%94%B0/</guid>
      <description>记第一次拍摄荷花。
摄于广东，夏。
Peace.</description>
    </item>
    
    <item>
      <title>重建 Hexo，新的开始</title>
      <link>/posts/2018/20180714-%E9%87%8D%E5%BB%BA-hexo%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/</link>
      <pubDate>Sat, 14 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/20180714-%E9%87%8D%E5%BB%BA-hexo%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/</guid>
      <description>经过几个月的沉寂，我打算重新用Hexo写我的博客。
这一段时间一直在忙着别的事儿，所以自然也就把博客放在了一边。
曾经三分钟热度，用GitHub做了一个博客。由于某些原因，我的文章也一篇未放在这儿，空留“Hello World”和landscape。
我之前的文章不是基于Markdown的，所以搬运过来还是需要一些时间，而且因为我最近把主题从Landscape换到了Tranquilpeak，这关主题里面有很多关于写作的语法功能我还没有试过，所以这个主题的文章编写我还不是特别熟练。
以后慢慢把文章放上来吧。
Peace.</description>
    </item>
    
    <item>
      <title>CD 封面设计</title>
      <link>/posts/2018/20180517-cd-%E5%B0%81%E9%9D%A2%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Thu, 17 May 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/20180517-cd-%E5%B0%81%E9%9D%A2%E8%AE%BE%E8%AE%A1/</guid>
      <description>这次做了一个 CD 的封面设计，自我感觉还行。
Peace.</description>
    </item>
    
    <item>
      <title>城市天际线 游戏截图后期</title>
      <link>/posts/2018/20180517-%E5%9F%8E%E5%B8%82%E5%A4%A9%E9%99%85%E7%BA%BF-%E6%B8%B8%E6%88%8F%E6%88%AA%E5%9B%BE%E5%90%8E%E6%9C%9F/</link>
      <pubDate>Thu, 17 May 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/20180517-%E5%9F%8E%E5%B8%82%E5%A4%A9%E9%99%85%E7%BA%BF-%E6%B8%B8%E6%88%8F%E6%88%AA%E5%9B%BE%E5%90%8E%E6%9C%9F/</guid>
      <description>最近迷上了城市天际线这个游戏，安装了巨多的插件之后画面十分好看，所以我截了一些图做后期练习用。
Peace.</description>
    </item>
    
    <item>
      <title>日月贝之行</title>
      <link>/posts/2018/20180503-%E6%97%A5%E6%9C%88%E8%B4%9D%E4%B9%8B%E8%A1%8C/</link>
      <pubDate>Thu, 03 May 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/20180503-%E6%97%A5%E6%9C%88%E8%B4%9D%E4%B9%8B%E8%A1%8C/</guid>
      <description>记在日月贝的一次建筑拍摄。
摄于广东珠海日月贝，夏。
Peace.</description>
    </item>
    
    <item>
      <title>404</title>
      <link>/pages/404/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/pages/404/</guid>
      <description>Oops，这个页面不见了，要不再看看别的页面呢？ 可能是以前博客改版之后路径改了。</description>
    </item>
    
    <item>
      <title>About</title>
      <link>/pages/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/pages/about/</guid>
      <description>我是谁 江湖外号赵铁柱，某厂卑微后端 业余摄影师，主风光建筑少拍人像，如今往 Photobash 方向靠近 Stable Diffusion 探路者，目前在探索图像生成和 AI 辅助后期 喜欢古典、德云社老票友，票龄估摸小十年 喜欢轻量化和极简风，胸无点墨只能勉强做一些思考 黄瓜味乐事和无糖可乐的坚定拥护者 关于这里 技术思考和总结，写写历程和发展路径 日常记录，心事想法和脑洞 联系方式 邮箱：echo Y2xhcmVuY2VlaHN1QDE2My5jb20K | base64 -d Github 博客信息 博客基于 Hugo 搭建，采用 Winston 主题进行深度定制
Copyright (c) 2022 CC-BY-NC-4.0 LICENSE</description>
    </item>
    
    <item>
      <title>Gallery</title>
      <link>/pages/gallery/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/pages/gallery/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Log 2019</title>
      <link>/log/2019/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/log/2019/</guid>
      <description>2019.12.08 不小心进了 ASC 校队，寒假得留在学校了。
2019.11.19 我喜欢李诞这个人是因为他的幽默和说话的方式，而不是他的佛系和人间不值得的价值观。
我的价值观就是在社会阶级固化之前尽力往高了爬。现实社会哪有那么多的佛系青年，都是高度封装的对社会焦虑的逃避。
2019.11.5 以后除了实验目的，我再也不折腾动态框架了，我突然觉得 Hexo 十分适合我这种不太喜欢特别折腾的人。
2019.10.7 今天彻底搞定了 Django 的博客系统搭建，然后因为想让文章管理更方便转移和多向配置，所以就直接 IO Markdown文件了。
2019.9.15 今天突发奇想又搞了一下 Django，然后解决了之前没能够解决的几个问题，所以现在的 Django Blog 会比以前好得多，所以 Django 继续提上日程，等优化好后就转到 Django 上。
2019.9.7 突然发现最近已经很少写一些技术性的文章了，主要是想打磨一下自己的技术栈，而且最近学业繁忙所以很少顾及。
2019.8.20 写了一篇英文的文章，突然发现英文的排版还是有些不尽如人意，后面还是要改改 css 了。
2019.8.13 改了一下博客的 css，改了博客文章页面的效果和首页的每条文章的显示，感觉细节比以前更加好看了些。
2019.7.25 博客的 Django 化完毕，但是由于我的 Web 技能不是特别熟练，仅是处于套模板阶段，所以只是把底层全部完善了一遍。考虑到以后可能会重新部署到 GitHub 上，所以目前还是回到了 Hexo 框架，便于维护文章。
2019.7.18 最近因为考完试，所以除了学车之外也放松了一段时间，然后把博客的 Django 化提上了日程，做了一个 Demo 放在 8000 端口。
继续深化 Python 还有 C++，学习 Java 尽量吧。
2019.7.7 今天我突然决心把博客的底层给换成自己写的底层，从而直接脱离 Hexo。
所以最近博客的外观不会有多少改动。
2019.6.25 简单修缮了一下网站，改了一下结构。
2019.6.22 刚刚搞了一个类似于日志的页面，打算在这里记录一些随想，随便写些什么。
&lt; 2020 </description>
    </item>
    
    <item>
      <title>Log 2020</title>
      <link>/log/2020/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/log/2020/</guid>
      <description>2020.12.27 终于大半年的考研历程终于结束了，整理几天心情，迎接接下来的期末考试 XD。
2020.09.27 终于抽出时间完善了整个部署的流程，现在可以流畅地进行三端部署了，接下来简单完善细节即可。
ASC 延期了大半年终于开赛，希望自己能够平衡好各种琐事吧。（笑）
2020.09.15 这两天因为其他的事情比较忙，而且需要多花一些时间改善博客的渲染器以及部署流程，所以博客只能停止更新几天。
2020.09.13 新学期新气象，在学校待了十几天，也算勉强适应了这个笼子里的生活。其实这跟我平时在家里也别无二致，我以为我会因此自闭寡欢，但我的确没有损失掉心情，这大概是因为我内心生活足够丰富吧（笑）。
最近趁着空闲，把博客改版换了首页，顺便重新设计了一下整个部署流程，实现了自动化发布。
2020.08.03 最近想趁着《星际穿越》重映之际，写写自己的感受和看法，但还是因为时间所迫而放弃了。平时除了学习和运动，就只能有少数时间用来娱乐，很多东西也渐渐都没了兴趣。
2020.07.30 果然用 C++ 也是十分愉快的，以后我需要多练练自己在 C++ 环境下的写码能力了。同时为了防止日志页面过长影响观感，所以后面会好好改进一下这儿。
2020.07.28 最近又新添了一块机械键盘（AnnePro 2），感觉还可以。我一直以为机械键盘会影响我的打字速度，但是实际用起来却没有明显的不适感，而且全键无冲可编程的配列可玩性也高了很多，真正能做到一把键盘走天下。
2020.07.21 这两天的阿里云到期了，然后换了腾讯云来搭建网站和一些服务（主要是便宜）。本来我想着用家里的树莓派 FRP 穿透来搭建网站，但是 zeesa.in 域名的 SSL 证书一直下不来，所以只能作罢。
最近除了学习之外的计划，就是把树莓派做成服务器的网站内容分发平台，以后换服务器部署会方便很多；然后博客的生成器从现在的 Hexo 转为 Hugo。因为我感觉 Hexo 实在是有点慢，另外是想试试新的静态网站生成器。
2020.07.14 昨天考完了复变函数之后，大三就正式结束了。不得不说，这个学期因为疫情而略显得魔幻了许多。比如之前我在补考之后才收到查卷结果发现我并没有挂科，白白花了大量时间复习——如今想想都觉得十分欧亨利。
最近阿里云快到期了，所以我顺势把博客托管到了 Netlify 上，感觉速度还可以接受。
2020.06.22 最近两天课程设计、期末考试和考研复习的压力渐渐上来了，而且还要为了体测而减重。每天基本过着苦行僧一般地生活，各种欲望被压到了最低。
本想着云通关《最后生还者2》来放松一下子，结果看完剧情后更压抑了。
2020.06.13 高校用拉人头的方式请留学生还真不一定是决策问题。面对着硬性指标的红头文件，和国际师生占比 10% 的世界大学排名评分，这的确比真真切切提高教育质量要来得“高效”。我管他是高考移民的假洋人还是真洋人，硬凑就完事儿了。
2020.06.04 这几天一直在搞树莓派，不得不说还是自己以前玩的太浅。花了几天的时间写了 daemon，让树莓派能够有断电断网重新连接的服务，然后用 frp 给做了内网穿透，顺便把自己的博客也搬了上去。
不过最近陆续开始期末课设了，马上也要到了考试周，时间也显得不够了起来。
2020.05.11 其实，对于像我这样大概率没办法第一时间拿快递的人来说，有一个中转站确实能提高双方效率，我喜欢这样灵活的设计。
但是丰巢这几波操作属于一手好牌打得稀烂，2b 的业务搞成 2c 还要强制性使用并收费，有一个算一个全是流氓。
2020.05.04 假期一下子就过去了 4 天，果然学习才是硬核的时光荏苒，真正的时间机器。
今天 B 站有一个“后浪”的宣传片，看完的确心潮澎湃，但经不起细想。弹幕上很多人都以为自己是后浪，然而现实是残酷的。“后浪”给我们展现的澎湃也只是浮华的少数，更多的人是海底暗涌，他们内心翻腾，却也心甘情愿地奉献了自己平凡的一生。
向所有人致敬。
2020.04.28 今天心血来潮看了看番，我发现那些“有妹有房，父母双亡”的剧情一般就是是初高中生的轻小说的改编。不知道这是一种通用背景设计，还是因为年轻的经历无法在小说中支撑一个完整复杂的世界观。</description>
    </item>
    
    <item>
      <title>Log 2021</title>
      <link>/log/2021/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/log/2021/</guid>
      <description>2021.10.02 又整理许久，今可得重新起航。开始填坑，祝各位国庆节快乐！
2021.07.22 过了良久，终于整完了大部分身边的琐事。突然发现自己已经很久没有正经写过文章，而且还留了一篇草草写出来的半成品，填坑提上了日程；另外，日常的做题和代码维护也得重新恢复起来了。
2021.06.27 毕业如同其他的人生节点一样，我们知道这一刻并为之努力良久，也知道它终究会到来并做足了准备。可当真正来临时——大概是因为未来的迷惘或者过去的遗憾——也依然会感到不舍，并时而怀念。
2021.05.26 又改了博客的整体结构，现在彻底转为 Vercel 托管 + 自建图床的方式，感觉体验十分不错（逃）。
2021.05.20 伴随着答辩、毕业照和提交相关资料的结束，大学生涯也渐渐画上了句号。当然，这样的一段时光充满着或好或背的回忆和遗憾，如果以后有时间，我会好好地梳理一下这四年的时光。
2021.05.07 有时候碰到了壁，也会随心地自我安慰一句“人哪能万事顺意”。但多了又难免觉得自己的能力十分有限，仿佛困在原地动弹不得。
2021.04.30 我一直觉得，人开始回忆起过去是一种不好的现象。
2021.04.05 终于把博客部署到了国内的服务器上，并且抽空把页面给优化了一下，解决了博客页面文章不明显以及公式太大的问题。
有一说一 Docker 是真的方便，pull 完镜像配置、bash 脚本传上服务器，一跑就成功部署了。（逃
2021.03.15 这几天的经历让我再一次感受到了极大的压力，如果有时间，我一定会把所思所感好好记录下来。
人呐，还是要乐观一些的。
2021.02.27 还是来了，科软炸的速度超出了我的想象，我早已不记得当初为何会选择这条路，也不记得为何会报上科软；我只记得我再也不会回到哪个时候。我曾认为两手准备可以很好地解决考研和工作之间的问题，但如今我仍为之哭泣。我大概再也不会认为自己是一个能够独立做出规划的人了罢，留过了眼泪却不知为何而流，仓惶而麻木，匆匆破防。
这样说不定也挺好的，我就这样安慰自己。
2021.02.21 众多情绪夹杂在了一起，我又陷入了频繁的焦虑中。
2021.02.09 晚上凑了点时间，把图库里的图片全部转移至国内的图床 CDN，再也不用为了省流生成 thumb 图了。文章的图片由于数量庞大还没有全部转移到图床，目前计划在自己搭了图床之后才去做批量转移。
2021.02.04 今天搞了一下混合语言开发，结果 VSCode 官方 C/C++ 插件的一个坑折腾了我一个多小时。
原来插件 lint 时的检索库的顺序是与环境变量相隔开的，插件 lint 的顺序还需要在 c_cpp_properties.json 文件中去添加相应的路径，这样才不会报错，否则会出现 make 成功但是代码标红的现象。
这个问题在发现之前毫无头绪，发现之后就“为啥这都能错”（逃）。
2021.01.14 感觉 Vercel 的 CDN 有点慢，后续计划自建图床，把所有的图片挂在图床上来加速国内的资源访问。
2021.01.13 新年新气象，由于去年一年学业繁忙，博客的外表还是一如既往没有大改；另外我抽时间优化了生成流程，使其如今变得更加自动化。从服务器端生成到本地生成三端部署，再到现在为了方便不同环境使用而转移到了 WSL，写博客也越来越方便（逃）。
有一说一，WSL 的使用体验十分出色，以至于我把所有的开发环境全部转移到了 WSL 中，今后换电脑什么的可以直接 import WSL 镜像，而不用大费周章去不停进行各项配置了。</description>
    </item>
    
    <item>
      <title>Log 2022</title>
      <link>/log/2022/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/log/2022/</guid>
      <description>2022.12.25 最近看到了这样的一句话：很多时候孤独是一种双向的拒绝，世界不关心我们，我们也不爱搭理世界；但是偶尔当我们想要暂时摆脱孤独的时候，才发现我们想要的孤独，是那种世界每天都绕着我转，我扒拉开世界一个人的静静的主动型孤独；而不是那种，每次买两个麦旋风都得存一个的被动型孤独。
突然发现这句话有一种在点我的真实感，人还是要保持和这个世界的联系的。
2022.12.16 小半个月的培训终于结束了，在一个新的场景和环境里认识了很多不同岗位的人，也算是小有收获；后面会开始恢复更新博客，尽量保证每周都能够有产出吧 🤣。
2022.12.04 休息一年，然后回来。
2022.12.03 今天折腾了一下 Gallery 页面，效果还不错；同时多亏自己的图片全部放在图床上，整体改动不大。不过页面不能自动化去生成就很膈应，后续还需要改造成 Hugo 的渲染页面，通过自动化的方式来管理。
2022.12.01 果然，给博客整了一个大活后，整个人对于更新博客这件事的动力就高了很多，甚至要写的文章和话题多到列成了一张小表。
我以前都极少在博客里面去分享自己的生活，这在曾经的我眼里是一件非常私密和难以启齿的事情；而如今我也变得乐意敞开心扉，放开地去面对这件事了。这或许是自己从社恐和自闭的状态，往外去发展和表达的一点小小的进步？
2022.11.26 这两天琢磨了一下 Hugo 的生成逻辑和结构，也算是成功地换上了一套新的皮肤；把后端换成 Hugo 后，可算是成功摆脱了 node_modules 依赖黑洞（逃
2022.11.24 很久没有更新博客了，最近主要在搞两块事情：一个是博客版本大更新（没错就是这个博客），博客的生成器要从依赖黑洞 Hexo 迁移到更精简的 hugo，皮肤换成全新的，同时部署流程也要简化；另一个就是 containerd 的博客内容输出，最近一直在深入研究 containerd，所以想着输出一些文档来记录一下，以后说不定能够用上。
当然还有生活上的点滴，日后也会一并更新到博客里。
2022.11.10 木已成舟，终有尽时。塞翁失马，焉知非福。
2022.11.02 晚上把最近多多少少发生的事情，都和父母讲了一遍。出乎我意料的是，他们对于我所认为的难事都十分地乐观。生活阅历的浅薄，总是让我没有那么大的勇气和精力去慢慢理解消化这些事情，只能先硬着头皮去应对——或许这也是每一个人的必修课。
于是，我开始用视频来记录每天的想法，也渐渐习惯上了这样的感觉。成长为更加自如从容的一个人，现在也变成了我不小的一个追求。
2022.10.30 又到了一年的生日，先祝自己生日快乐（笑）。
不知不觉又一年，还有两个月元旦，又得写年度总结了。我决定以后每个年度总结里，都给自己定一些长达一年、需要坚持才能达成的小目标；然后再来一个大的方向性计划作为冲刺型的目标，希望自己能够循序渐进，厚积薄发吧。
最后附一首 Frank Sinatra 的《That&amp;rsquo;s Life》，与未来的自己共勉。
2022.10.22 最近翻了一圈我爸的微博，得到了很多的治愈，勉强抚平了自己近日的焦躁。这么多年了，我爸依然在很多方面是我的老师。
2022.10.19 最近毫无征兆地进入到了一个滑坡状态：面对着无力抵抗的困境，只能选择降低预期和期望——简言之就是通过放弃自己的方式，来达到心态上的平衡。
这带来最明显的副作用，就是频繁跳出的精神内耗，它大量抢占了思考的时间。我开始刷起了短视频以抵抗失眠；这就跟黑魔法一样，快乐完就开始空虚，只见时间又少了一个小时，伤害和依赖性极强。
时代的一粒灰，压在了我身上。
2022.10.16 大半年都没有管博客的情况，突然发现以前的域名 zeesa.in 已经到期了，因此也下线了很久。今天重新把博客在 zeee.cc 上面给搭了起来，还好之前脚本写的比较完善，直接改个路径就部署上去了（摊手）。
最近这半年光景发生了很多的事，我会找个时间记录到博客里。
2022.05.04 今天电脑网卡突然掉了，设备管理器里显示错误码 10，大概是驱动错误。家里有线网络也有问题连接不上，无奈只能去电脑城找网络。装好后，老板要价 20。他突然笑得很开心，这大概是他赚过最轻松的一笔手工费。
2022.02.09 前两天，在朋友圈里看到学弟一篇长文，充满了自己临近毕业的许多选择和感慨。这让我想到了我毕业时会的日子，可知道最后还是没能骨气勇气记录下来。不得不说，时间就像是不停冲刷海滩的浪，沟壑成滩涂。
2022.02.02 突然心血来潮统计了一下自己去年的一个小数据：快门次数 681 次，出图 23 张，发布 5 张，10 万 + 火了 1 张。这个数据虽然差距很大，但至少能证明我的审美还是没有偏离的。</description>
    </item>
    
    <item>
      <title>博客未来规划</title>
      <link>/posts/2019/20190715-%E5%8D%9A%E5%AE%A2%E6%9C%AA%E6%9D%A5%E8%A7%84%E5%88%92/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/20190715-%E5%8D%9A%E5%AE%A2%E6%9C%AA%E6%9D%A5%E8%A7%84%E5%88%92/</guid>
      <description>在这快两年的时间跨度里（其实才一年），我突然想给自己的博客来一次改进计划。
其实我的博客也有过几次大的改版变化，从一开始的 landscape 到 anatole 再到后来的 tranquilpeak。
但这也仅仅是主题上的改变，内核依旧是 Hexo。
随着我后来在 WEB 方面学习的知识多了，需求也就变多了；
Hexo 十分优秀，但也仍是有着诸多限制，并且不够自由。碰巧我在这几天翻出了很多 WEB 大佬们的博客，给了我许多的灵感。
生命在于折腾，所以我想着要做出一些改变。</description>
    </item>
    
  </channel>
</rss>
