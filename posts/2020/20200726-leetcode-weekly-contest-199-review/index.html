<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>LeetCode Weekly Contest 199 Review - Zee Tsui</title>
  <title>ZC 个人内容记录</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" href="/favicon.ico">
  <link rel="canonical" href="/posts/2020/20200726-leetcode-weekly-contest-199-review/" />

  
  
  <link rel="stylesheet" href="/css/style.min.c813c458db6847576b9bd786addc081f1f218bc0b99cdfe79f2daf35df2e453a.css">
  

  
    
    <meta property="og:title" content="LeetCode Weekly Contest 199 Review"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="/posts/2020/20200726-leetcode-weekly-contest-199-review/"/>
    
    
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:site" content="@zerostaticio"/>
    <meta name="twitter:creator" content="@zerostaticio"/>
  

  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&display=swap" rel="stylesheet"> 
</head>




<body class='page frame page-blog-single'>
  <div id="menu-main-mobile" class="menu-main-mobile">
    <ul class="menu">
        
        
            
                <li class="menu-item-home">
                    <a href="/">Home</a>
                </li>
            
        
            
                <li class="menu-item-blog">
                    <a href="/posts/">Blog</a>
                </li>
            
        
            
                <li class="menu-item-categories">
                    <a href="/categories/">Categories</a>
                </li>
            
        
            
            <li class="menu-item-gallery">
                <a href="/gallery">Gallery</a>
            </li>
            
        
            
                <li class="menu-item-log">
                    <a href="/log/">Log</a>
                </li>
            
        
            
                <li class="menu-item-about">
                    <a href="/pages/about/">About</a>
                </li>
            
        
    </ul>
</div>
  <div id="wrapper" class="wrapper">
    <div class='header'>
  
  <a></a>
  <div class="menu-main">
    <ul>
      
      
      
      <li class="menu-item-home">
        <a href="/">
          
          <span>Home</span>
        </a>
      </li>
      
      
      
      <li class="menu-item-blog">
        <a href="/posts/">
          
          <span>Blog</span>
        </a>
      </li>
      
      
      
      <li class="menu-item-categories">
        <a href="/categories/">
          
          <span>Categories</span>
        </a>
      </li>
      
      
      
      <li class="menu-item-gallery">
        <a href="/gallery">
          
          <span>Gallery</span>
        </a>
      </li>
      
      
      
      <li class="menu-item-log">
        <a href="/log/">
          
          <span>Log</span>
        </a>
      </li>
      
      
      
      <li class="menu-item-about">
        <a href="/pages/about/">
          
          <span>About</span>
        </a>
      </li>
      
      
    </ul>
  </div>
  <div id="toggle-menu-main-mobile" class="hamburger-trigger">
    <button class="hamburger">Menu</button>
  </div>
</div>
    
  <div class="blog">
    <div class="intro-article">
      <h1>LeetCode Weekly Contest 199 Review<span class="dot">.</span></h1>
      
    </div>
    <div class="content">
      <!-- more -->
<h2 id="第一题shuffle-string">第一题：Shuffle String</h2>
<p>给你一个字符串 <code>s</code> 和一个<strong>长度相同</strong>的整数数组 <code>indices</code>。请你重新排列字符串 <code>s</code> ，其中第 <code>i</code> 个字符需要移动到 <code>indices[i]</code> 指示的位置，返回重新排列后的字符串。</p>
<p><img src="https://zeee.cc/pictures/blog/20200726LeetCodeWeeklyContest199Review/q1.jpg" alt=""></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">输入：s = &#34;codeleet&#34;, indices = [4,5,6,7,0,2,1,3]
</span></span><span class="line"><span class="cl">输出：&#34;leetcode&#34;
</span></span><span class="line"><span class="cl">解释：如图所示，&#34;codeleet&#34; 重新排列后变为 &#34;leetcode&#34; 。
</span></span></code></pre></div><h3 id="分析">分析</h3>
<p>这道题的算法比较简单，有两种解法。</p>
<p>第一种是在<strong>不能新建字符串空间</strong>的情况下，可以通过从开头遍历，然后根据 <code>indices</code> 循环交换字符串，直到 <code>indices</code> 正好为该位置的指针时，转到下一个继续进行循环交换。</p>
<p>第二种是<strong>可以新建字符串空间</strong>的情况，这样子就比较简单了，直接新建或复制出一个同等长度的字符串，然后根据 <code>indices</code> 遍历原字符串，然后放到新数组的对应位置即可。</p>
<p>很明显，第一种的时间复杂度为 $O(n^2)$，第二种的时间复杂度为 $O(n)$，所以最终提交的为第二种方法的代码。源码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">restoreString</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">indices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">m</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>  <span class="c1"># 新建一个列表</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="n">m</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># 按照 indices 为指针，把字符放到新列表中的对应的位置</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="s2">&#34;&#34;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>  <span class="c1"># 用 join 把列表合成字符串</span>
</span></span></code></pre></div><p>因为 Python 语言本身不支持字符串的枚举，所以只能生成列表进行操作，最后再合起来。而 C++ 可以直接枚举操作字符串，所以代码相对简单一些：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">string</span> <span class="n">restoreString</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">indices</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">string</span> <span class="n">t</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>  <span class="c1">// 复制一个字符串
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">t</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>  <span class="c1">// 按照 indices 为指针把字符放到新字符串对应的位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h2 id="第二题bulb-switcher-iv">第二题：Bulb Switcher IV</h2>
<p>房间中有 <code>n</code> 个灯泡，编号从 <code>0</code> 到 <code>n-1</code>，自左向右排成一行。最开始的时候，所有的灯泡都是<strong>关</strong>着的。</p>
<p>请你设法使得灯泡的开关状态和 <code>target</code> 描述的状态一致，其中 <code>target[i]</code> 等于 <code>1</code> 第 <code>i</code> 个灯泡是开着的，等于 <code>0</code> 意味着第 <code>i</code> 个灯是关着的。</p>
<p>有一个开关可以用于翻转灯泡的状态，翻转操作定义如下：</p>
<p>选择当前配置下的任意一个灯泡（下标为 <code>i</code>）
翻转下标从 <code>i</code> 到 <code>n-1</code> 的每个灯泡
翻转时，如果灯泡的状态为 <code>0</code> 就变为 <code>1</code>，为 <code>1</code> 就变为 <code>0</code> 。</p>
<p>返回达成 <code>target</code> 描述的状态所需的<strong>最少</strong>翻转次数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">输入：target = &#34;10111&#34;
</span></span><span class="line"><span class="cl">输出：3
</span></span><span class="line"><span class="cl">解释：初始配置 &#34;00000&#34;.
</span></span><span class="line"><span class="cl">从第 3 个灯泡（下标为 2）开始翻转 &#34;00000&#34; -&gt; &#34;00111&#34;
</span></span><span class="line"><span class="cl">从第 1 个灯泡（下标为 0）开始翻转 &#34;00111&#34; -&gt; &#34;11000&#34;
</span></span><span class="line"><span class="cl">从第 2 个灯泡（下标为 1）开始翻转 &#34;11000&#34; -&gt; &#34;10111&#34;
</span></span><span class="line"><span class="cl">至少需要翻转 3 次才能达成 target 描述的状态
</span></span></code></pre></div><h3 id="分析-1">分析</h3>
<p>这道题其实可以直接通过找规律解出。通过几个例子可以发现，其实反转的次数与所给的字符串中的 01 跳变次数的变化一致——当每一个字符串前面不上一个 <code>'0'</code> 的时候，跳变次数就等于反转次数。</p>
<p>Python 代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">minFlips</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">temp</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span>  <span class="c1"># 一开始填个 0</span>
</span></span><span class="line"><span class="cl">        <span class="n">final</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># 翻转次数</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">target</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">temp</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">final</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># 不等时 +1</span>
</span></span><span class="line"><span class="cl">                <span class="n">temp</span> <span class="o">=</span> <span class="n">n</span>  <span class="c1"># 替换 temp 值</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">final</span>
</span></span></code></pre></div><p>C++ 的写法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">minFlips</span><span class="p">(</span><span class="n">string</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">char</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">c</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">((</span><span class="n">d</span> <span class="o">^</span> <span class="n">cur</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">cur</span> <span class="o">^=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">ans</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>二者在算法上是一致的。</p>
<h2 id="第三题number-of-good-leaf-nodes-pairs">第三题：Number of Good Leaf Nodes Pairs</h2>
<p>给你二叉树的根节点 <code>root</code> 和一个整数 <code>distance</code> 。</p>
<p>如果二叉树中两个<strong>叶</strong>节点之间的 最短路径长度<strong>小于或者等于</strong> <code>distance</code>，那它们就可以构成一组<strong>好叶子节点对</strong>。</p>
<p>返回树中<strong>好叶子节点对的数量</strong>。</p>
<p><img src="https://zeee.cc/pictures/blog/20200726LeetCodeWeeklyContest199Review/e1.jpg" alt=""></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">输入：root = [1,2,3,null,4], distance = 3
</span></span><span class="line"><span class="cl">输出：1
</span></span><span class="line"><span class="cl">解释：树的叶节点是 3 和 4 ，它们之间的最短路径的长度是 3 。这是唯一的好叶子节点对。
</span></span></code></pre></div><h3 id="分析-2">分析</h3>
<p>这道题比前面两题要难一些，需要用到 DFS 算法去遍历 <code>root</code> 树，从而找出所有的小于 <code>distance</code> 的路径。</p>
<p>这道题的算法具体就是，从树的底层往上遍历，先对每一个节点计算到父节点的距离（因为子节点有多个，所以到父节点那儿是一组距离向量）；然后父节点再根据子节点的距离参数计算自己到父节点的一组距离向量，以此类推。最后把小于 distance 的挑出来计数即可。</p>
<p>Python 代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">countPairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="mi">0</span>  <span class="c1"># 常规判断空值</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="k">nonlocal</span> <span class="n">ans</span>  <span class="c1"># 使用非 local 的变量</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="ow">or</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># 如果没有子节点，就返回 [1]</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="n">l</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="k">else</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">            <span class="n">r</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">)</span> <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="k">else</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">                <span class="k">for</span> <span class="n">c2</span> <span class="ow">in</span> <span class="n">r</span><span class="p">[:</span><span class="nb">min</span><span class="p">(</span><span class="n">d</span> <span class="o">-</span> <span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">))]:</span>
</span></span><span class="line"><span class="cl">                    <span class="n">ans</span> <span class="o">+=</span> <span class="n">c1</span> <span class="o">*</span> <span class="n">c2</span>  <span class="c1"># 计算满足条件的路径条数</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="n">cur</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">))</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># 新建一个数组</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)):</span>
</span></span><span class="line"><span class="cl">                <span class="n">cur</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># i + 1 处加上左树 i 的值，i + 1 是因为这个数组对应的每一位是层之间的距离</span>
</span></span><span class="line"><span class="cl">                                    <span class="c1"># 即第几层到本层的距离多少，然后加在一起（左右不分，全加一起）</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)):</span>
</span></span><span class="line"><span class="cl">                <span class="n">cur</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># i + 1 处加上右树 i 的值</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">cur</span><span class="p">[:</span><span class="nb">min</span><span class="p">(</span><span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">cur</span><span class="p">))]</span>  <span class="c1"># 只返回小于 distance 的数组（大于的后面计算就无意义了）</span>
</span></span><span class="line"><span class="cl">                                             <span class="c1"># 这样可以减少判断运算</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">ans</span>
</span></span></code></pre></div><p>C++ 的代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dfs</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">t</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dis</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">ans</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="k">return</span> <span class="p">{</span><span class="mi">1</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vl</span><span class="p">,</span> <span class="n">vr</span><span class="p">,</span> <span class="n">vt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="n">vl</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">dis</span><span class="p">,</span> <span class="n">ans</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="n">vr</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">dis</span><span class="p">,</span> <span class="n">ans</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">l</span> <span class="p">:</span> <span class="n">vl</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">r</span> <span class="p">:</span> <span class="n">vr</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">dis</span><span class="p">)</span> <span class="o">++</span><span class="n">ans</span><span class="p">;</span>  <span class="c1">// 遍历向量，计算满足条件的数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">l</span> <span class="p">:</span> <span class="n">vl</span><span class="p">)</span> <span class="n">vt</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1">// 把左距离 + 1，然后添加到末尾
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">r</span> <span class="p">:</span> <span class="n">vr</span><span class="p">)</span> <span class="n">vt</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1">// 同上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">vt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">countPairs</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">distance</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">ans</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>C++ 的算法就比较简单粗暴，原理大致相同，就是往上加，然后满足条件的就使 ans++。此代码没有向 Python 一样剪枝，每次都去掉不满足条件的向量，这在部分情况下会增加运算量，还有一定的优化空间。</p>
<h2 id="第四题string-compression-ii">第四题：String Compression II</h2>
<p><strong>行程长度编码</strong>是一种常用的字符串压缩方法，它将连续的相同字符（重复 <code>2</code> 次或更多次）替换为字符和表示字符计数的数字（行程长度）。例如，用此方法压缩字符串 <code>&quot;aabccc&quot;</code> ，将 <code>&quot;aa&quot;</code> 替换为 <code>&quot;a2&quot;</code> ，<code>&quot;ccc&quot;</code> 替换为 <code>&quot;c3&quot;</code> 。因此压缩后的字符串变为 <code>&quot;a2bc3&quot;</code> 。</p>
<p>注意，本问题中，压缩时没有在单个字符后附加计数 <code>'1'</code> 。</p>
<p>给你一个字符串 <code>s</code> 和一个整数 <code>k</code> 。你需要从字符串 <code>s</code> 中删除最多 <code>k</code> 个字符，以使 <code>s</code> 的行程长度编码长度最小。</p>
<p>请你返回删除最多 <code>k</code> 个字符后，<code>s</code> 行程长度编码的最小长度。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">输入：s = &#34;aaabcccd&#34;, k = 2
</span></span><span class="line"><span class="cl">输出：4
</span></span><span class="line"><span class="cl">解释：在不删除任何内容的情况下，压缩后的字符串是 &#34;a3bc3d&#34; ，长度为 6 。最优的方案是删除 &#39;b&#39; 和 &#39;d&#39;，这样一来，压缩后的字符串为 &#34;a3c3&#34; ，长度是 4 。
</span></span></code></pre></div><h3 id="分析-3">分析</h3>
<p>在这道题的时候，我很快就想出了算法：统计词频，然后从小到大排列，再按顺序减就完了。</p>
<p>但是这道题并不是我想的那么简单，主要问题就出在最优减的解上面，我这个方法在小部分的题目中无法找出最优解（即最短字符串）。</p>
<p>比如说，有 9 个 a 和 10 个 b 的时候要减去 2 个，那么减 b 的数量才是最优解。如果实在上面的算法上加以改进的话，时间复杂度会飙升，所以最后还是选择了放弃（逃）</p>
<p>看到很多人没做出来，我也是平衡了很多。</p>
<p>大佬的 Python 代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">lru_cache</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">groupby</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">getLengthOfOptimalCompression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">K</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">def</span> <span class="nf">rle</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="n">x</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">N</span> <span class="o">==</span> <span class="n">K</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">INF</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1e9</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nd">@lru_cache</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">def</span> <span class="nf">dp</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">curlength</span><span class="p">,</span> <span class="n">lastcur</span><span class="p">,</span> <span class="n">eaten</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">eaten</span> <span class="o">&gt;</span> <span class="n">K</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">INF</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">N</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># Eat this character:</span>
</span></span><span class="line"><span class="cl">            <span class="n">ans</span> <span class="o">=</span> <span class="n">dp</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">curlength</span><span class="p">,</span> <span class="n">lastcur</span><span class="p">,</span> <span class="n">eaten</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="c1"># Or add:</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">lastcur</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">delta</span> <span class="o">=</span> <span class="n">rle</span><span class="p">(</span><span class="n">curlength</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">rle</span><span class="p">(</span><span class="n">curlength</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="n">cand</span> <span class="o">=</span> <span class="n">dp</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">curlength</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">lastcur</span><span class="p">,</span> <span class="n">eaten</span><span class="p">)</span> <span class="o">+</span> <span class="n">delta</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="n">cand</span> <span class="o">&lt;</span> <span class="n">ans</span><span class="p">:</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">cand</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">cand</span> <span class="o">=</span> <span class="n">dp</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">eaten</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="n">cand</span> <span class="o">&lt;</span> <span class="n">ans</span><span class="p">:</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">cand</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">ans</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">dp</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span></code></pre></div>
    </div>
    
    <link href="https://cdn.bootcss.com/KaTeX/0.10.2/katex.min.css" rel="stylesheet">
    <script src="https://cdn.bootcss.com/KaTeX/0.10.2/katex.min.js"></script>
    <script src="https://cdn.bootcss.com/KaTeX/0.10.2/contrib/auto-render.min.js"></script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
          renderMathInElement(document.body, {
                  delimiters: [
                      {left: "$$", right: "$$", display: true},
                      {left: "$", right: "$", display: false}
                  ]
              });
        });
    </script>
  </div>

    <div class="footer">
  <div class="footer-social">
    <h1></h1>
    <p>Copyright © 2022 All Rights Reserved. Built by Zee with ❤.</p>
  </div>
</div>
  </div>

  

  

  
  <script type="text/javascript" src="/js/bundle.min.5993fcb11c07dea925a3fbd58c03c7f1857197c35fccce3aa963a12c0b3c9960.js"></script>
  

  
  

</body>
</html>