<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Docker Cheatsheet - Zee Tsui</title>
  <title>ZC 个人内容记录</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" href="/favicon.ico">
  <link rel="canonical" href="/posts/2019/20191112-docker-cheatsheet/" />

  
  
  <link rel="stylesheet" href="/css/style.min.c813c458db6847576b9bd786addc081f1f218bc0b99cdfe79f2daf35df2e453a.css">
  

  
    
    <meta property="og:title" content="Docker Cheatsheet"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="/posts/2019/20191112-docker-cheatsheet/"/>
    
    
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:site" content="@zerostaticio"/>
    <meta name="twitter:creator" content="@zerostaticio"/>
  

  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&display=swap" rel="stylesheet"> 
</head>




<body class='page frame page-blog-single'>
  <div id="menu-main-mobile" class="menu-main-mobile">
    <ul class="menu">
        
        
            
                <li class="menu-item-home">
                    <a href="/">Home</a>
                </li>
            
        
            
                <li class="menu-item-blog">
                    <a href="/posts/">Blog</a>
                </li>
            
        
            
                <li class="menu-item-categories">
                    <a href="/categories/">Categories</a>
                </li>
            
        
            
            <li class="menu-item-gallery">
                <a href="/gallery">Gallery</a>
            </li>
            
        
            
                <li class="menu-item-log">
                    <a href="/log/">Log</a>
                </li>
            
        
            
                <li class="menu-item-about">
                    <a href="/pages/about/">About</a>
                </li>
            
        
    </ul>
</div>
  <div id="wrapper" class="wrapper">
    <div class='header'>
  
  <a></a>
  <div class="menu-main">
    <ul>
      
      
      
      <li class="menu-item-home">
        <a href="/">
          
          <span>Home</span>
        </a>
      </li>
      
      
      
      <li class="menu-item-blog">
        <a href="/posts/">
          
          <span>Blog</span>
        </a>
      </li>
      
      
      
      <li class="menu-item-categories">
        <a href="/categories/">
          
          <span>Categories</span>
        </a>
      </li>
      
      
      
      <li class="menu-item-gallery">
        <a href="/gallery">
          
          <span>Gallery</span>
        </a>
      </li>
      
      
      
      <li class="menu-item-log">
        <a href="/log/">
          
          <span>Log</span>
        </a>
      </li>
      
      
      
      <li class="menu-item-about">
        <a href="/pages/about/">
          
          <span>About</span>
        </a>
      </li>
      
      
    </ul>
  </div>
  <div id="toggle-menu-main-mobile" class="hamburger-trigger">
    <button class="hamburger">Menu</button>
  </div>
</div>
    
  <div class="blog">
    <div class="intro-article">
      <h1>Docker Cheatsheet<span class="dot">.</span></h1>
      
    </div>
    <div class="content">
      <p>该版本的 Cheatsheet 由其他版本精简而来，旨在提供一个日常使用 Docker 时的速查手册。</p>
<!-- more -->
<h2 id="目录">目录</h2>
<ul>
<li><a href="#%E6%A3%80%E6%9F%A5%E7%89%88%E6%9C%AC">检查版本</a></li>
<li><a href="#%E5%AE%89%E8%A3%85">安装</a></li>
<li><a href="#%E5%AE%B9%E5%99%A8container">容器(Containers)</a></li>
<li><a href="#%E9%95%9C%E5%83%8Fimages">镜像(Images)</a></li>
<li><a href="#%E7%BD%91%E7%BB%9Cnetworks">网络(Networks)</a></li>
<li><a href="#%E4%BB%93%E7%AE%A1%E4%B8%AD%E5%BF%83%E5%92%8C%E4%BB%93%E5%BA%93registry--repository">仓管中心和仓库(Registry &amp; Repository)</a></li>
<li><a href="#dockerfile">Dockerfile</a></li>
<li><a href="#%E5%B1%82layers">层(Layers)</a></li>
<li><a href="#%E9%93%BE%E6%8E%A5links">链接(Links)</a></li>
<li><a href="#%E5%8D%B7%E6%A0%87volumes">卷标(Volumes)</a></li>
<li><a href="#%E6%9A%B4%E9%9C%B2%E7%AB%AF%E5%8F%A3exposing-ports">暴露端口(Exposing Ports)</a></li>
<li><a href="#%E5%AE%89%E5%85%A8security">安全</a></li>
<li><a href="#%E5%B0%8F%E8%B4%B4%E5%A3%AB">小贴士</a></li>
</ul>
<h2 id="检查版本">检查版本</h2>
<p>时刻关注你当前正在使用的 Docker 版本是十分重要的，这能够帮助你了解可用的特性。同时，可以让你在查找镜像时选择使用的版本。接下来让我们看看如何操作。</p>
<ul>
<li><a href="https://docs.docker.com/engine/reference/commandline/version/"><code>docker version</code></a> 查看你正在运行的 Docker 版本。</li>
</ul>
<p>获取 Docker 服务版本：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker version --format &#39;{{.Server.Version}}&#39;
</span></span></code></pre></div><p>你也可以输出原始的 JSON 数据：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker version --format &#39;{{json .}}&#39;
</span></span></code></pre></div><h2 id="安装">安装</h2>
<h3 id="linux">Linux</h3>
<p>Docker 官方提供了快速、易用的安装脚本：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">curl -sSL https://get.docker.com/ | sh
</span></span></code></pre></div><p>如果你不想执行一个不明不白的 Shell 脚本，那么请看 <a href="https://docs.docker.com/engine/installation/linux/">安装说明</a>，选择你在用的发行版本。</p>
<p>如果你是一个 Docker 超新手，那么你应当先去看看 <a href="https://docs.docker.com/engine/getstarted/">系列教程</a>。</p>
<h2 id="容器-container">容器 (Container)</h2>
<h3 id="生命周期">生命周期</h3>
<ul>
<li><a href="https://docs.docker.com/engine/reference/commandline/create"><code>docker create</code></a> 创建容器但不启动它。</li>
<li><a href="https://docs.docker.com/engine/reference/commandline/rename/"><code>docker rename</code></a> 用于重命名容器。</li>
<li><a href="https://docs.docker.com/engine/reference/commandline/run"><code>docker run</code></a> 一键创建并同时启动该容器。</li>
<li><a href="https://docs.docker.com/engine/reference/commandline/rm"><code>docker rm</code></a> 删除容器。</li>
<li><a href="https://docs.docker.com/engine/reference/commandline/update/"><code>docker update</code></a> 调整容器的资源限制。</li>
</ul>
<p>通常情况下，不使用任何命令行选项启动一个容器，该容器将会立即启动并停止。若需保持其运行，你可以使用 <code>docker run -td container_id</code> 命令。选项 <code>-t</code> 表示分配一个 pseudo-TTY 会话，<code>-d</code> 表示自动将容器与终端分离（也就是说在后台运行容器，并输出容器 ID）。</p>
<p>如果你需要一个临时容器，可使用 <code>docker run --rm</code> 会在容器停止之后删除它。</p>
<p>如果你需要映射宿主机 (host) 的目录到 Docker 容器内，可使用 <code>docker run -v $HOSTDIR:$DOCKERDIR</code>。详见 <a href="#%E5%8D%B7%E6%A0%87volumes">卷标(Volumes)</a> 一节。</p>
<p>如果你想同时删除与容器相关联的卷标，那么在删除容器的时候必须包含 <code>-v</code> 选项，像这样 <code>docker rm -v</code>。</p>
<p>从 Docker 1.10 起，其内置一套各容器独立的 <a href="https://docs.docker.com/engine/admin/logging/overview/">日志引擎</a>，每个容器可以独立使用。你可以使用 <code>docker run --log-driver=syslog</code> 来自定义日志引擎（例如以上的 <code>syslog</code>）。</p>
<h3 id="启动和停止">启动和停止</h3>
<ul>
<li><a href="https://docs.docker.com/engine/reference/commandline/start"><code>docker start</code></a> 启动已存在的容器。</li>
<li><a href="https://docs.docker.com/engine/reference/commandline/stop"><code>docker stop</code></a> 停止运行中的容器。</li>
<li><a href="https://docs.docker.com/engine/reference/commandline/restart"><code>docker restart</code></a> 重启容器。</li>
<li><a href="https://docs.docker.com/engine/reference/commandline/pause/"><code>docker pause</code></a> 暂停运行中的容器，将其「冻结」在当前状态。</li>
<li><a href="https://docs.docker.com/engine/reference/commandline/unpause/"><code>docker unpause</code></a> 结束容器暂停状态。</li>
<li><a href="https://docs.docker.com/engine/reference/commandline/wait"><code>docker wait</code></a> 阻塞地等待某个运行中的容器直到停止。</li>
<li><a href="https://docs.docker.com/engine/reference/commandline/kill"><code>docker kill</code></a> 向运行中的容器发送 SIGKILL 指令。</li>
<li><a href="https://docs.docker.com/engine/reference/commandline/attach"><code>docker attach</code></a> 连接到运行中的容器。</li>
</ul>
<p>如果你想将容器的端口 (ports) 暴露至宿主机，请见 <a href="#%E6%9A%B4%E9%9C%B2%E7%AB%AF%E5%8F%A3exposing-ports">暴露端口</a> 一节。</p>
<p>关于 Docker 实例崩溃后的重启策略，详见 <a href="http://container42.com/2014/09/30/docker-restart-policies/">本文</a>。</p>
<h4 id="cpu-限制">CPU 限制</h4>
<p>你可以限制 CPU 资源占用，无论是指定百分比，或是特定核心数。</p>
<p>设置 <a href="https://docs.docker.com/engine/reference/run/#/cpu-share-constraint"><code>cpu-shares</code></a></p>
<p>&ndash; 1024 表示 100% CPU，512 为 50% CPU：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker run -ti --c 512 agileek/cpuset-test
</span></span></code></pre></div><p>设置 <a href="https://docs.docker.com/engine/reference/run/#/cpuset-constraint"><code>cpuset-cpus</code></a> ，使用特定 CPU 内核</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker run -ti --cpuset-cpus=0,4,6 agileek/cpuset-test
</span></span></code></pre></div><p>注意，Docker 在容器内仍然能够 <strong>看到</strong> 全部 CPU &ndash; 它仅仅是不使用全部而已。</p>
<h4 id="内存限制">内存限制</h4>
<p>设置 <a href="https://docs.docker.com/engine/reference/run/#/user-memory-constraints">内存限制</a>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker run -it -m 300M ubuntu:14.04 /bin/bash
</span></span></code></pre></div><h4 id="能力-capabilities">能力 (Capabilities)</h4>
<p>Linux 的 Capability 可以通过使用 <code>cap-add</code> 和 <code>cap-drop</code> 设置，这有助于提高安全性。</p>
<p>如需要挂载基于 FUSE 的文件系统，你需要结合 <code>--cap-add</code> 和 <code>--device</code> 使用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker run --rm -it --cap-add SYS_ADMIN --device /dev/fuse sshfs
</span></span></code></pre></div><p>授予对某个设备的访问权限：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker run -it --device=/dev/ttyUSB0 debian bash
</span></span></code></pre></div><p>授予对所有设备的访问权限：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker run -it --privileged -v /dev/bus/usb:/dev/bus/usb debian bash
</span></span></code></pre></div><h3 id="信息">信息</h3>
<ul>
<li><a href="https://docs.docker.com/engine/reference/commandline/ps"><code>docker ps</code></a> 查看运行中的所有容器。</li>
<li><a href="https://docs.docker.com/engine/reference/commandline/logs"><code>docker logs</code></a> 从容器中读取日志。</li>
<li><a href="https://docs.docker.com/engine/reference/commandline/inspect"><code>docker inspect</code></a> 查看某个容器的所有信息（包括 IP 地址）。</li>
<li><a href="https://docs.docker.com/engine/reference/commandline/events"><code>docker events</code></a> 从容器中获取事件（events）。</li>
<li><a href="https://docs.docker.com/engine/reference/commandline/port"><code>docker port</code></a> 查看容器的公开端口。</li>
<li><a href="https://docs.docker.com/engine/reference/commandline/top"><code>docker top</code></a> 查看容器中活动进程。</li>
<li><a href="https://docs.docker.com/engine/reference/commandline/stats"><code>docker stats</code></a> 查看容器的资源使用量统计信息。</li>
<li><a href="https://docs.docker.com/engine/reference/commandline/diff"><code>docker diff</code></a> 查看容器文件系统中存在改动的文件。</li>
</ul>
<p><code>docker ps -a</code> 将显示所有容器，包括运行中和已停止的。</p>
<p><code>docker stats --all</code> 同样将显示所有容器，默认仅显示运行中的容器。</p>
<h3 id="导入--导出">导入 / 导出</h3>
<ul>
<li><a href="https://docs.docker.com/engine/reference/commandline/cp"><code>docker cp</code></a> 在容器和本地文件系统之间复制文件或目录。</li>
<li><a href="https://docs.docker.com/engine/reference/commandline/export"><code>docker export</code></a> 将容器的文件系统打包为归档文件流 (tarball archive stream) 并输出至标准输出 (STDOUT)。</li>
</ul>
<h3 id="执行命令">执行命令</h3>
<ul>
<li><a href="https://docs.docker.com/engine/reference/commandline/exec"><code>docker exec</code></a> 在容器内执行命令。</li>
</ul>
<p>例如，进入正在运行的 <code>foo</code> 容器，并连接 (attach) 到一个新的 Shell 进程：<code>docker exec -it foo /bin/bash</code>。</p>
<h2 id="镜像-images">镜像 (Images)</h2>
<h3 id="生命周期-1">生命周期</h3>
<ul>
<li><a href="https://docs.docker.com/engine/reference/commandline/images"><code>docker images</code></a> 查看所有镜像。</li>
<li><a href="https://docs.docker.com/engine/reference/commandline/import"><code>docker import</code></a> 从归档文件创建镜像。</li>
<li><a href="https://docs.docker.com/engine/reference/commandline/build"><code>docker build</code></a> 从 Dockerfile 创建镜像。</li>
<li><a href="https://docs.docker.com/engine/reference/commandline/commit"><code>docker commit</code></a> 为容器创建镜像，如果容器正在运行则会临时暂停。</li>
<li><a href="https://docs.docker.com/engine/reference/commandline/rmi"><code>docker rmi</code></a> 删除镜像。</li>
<li><a href="https://docs.docker.com/engine/reference/commandline/load"><code>docker load</code></a> 从标准输入 (STDIN) 加载归档包 (tar archive) 作为镜像，包括镜像本身和标签 (tags, 0.7 起)。</li>
<li><a href="https://docs.docker.com/engine/reference/commandline/save"><code>docker save</code></a> 将镜像打包为归档包，并输出至标准输出 (STDOUT)，包括所有的父层、标签和版本 (parent layers, tags, versions, 0.7 起)。</li>
</ul>
<h3 id="其它信息">其它信息</h3>
<ul>
<li><a href="https://docs.docker.com/engine/reference/commandline/history"><code>docker history</code></a> 查看镜像的历史记录。</li>
<li><a href="https://docs.docker.com/engine/reference/commandline/tag"><code>docker tag</code></a> 给镜像打标签命名（本地或者仓库均可）。</li>
</ul>
<h3 id="清理">清理</h3>
<p>虽然你可以用 <code>docker rmi</code> 命令来删除指定的镜像，不过有个名为 <a href="https://github.com/spotify/docker-gc">docker-gc</a> 的工具，它可以以一种安全的方式，清理掉那些不再被任何容器使用的镜像。Docker 1.13 起，使用 <code>docker image prune</code> 亦可删除未使用的镜像。</p>
<h3 id="加载--保存镜像">加载 / 保存镜像</h3>
<p>从文件中加载镜像：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker load &lt; my_image.tar.gz
</span></span></code></pre></div><p>保存既有镜像：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker save my_image:my_tag | gzip &gt; my_image.tar.gz
</span></span></code></pre></div><h3 id="导入--导出容器">导入 / 导出容器</h3>
<p>从文件中导入容器镜像：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">cat my_container.tar.gz | docker import - my_image:my_tag
</span></span></code></pre></div><p>导出既有容器：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker export my_container | gzip &gt; my_container.tar.gz
</span></span></code></pre></div><h3 id="加载已保存的镜像-与-导入已导出为镜像的容器-的不同">加载已保存的镜像 与 导入已导出为镜像的容器 的不同</h3>
<p>通过 <code>load</code> 命令来加载镜像，会创建一个新的镜像，并继承原镜像的所有历史。
通过 <code>import</code> 将容器作为镜像导入，也会创建一个新的镜像，但并不包含原镜像的历史，因此会比使用 <code>load</code> 方式生成的镜像更小。</p>
<h2 id="网络-networks">网络 (Networks)</h2>
<p>Docker 具备 <a href="https://docs.docker.com/engine/userguide/networking/">网络</a> 功能。我并不是很了解它，所以这是一个扩展本文的好地方。这是一种无需暴露端口即可实现 Docker 容器间通信的好方法。</p>
<h3 id="生命周期-2">生命周期</h3>
<ul>
<li><a href="https://docs.docker.com/engine/reference/commandline/network_create/"><code>docker network create</code></a></li>
<li><a href="https://docs.docker.com/engine/reference/commandline/network_rm/"><code>docker network rm</code></a></li>
</ul>
<h3 id="其它信息-1">其它信息</h3>
<ul>
<li><a href="https://docs.docker.com/engine/reference/commandline/network_ls/"><code>docker network ls</code></a></li>
<li><a href="https://docs.docker.com/engine/reference/commandline/network_inspect/"><code>docker network inspect</code></a></li>
</ul>
<h3 id="建立连接">建立连接</h3>
<ul>
<li><a href="https://docs.docker.com/engine/reference/commandline/network_connect/"><code>docker network connect</code></a></li>
<li><a href="https://docs.docker.com/engine/reference/commandline/network_disconnect/"><code>docker network disconnect</code></a></li>
</ul>
<p>你可以 <a href="https://blog.jessfraz.com/post/ips-for-all-the-things/">为容器指定 IP 地址</a>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># 使用你自己的子网和网关创建一个桥接网络
</span></span><span class="line"><span class="cl">docker network create --subnet 203.0.113.0/24 --gateway 203.0.113.254 iptastic
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 基于以上创建的网络，运行一个 Nginx 容器并指定 IP
</span></span><span class="line"><span class="cl">$ docker run --rm -it --net iptastic --ip 203.0.113.2 nginx
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 在其他地方使用 CURL 访问这个 IP（假设该 IP 为公网）
</span></span><span class="line"><span class="cl">$ curl 203.0.113.2
</span></span></code></pre></div><h2 id="仓管中心和仓库-registry--repository">仓管中心和仓库 (Registry &amp; Repository)</h2>
<p>仓库 (repository) 是 <em>被托管 (hosted)</em> 的已命名镜像 (tagged images) 的集合，这组镜像用于构建容器文件系统。</p>
<p>仓管中心 (registry) 则是 <em>托管服务 (host)</em> &ndash; 用于存储仓库并提供 HTTP API，以便 <a href="https://docs.docker.com/engine/tutorials/dockerrepos/">管理仓库的上传和下载</a>。</p>
<p>Docker 官方托管着自己的 <a href="https://hub.docker.com/">仓管中心</a>，包含着数量众多的仓库。不过话虽如此，这个仓管中心 <a href="https://titanous.com/posts/docker-insecurity">并没有很好地验证镜像</a>，所以如果你担心安全问题的话，请尽量避免使用它。</p>
<ul>
<li><a href="https://docs.docker.com/engine/reference/commandline/login"><code>docker login</code></a> 登入仓管中心。</li>
<li><a href="https://docs.docker.com/engine/reference/commandline/logout"><code>docker logout</code></a> 登出仓管中心。</li>
<li><a href="https://docs.docker.com/engine/reference/commandline/search"><code>docker search</code></a> 从仓管中心检索镜像。</li>
<li><a href="https://docs.docker.com/engine/reference/commandline/pull"><code>docker pull</code></a> 从仓管中心拉取镜像到本地。</li>
<li><a href="https://docs.docker.com/engine/reference/commandline/push"><code>docker push</code></a> 从本地推送镜像到仓管中心。</li>
</ul>
<h3 id="本地仓管中心">本地仓管中心</h3>
<p>使用 <a href="https://github.com/docker/distribution">docker distribution</a> 项目搭建本地的仓管中心。</p>
<p>科学上网后，也可以看看 <a href="https://groups.google.com/a/dockerproject.org/forum/#!forum/distribution">Google+ Group</a>。</p>
<h2 id="dockerfile">Dockerfile</h2>
<p>当你执行 <code>docker build</code> 时，Docker 将会根据 <a href="https://docs.docker.com/engine/reference/builder/">配置文件</a> 启动 Docker 容器。远优于使用 <code>docker commit</code>。</p>
<h3 id="指令">指令</h3>
<ul>
<li><a href="https://docs.docker.com/engine/reference/builder/#dockerignore-file">.dockerignore</a></li>
<li><a href="https://docs.docker.com/engine/reference/builder/#from">FROM</a> 为其他指令设置基础镜像 (Base Image)。</li>
<li><a href="https://docs.docker.com/engine/reference/builder/#maintainer-deprecated">MAINTAINER (deprecated - use LABEL instead)</a> 为生成的镜像设置作者字段。</li>
<li><a href="https://docs.docker.com/engine/reference/builder/#run">RUN</a> 在当前镜像的基础上生成一个新层并执行命令。</li>
<li><a href="https://docs.docker.com/engine/reference/builder/#cmd">CMD</a> 设置容器默认执行命令。</li>
<li><a href="https://docs.docker.com/engine/reference/builder/#expose">EXPOSE</a> 告知 Docker 容器在运行时所要监听的网络端口。注意：并没有实际上将端口设置为可访问。</li>
<li><a href="https://docs.docker.com/engine/reference/builder/#env">ENV</a> 设置环境变量。</li>
<li><a href="https://docs.docker.com/engine/reference/builder/#add">ADD</a> 将文件、目录或远程文件复制到容器中。缓存无效。请尽量用 <code>COPY</code> 代替 <code>ADD</code>。</li>
<li><a href="https://docs.docker.com/engine/reference/builder/#copy">COPY</a> 将文件或文件夹复制到容器中。注意：将使用 ROOT 用户复制文件，故无论 USER / WORKDIR 指令如何配置，你都需要手动修改其所有者（<code>chown</code>），<code>ADD</code> 也是一样。</li>
<li><a href="https://docs.docker.com/engine/reference/builder/#entrypoint">ENTRYPOINT</a> 将容器设为可执行的。</li>
<li><a href="https://docs.docker.com/engine/reference/builder/#volume">VOLUME</a> 在容器内部创建挂载点 (mount point) 指向外部挂载的卷标或其他容器。</li>
<li><a href="https://docs.docker.com/engine/reference/builder/#user">USER</a> 设置随后执行 RUN / CMD / ENTRYPOINT 命令的用户名。</li>
<li><a href="https://docs.docker.com/engine/reference/builder/#workdir">WORKDIR</a> 设置工作目录 (working directory)。</li>
<li><a href="https://docs.docker.com/engine/reference/builder/#arg">ARG</a> 定义编译时 (build-time) 变量。</li>
<li><a href="https://docs.docker.com/engine/reference/builder/#onbuild">ONBUILD</a> 添加触发指令，当该镜像被作为其他镜像的基础镜像时该指令会被触发。</li>
<li><a href="https://docs.docker.com/engine/reference/builder/#stopsignal">STOPSIGNAL</a> 设置停止容器时，向容器内发送的系统调用信号 (system call signal)。</li>
<li><a href="https://docs.docker.com/config/labels-custom-metadata/">LABEL</a> 将键值对元数据 (key/value metadata) 应用到镜像、容器或是守护进程。</li>
</ul>
<h2 id="层-layers">层 (Layers)</h2>
<p>Docker 的版本化文件系统是基于层的。就像 <a href="https://docs.docker.com/engine/userguide/storagedriver/imagesandcontainers/">Git 的提交或文件变更系统</a> 一样。</p>
<h2 id="链接-links">链接 (Links)</h2>
<p>链接 (links) <a href="https://docs.docker.com/userguide/dockerlinks/">通过 TCP/IP 端口</a> 实现 Docker 容器之间的通讯。<a href="https://blogs.atlassian.com/2013/11/docker-all-the-things-at-atlassian-automation-and-wiring/">Atlassian</a> 展示了可用的例子。你还可以 <a href="https://docs.docker.com/engine/userguide/networking/default_network/dockerlinks/#/updating-the-etchosts-file">通过主机名 (hostname) 链接</a>。</p>
<p>在某种意义上来说，该特性已经被 <a href="https://docs.docker.com/network/">自定义网络</a> 所替代。</p>
<p>注意: 如果你希望容器之间<strong>只</strong>通过链接进行通讯，在启动 Docker 守护进程时，请使用 <code>-icc=false</code> 来禁用内部进程通讯。</p>
<p>假设你有一个名为 CONTAINER 的容器（通过 <code>docker run --name CONTAINER</code> 指定）并且在 Dockerfile 中，暴露了一个端口:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">EXPOSE 1337
</span></span></code></pre></div><p>然后，我们创建另外一个名为 LINKED 的容器:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker run -d --link CONTAINER:ALIAS --name LINKED user/wordpress
</span></span></code></pre></div><p>然后 CONTAINER 暴露的端口和别名将会以如下的环境变量出现在 LINKED 中:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ALIAS_PORT_1337_TCP_PORT
</span></span><span class="line"><span class="cl">$ALIAS_PORT_1337_TCP_ADDR
</span></span></code></pre></div><p>那么你便可以通过这种方式来连接它了。</p>
<p>使用 <code>docker rm --link</code> 即可删除链接。</p>
<p>通常，Docker 容器（亦可理解为「服务」）之间的链接，是「服务发现」的一个子集。如果你打算在生产中大规模使用 Docker，这将是一个很大的问题。请参阅<a href="https://www.digitalocean.com/community/tutorials/the-docker-ecosystem-service-discovery-and-distributed-configuration-stores">The Docker Ecosystem: Service Discovery and Distributed Configuration Stores</a> 获取更多信息。</p>
<h2 id="卷标volumes">卷标(Volumes)</h2>
<p>Docker 的卷标 (volumes) 是 <a href="https://docs.docker.com/engine/tutorials/dockervolumes/">独立的文件系统</a>。它们并非必须连接到特定的容器上。</p>
<h3 id="生命周期-3">生命周期</h3>
<ul>
<li><a href="https://docs.docker.com/engine/reference/commandline/volume_create/"><code>docker volume create</code></a></li>
<li><a href="https://docs.docker.com/engine/reference/commandline/volume_rm/"><code>docker volume rm</code></a></li>
</ul>
<h3 id="信息-1">信息</h3>
<ul>
<li><a href="https://docs.docker.com/engine/reference/commandline/volume_ls/"><code>docker volume ls</code></a></li>
<li><a href="https://docs.docker.com/engine/reference/commandline/volume_inspect/"><code>docker volume inspect</code></a></li>
</ul>
<p>卷标在不能使用链接（只有 TCP/IP）的情况下非常有用。例如，如果你有两个 Docker 实例需要通讯并在文件系统上留下记录。</p>
<p>你可以一次性将其挂载到多个 docker 容器上，通过 <code>docker run --volumes-from</code>。</p>
<p>因为卷标是独立的文件系统，它们通常被用于存储各容器之间的瞬时状态。也就是说，你可以配置一个无状态临时容器，关掉之后，当你有第二个这种临时容器实例的时候，你可以从上一次保存的状态继续执行。</p>
<p>查看 <a href="http://crosbymichael.com/advanced-docker-volumes.html">卷标进阶</a> 来获取更多细节。<a href="http://container42.com/2014/11/03/docker-indepth-volumes/">Container42</a> 非常有用。</p>
<p>你可以 <a href="https://docs.docker.com/engine/tutorials/dockervolumes/#mount-a-host-directory-as-a-data-volume">将宿主 MacOS 的文件夹映射为 Docker 卷标</a>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker run -v /Users/wsargent/myapp/src:/src
</span></span></code></pre></div><p>你也可以用远程 NFS 卷标，如果你觉得你 <a href="https://docs.docker.com/engine/tutorials/dockervolumes/#/mount-a-shared-storage-volume-as-a-data-volume">有足够勇气</a>。</p>
<p>还可以考虑运行一个纯数据容器，像 <a href="http://container42.com/2013/12/16/persistent-volumes-with-docker-container-as-volume-pattern/">这里</a> 所说的那样，提供可移植数据。</p>
<p>记得，<a href="#%E5%B0%86%E6%96%87%E4%BB%B6%E6%8C%82%E8%BD%BD%E4%B8%BA%E5%8D%B7%E6%A0%87">文件也可以被挂载为卷标</a>。</p>
<h2 id="暴露端口-exposing-ports">暴露端口 (Exposing ports)</h2>
<p>通过宿主容器暴露输入端口相当 <a href="https://docs.docker.com/engine/reference/run/#expose-incoming-ports">繁琐但有效的</a>。</p>
<p>例如使用 <code>-p</code> 将容器端口映射到宿主端口上（只使用本地主机 (localhost) 接口）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker run -p 127.0.0.1:$HOSTPORT:$CONTAINERPORT --name CONTAINER -t someimage
</span></span></code></pre></div><p>你可以使用 <a href="https://docs.docker.com/engine/reference/builder/#expose">EXPOSE</a> 告知 Docker，该容器在运行时监听指定的端口：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">EXPOSE &lt;CONTAINERPORT&gt;
</span></span></code></pre></div><p>但是注意 EXPOSE 并不会直接暴露端口，你需要用参数 <code>-p</code> 。比如说你要在 localhost 上暴露容器的端口:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">iptables -t nat -A DOCKER -p tcp --dport &lt;LOCALHOSTPORT&gt; -j DNAT --to-destination &lt;CONTAINERIP&gt;:&lt;PORT&gt;
</span></span></code></pre></div><p>如果你是在 Virtualbox 中运行 Docker，那么你需要配置端口转发 (forward the port)。使用 <a href="https://docs.vagrantup.com/v2/networking/forwarded_ports.html">forwarded_port</a> 在 Vagrantfile 上配置暴露的端口范围，这样你就可以动态地映射了：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|
</span></span><span class="line"><span class="cl">  ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  (49000..49900).each do |port|
</span></span><span class="line"><span class="cl">    config.vm.network :forwarded_port, :host =&gt; port, :guest =&gt; port
</span></span><span class="line"><span class="cl">  end
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  ...
</span></span><span class="line"><span class="cl">end
</span></span></code></pre></div><p>如果你忘记了将什么端口映射到宿主机上的话，可使用 <code>docker port</code> 查看：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker port CONTAINER $CONTAINERPORT
</span></span></code></pre></div><h2 id="安全security">安全(Security)</h2>
<p>这节准备讨论一些关于 Docker 安全性的问题。Docker 官方文档 <a href="https://docs.docker.com/articles/security/">安全</a> 页面讲述了更多细节。</p>
<p>首先第一件事：Docker 是有 root 权限的。如果你在 <code>docker</code> 组，那么你就有 <a href="https://web.archive.org/web/20161226211755/http://reventlov.com/advisories/using-the-docker-command-to-root-the-host">root 权限</a>。如果你将 Docker 的 Unix Socket 暴露给容器，意味着你赋予了容器 <a href="https://www.lvh.io/posts/dont-expose-the-docker-socket-not-even-to-a-container.html">宿主机 root 权限</a>。</p>
<p>Docker 不应当作为唯一的防御措施。你应当使其更加安全可靠。</p>
<p>为了更好地理解容器暴露了什么，可参阅由 <a href="https://twitter.com/dyn___">Aaron Grattafiori</a> 编写的 <a href="https://www.nccgroup.trust/globalassets/our-research/us/whitepapers/2016/april/ncc_group_understanding_hardening_linux_containers-1-1.pdf">Understanding and Hardening Linux Containers</a>。这是一个完整全面且包含大量链接和脚注的容器问题指南，介绍了许多有用的内容。即使你已经加固过容器，以下的安全提示依然十分有帮助，但并不能代替理解的过程。</p>
<h3 id="安全提示">安全提示</h3>
<p>为了最大的安全性，你应当考虑在虚拟机上运行 Docker。这是直接从 Docker 安全团队拿来的资料 &ndash; <a href="http://www.slideshare.net/jpetazzo/linux-containers-lxc-docker-and-security">slides</a> / <a href="http://www.projectatomic.io/blog/2014/08/is-it-safe-a-look-at-docker-and-security-from-linuxcon/">notes</a>。之后，可使用 AppArmor、seccomp、SELinux、grsec 等来 <a href="http://linux-audit.com/docker-security-best-practices-for-your-vessel-and-containers/">限制容器的权限</a>。更多细节，请查阅 <a href="https://blog.docker.com/2016/02/docker-engine-1-10-security/">Docker 1.10 security features</a>。</p>
<p>Docker 镜像 ID 属于 <a href="https://medium.com/@quayio/your-docker-image-ids-are-secrets-and-its-time-you-treated-them-that-way-f55e9f14c1a4">敏感信息</a> 所以它不应该向外界公开。请将它们当作密码来对待。</p>
<p>阅读由 <a href="https://github.com/konstruktoid">Thomas Sjögren</a> 编写的 <a href="https://github.com/konstruktoid/Docker/blob/master/Security/CheatSheet.adoc">Docker Security Cheat Sheet</a>：关于加固容器的不错的建议。</p>
<p>查看 <a href="https://github.com/docker/docker-bench-security">Docker 安全测试脚本</a>，下载 <a href="https://blog.docker.com/2015/05/understanding-docker-security-and-best-practices/">最佳实践白皮书</a>。</p>
<p>你应当远离使用非稳定版本 grsecurity / pax 的内核，比如 <a href="https://en.wikipedia.org/wiki/Alpine_Linux">Alpine Linux</a>。如果在产品中用了 grsecurity，那么你应该考虑使用有 <a href="https://grsecurity.net/business_support.php">商业支持</a> 的 <a href="https://grsecurity.net/announce.php">稳定版本</a>，就像你对待 RedHat 那样。虽然要 $200 每月，但对于你的运维预算来说不值一提。</p>
<p>从 Docker 1.11 开始，你可以轻松的限制在容器中可用的进程数，以防止 fork 炸弹。 这要求 Linux 内核 &gt;= 4.3，并且要在内核配置中打开 CGROUP_PIDS=y。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker run --pids-limit=64
</span></span></code></pre></div><p>同时，你也可以限制进程再获取新权限。该功能是 Linux 内核从 3.5 版本开始就拥有的。你可以从 <a href="http://www.projectatomic.io/blog/2016/03/no-new-privs-docker/">这篇博客</a> 中阅读到更多关于这方面的内容。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker run --security-opt=no-new-privileges
</span></span></code></pre></div><p>关闭内部进程通讯：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker -d --icc=false --iptables
</span></span></code></pre></div><p>设置容器为只读：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker run --read-only
</span></span></code></pre></div><p>通过 hashsum 来验证卷标：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker pull debian@sha256:a25306f3850e1bd44541976aa7b5fd0a29be
</span></span></code></pre></div><p>设置卷标为只读：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker run -v $(pwd)/secrets:/secrets:ro debian
</span></span></code></pre></div><p>在 Dockerfile 中定义用户并以该用户运行，避免在容器中以 ROOT 身份操作：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">RUN groupadd -r user &amp;&amp; useradd -r -g user user
</span></span><span class="line"><span class="cl">USER user
</span></span></code></pre></div><h3 id="用户命名空间user-namespaces">用户命名空间(User Namespaces)</h3>
<p>还可以通过使用 <a href="https://s3hh.wordpress.com/2013/07/19/creating-and-using-containers-without-privilege/">用户命名空间</a> &ndash; 自 1.10 版本起已内置，但默认并未启用。</p>
<p>要在 Ubuntu 15.10 中启用用户命名空间 (remap the userns)，请 <a href="https://raesene.github.io/blog/2016/02/04/Docker-User-Namespaces/">跟着这篇博客的例子</a> 来做。</p>
<h2 id="小贴士">小贴士</h2>
<h3 id="清理-1">清理</h3>
<p>最新的 <a href="https://github.com/docker/docker/pull/26108">数据管理命令</a> 已在 Docker 1.13 实现：</p>
<ul>
<li><code>docker system prune</code></li>
<li><code>docker volume prune</code></li>
<li><code>docker network prune</code></li>
<li><code>docker container prune</code></li>
<li><code>docker image prune</code></li>
</ul>
<h3 id="df-命令">df 命令</h3>
<p><code>docker system df</code> 将显示当前 Docker 各部分占用的磁盘空间。</p>
<h3 id="heredoc-声明-docker-容器">Heredoc 声明 Docker 容器</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker build -t htop - &lt;&lt; EOF
</span></span><span class="line"><span class="cl">FROM alpine
</span></span><span class="line"><span class="cl">RUN apk --no-cache add htop
</span></span><span class="line"><span class="cl">EOF
</span></span></code></pre></div><h3 id="最近一次的容器-id">最近一次的容器 ID</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">alias dl=&#39;docker ps -l -q&#39;
</span></span><span class="line"><span class="cl">docker run ubuntu echo hello world
</span></span><span class="line"><span class="cl">docker commit $(dl) helloworld
</span></span></code></pre></div><h3 id="带命令的提交需要-dockerfile">带命令的提交（需要 Dockerfile）</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker commit -run=&#39;{&#34;Cmd&#34;:[&#34;postgres&#34;, &#34;-too -many -opts&#34;]}&#39; $(dl) postgres
</span></span></code></pre></div><h3 id="获取-ip-地址">获取 IP 地址</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker inspect $(dl) | grep -wm1 IPAddress | cut -d &#39;&#34;&#39; -f 4
</span></span></code></pre></div><p>或使用 <a href="https://stedolan.github.io/jq/">jq</a>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker inspect $(dl) | jq -r &#39;.[0].NetworkSettings.IPAddress&#39;
</span></span></code></pre></div><p>或使用 <a href="https://docs.docker.com/engine/reference/commandline/inspect">go 模板</a>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker inspect -f &#39;{{ .NetworkSettings.IPAddress }}&#39; &lt;container_name&gt;
</span></span></code></pre></div><p>或在通过 Dockerfile 构建镜像时，通过构建参数 (build argument) 传入：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">DOCKER_HOST_IP=`ifconfig | grep -E &#34;([0-9]{1,3}\.){3}[0-9]{1,3}&#34; | grep -v 127.0.0.1 | awk &#39;{ print $2 }&#39; | cut -f2 -d: | head -n1`
</span></span><span class="line"><span class="cl">echo DOCKER_HOST_IP = $DOCKER_HOST_IP
</span></span><span class="line"><span class="cl">docker build \
</span></span><span class="line"><span class="cl">  --build-arg ARTIFACTORY_ADDRESS=$DOCKER_HOST_IP 
</span></span><span class="line"><span class="cl">  -t sometag \
</span></span><span class="line"><span class="cl">  some-directory/
</span></span></code></pre></div><h3 id="获取端口映射">获取端口映射</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker inspect -f &#39;{{range $p, $conf := .NetworkSettings.Ports}} {{$p}} -&gt; {{(index $conf 0).HostPort}} {{end}}&#39; &lt;containername&gt;
</span></span></code></pre></div><h3 id="通过正则匹配容器">通过正则匹配容器</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">for i in $(docker ps -a | grep &#34;REGEXP_PATTERN&#34; | cut -f1 -d&#34; &#34;); do echo $i; done`
</span></span></code></pre></div><h3 id="获取环境变量配置">获取环境变量配置</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker run --rm ubuntu env
</span></span></code></pre></div><h3 id="强行终止运行中的容器">强行终止运行中的容器</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker kill $(docker ps -q)
</span></span></code></pre></div><h3 id="删除所有容器强行删除无论容器运行或停止">删除所有容器（强行删除！无论容器运行或停止）</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker rm -f $(docker ps -qa)
</span></span></code></pre></div><h3 id="删除旧容器">删除旧容器</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker ps -a | grep &#39;weeks ago&#39; | awk &#39;{print $1}&#39; | xargs docker rm
</span></span></code></pre></div><h3 id="删除已停止的容器">删除已停止的容器</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker rm -v `docker ps -a -q -f status=exited`
</span></span></code></pre></div><h3 id="停止并删除容器">停止并删除容器</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker stop $(docker ps -aq) &amp;&amp; docker rm -v $(docker ps -aq)
</span></span></code></pre></div><h3 id="删除无用-dangling-的镜像">删除无用 (dangling) 的镜像</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker rmi $(docker images -q -f dangling=true)
</span></span></code></pre></div><h3 id="删除所有镜像">删除所有镜像</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker rmi $(docker images -q)
</span></span></code></pre></div><h3 id="删除无用-dangling-的卷标">删除无用 (dangling) 的卷标</h3>
<p>Docker 1.9 版本起：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker volume rm $(docker volume ls -q -f dangling=true)
</span></span></code></pre></div><p>1.9.0 中，参数 <code>dangling=false</code> 居然 <em>没</em> 用 - 它会被忽略然后列出所有的卷标。</p>
<h3 id="查看镜像依赖">查看镜像依赖</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker images -viz | dot -Tpng -o docker.png
</span></span></code></pre></div><h3 id="docker-容器瘦身">Docker 容器瘦身</h3>
<ul>
<li>在某层 (RUN layer) 清理 APT</li>
</ul>
<p>这应当和其他 apt 命令在同一层中完成。
否则，前面的层将会保持原有信息，而你的镜像则依旧臃肿。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">RUN {apt commands} \
</span></span><span class="line"><span class="cl">  &amp;&amp; apt-get clean \  
</span></span><span class="line"><span class="cl">  &amp;&amp; rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*
</span></span></code></pre></div><ul>
<li>压缩镜像</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ID=$(docker run -d image-name /bin/bash)
</span></span><span class="line"><span class="cl">docker export $ID | docker import – flat-image-name
</span></span></code></pre></div><ul>
<li>备份</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ID=$(docker run -d image-name /bin/bash)
</span></span><span class="line"><span class="cl">(docker export $ID | gzip -c &gt; image.tgz)
</span></span><span class="line"><span class="cl">gzip -dc image.tgz | docker import - flat-image-name
</span></span></code></pre></div><h3 id="监视运行中容器的系统资源利用率">监视运行中容器的系统资源利用率</h3>
<p>检查某个容器的 CPU、内存以及网络 I/O 使用情况，你可以：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker stats &lt;container&gt;
</span></span></code></pre></div><p>按 ID 列出所有容器：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker stats $(docker ps -q)
</span></span></code></pre></div><p>按名称列出所有容器：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker stats $(docker ps --format &#39;{{.Names}}&#39;)
</span></span></code></pre></div><p>按指定镜像名称列出所有容器：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker ps -a -f ancestor=ubuntu
</span></span></code></pre></div><p>删除所有未标签命名 (untagged) 的容器：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker rmi $(docker images | grep “^” | awk &#39;{split($0,a,&#34; &#34;); print a[3]}&#39;)
</span></span></code></pre></div><p>通过正则匹配删除指定容器：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker ps -a | grep wildfly | awk &#39;{print $1}&#39; | xargs docker rm -f
</span></span></code></pre></div><p>删除所有已退出 (exited) 的容器：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker rm -f $(docker ps -a | grep Exit | awk &#39;{ print $1 }&#39;)
</span></span></code></pre></div><h3 id="将文件挂载为卷标">将文件挂载为卷标</h3>
<p>文件也可以被挂载为卷标。例如你可以仅仅注入单个配置文件：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># 从容器复制文件</span>
</span></span><span class="line"><span class="cl">docker run --rm httpd cat /usr/local/apache2/conf/httpd.conf &gt; httpd.conf
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 编辑文件</span>
</span></span><span class="line"><span class="cl">vim httpd.conf
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 挂载修改后的配置启动容器</span>
</span></span><span class="line"><span class="cl">docker run --rm -ti -v <span class="s2">&#34;</span><span class="nv">$PWD</span><span class="s2">/httpd.conf:/usr/local/apache2/conf/httpd.conf:ro&#34;</span> -p <span class="s2">&#34;80:80&#34;</span> httpd
</span></span></code></pre></div><p><img src="https://images.unsplash.com/photo-1566928224408-18392a67fbc7?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1867&amp;q=80" alt=""></p>

    </div>
    
    <link href="https://cdn.bootcss.com/KaTeX/0.10.2/katex.min.css" rel="stylesheet">
    <script src="https://cdn.bootcss.com/KaTeX/0.10.2/katex.min.js"></script>
    <script src="https://cdn.bootcss.com/KaTeX/0.10.2/contrib/auto-render.min.js"></script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
          renderMathInElement(document.body, {
                  delimiters: [
                      {left: "$$", right: "$$", display: true},
                      {left: "$", right: "$", display: false}
                  ]
              });
        });
    </script>
  </div>

    <div class="footer">
  <div class="footer-social">
    <h1></h1>
    <p>Copyright © 2022 All Rights Reserved. Built by Zee with ❤.</p>
  </div>
</div>
  </div>

  

  

  
  <script type="text/javascript" src="/js/bundle.min.5993fcb11c07dea925a3fbd58c03c7f1857197c35fccce3aa963a12c0b3c9960.js"></script>
  

  
  

</body>
</html>