<!DOCTYPE html>
<html lang="">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Zeesain Tsui">



    <meta name="description" content="大梦初醒啊。">



<title>Docker Cheatsheet | Zeesain Tsui</title>



    <link rel="icon" href="/image/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
            <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
    MathJax.Hub.Config({
        CommonHTML: {
          scale: 95
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<!-- <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script> -->


        
    


<meta name="generator" content="Hexo 5.3.0"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Zeesain Tsui</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/">首页</a>
                
                    <a class="menu-item" href="/archives">博客</a>
                
                    <a class="menu-item" href="/category">索引</a>
                
                    <a class="menu-item" href="/log">日志</a>
                
                    <a class="menu-item" href="/pic">图库</a>
                
                    <a class="menu-item" href="/about">关于</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>

        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Zeesain Tsui</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/">首页</a>
                
                    <a class="menu-item" href="/archives">博客</a>
                
                    <a class="menu-item" href="/category">索引</a>
                
                    <a class="menu-item" href="/log">日志</a>
                
                    <a class="menu-item" href="/pic">图库</a>
                
                    <a class="menu-item" href="/about">关于</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Docker Cheatsheet</h1>
            
                <div class="post-meta">
                    <!-- 
                        Author: <a itemprop="author" rel="author" href="/">Zeesain Tsui</a>
                     -->

                    
                        <span class="post-time">
                        <a href="#">November 12, 2019</a>
                        </span>
                    
                    
                        <span class="post-category">
                        &nbsp;&nbsp;
                        
                            <a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
                        
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <p>该版本的 Cheatsheet 由其他版本精简而来，旨在提供一个日常使用 Docker 时的速查手册。</p>
<a id="more"></a>

<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#%E6%A3%80%E6%9F%A5%E7%89%88%E6%9C%AC">检查版本</a></li>
<li><a href="#%E5%AE%89%E8%A3%85">安装</a></li>
<li><a href="#%E5%AE%B9%E5%99%A8container">容器(Containers)</a></li>
<li><a href="#%E9%95%9C%E5%83%8Fimages">镜像(Images)</a></li>
<li><a href="#%E7%BD%91%E7%BB%9Cnetworks">网络(Networks)</a></li>
<li><a href="#%E4%BB%93%E7%AE%A1%E4%B8%AD%E5%BF%83%E5%92%8C%E4%BB%93%E5%BA%93registry--repository">仓管中心和仓库(Registry &amp; Repository)</a></li>
<li><a href="#dockerfile">Dockerfile</a></li>
<li><a href="#%E5%B1%82layers">层(Layers)</a></li>
<li><a href="#%E9%93%BE%E6%8E%A5links">链接(Links)</a></li>
<li><a href="#%E5%8D%B7%E6%A0%87volumes">卷标(Volumes)</a></li>
<li><a href="#%E6%9A%B4%E9%9C%B2%E7%AB%AF%E5%8F%A3exposing-ports">暴露端口(Exposing Ports)</a></li>
<li><a href="#%E5%AE%89%E5%85%A8security">安全</a></li>
<li><a href="#%E5%B0%8F%E8%B4%B4%E5%A3%AB">小贴士</a></li>
</ul>
<h2 id="检查版本"><a href="#检查版本" class="headerlink" title="检查版本"></a>检查版本</h2><p>时刻关注你当前正在使用的 Docker 版本是十分重要的，这能够帮助你了解可用的特性。同时，可以让你在查找镜像时选择使用的版本。接下来让我们看看如何操作。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/version/"><code>docker version</code></a> 查看你正在运行的 Docker 版本。</li>
</ul>
<p>获取 Docker 服务版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version --format &#39;&#123;&#123;.Server.Version&#125;&#125;&#39;</span><br></pre></td></tr></table></figure>
<p>你也可以输出原始的 JSON 数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version --format &#39;&#123;&#123;json .&#125;&#125;&#39;</span><br></pre></td></tr></table></figure>


<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>Docker 官方提供了快速、易用的安装脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https:&#x2F;&#x2F;get.docker.com&#x2F; | sh</span><br></pre></td></tr></table></figure>
<p>如果你不想执行一个不明不白的 Shell 脚本，那么请看 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/installation/linux/">安装说明</a>，选择你在用的发行版本。</p>
<p>如果你是一个 Docker 超新手，那么你应当先去看看 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/getstarted/">系列教程</a>。</p>
<h2 id="容器-Container"><a href="#容器-Container" class="headerlink" title="容器 (Container)"></a>容器 (Container)</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ul>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/create"><code>docker create</code></a> 创建容器但不启动它。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/rename/"><code>docker rename</code></a> 用于重命名容器。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/run"><code>docker run</code></a> 一键创建并同时启动该容器。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/rm"><code>docker rm</code></a> 删除容器。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/update/"><code>docker update</code></a> 调整容器的资源限制。</li>
</ul>
<p>通常情况下，不使用任何命令行选项启动一个容器，该容器将会立即启动并停止。若需保持其运行，你可以使用 <code>docker run -td container_id</code> 命令。选项 <code>-t</code> 表示分配一个 pseudo-TTY 会话，<code>-d</code> 表示自动将容器与终端分离（也就是说在后台运行容器，并输出容器 ID）。</p>
<p>如果你需要一个临时容器，可使用 <code>docker run --rm</code> 会在容器停止之后删除它。</p>
<p>如果你需要映射宿主机 (host) 的目录到 Docker 容器内，可使用 <code>docker run -v $HOSTDIR:$DOCKERDIR</code>。详见 <a href="#%E5%8D%B7%E6%A0%87volumes">卷标(Volumes)</a> 一节。</p>
<p>如果你想同时删除与容器相关联的卷标，那么在删除容器的时候必须包含 <code>-v</code> 选项，像这样 <code>docker rm -v</code>。</p>
<p>从 Docker 1.10 起，其内置一套各容器独立的 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/admin/logging/overview/">日志引擎</a>，每个容器可以独立使用。你可以使用 <code>docker run --log-driver=syslog</code> 来自定义日志引擎（例如以上的 <code>syslog</code>）。</p>
<h3 id="启动和停止"><a href="#启动和停止" class="headerlink" title="启动和停止"></a>启动和停止</h3><ul>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/start"><code>docker start</code></a> 启动已存在的容器。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/stop"><code>docker stop</code></a> 停止运行中的容器。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/restart"><code>docker restart</code></a> 重启容器。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/pause/"><code>docker pause</code></a> 暂停运行中的容器，将其「冻结」在当前状态。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/unpause/"><code>docker unpause</code></a> 结束容器暂停状态。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/wait"><code>docker wait</code></a> 阻塞地等待某个运行中的容器直到停止。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/kill"><code>docker kill</code></a> 向运行中的容器发送 SIGKILL 指令。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/attach"><code>docker attach</code></a> 连接到运行中的容器。</li>
</ul>
<p>如果你想将容器的端口 (ports) 暴露至宿主机，请见 <a href="#%E6%9A%B4%E9%9C%B2%E7%AB%AF%E5%8F%A3exposing-ports">暴露端口</a> 一节。</p>
<p>关于 Docker 实例崩溃后的重启策略，详见 <a target="_blank" rel="noopener" href="http://container42.com/2014/09/30/docker-restart-policies/">本文</a>。</p>
<h4 id="CPU-限制"><a href="#CPU-限制" class="headerlink" title="CPU 限制"></a>CPU 限制</h4><p>你可以限制 CPU 资源占用，无论是指定百分比，或是特定核心数。</p>
<p>设置 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/run/#/cpu-share-constraint"><code>cpu-shares</code></a></p>
<p> – 1024 表示 100% CPU，512 为 50% CPU：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -ti --c 512 agileek&#x2F;cpuset-test</span><br></pre></td></tr></table></figure>
<p>设置 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/run/#/cpuset-constraint"><code>cpuset-cpus</code></a> ，使用特定 CPU 内核</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -ti --cpuset-cpus&#x3D;0,4,6 agileek&#x2F;cpuset-test</span><br></pre></td></tr></table></figure>
<p>注意，Docker 在容器内仍然能够 <strong>看到</strong> 全部 CPU – 它仅仅是不使用全部而已。</p>
<h4 id="内存限制"><a href="#内存限制" class="headerlink" title="内存限制"></a>内存限制</h4><p>设置 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/run/#/user-memory-constraints">内存限制</a>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -m 300M ubuntu:14.04 &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>
<h4 id="能力-Capabilities"><a href="#能力-Capabilities" class="headerlink" title="能力 (Capabilities)"></a>能力 (Capabilities)</h4><p>Linux 的 Capability 可以通过使用 <code>cap-add</code> 和 <code>cap-drop</code> 设置，这有助于提高安全性。</p>
<p>如需要挂载基于 FUSE 的文件系统，你需要结合 <code>--cap-add</code> 和 <code>--device</code> 使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -it --cap-add SYS_ADMIN --device &#x2F;dev&#x2F;fuse sshfs</span><br></pre></td></tr></table></figure>
<p>授予对某个设备的访问权限：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --device&#x3D;&#x2F;dev&#x2F;ttyUSB0 debian bash</span><br></pre></td></tr></table></figure>
<p>授予对所有设备的访问权限：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --privileged -v &#x2F;dev&#x2F;bus&#x2F;usb:&#x2F;dev&#x2F;bus&#x2F;usb debian bash</span><br></pre></td></tr></table></figure>
<h3 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h3><ul>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/ps"><code>docker ps</code></a> 查看运行中的所有容器。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/logs"><code>docker logs</code></a> 从容器中读取日志。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/inspect"><code>docker inspect</code></a> 查看某个容器的所有信息（包括 IP 地址）。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/events"><code>docker events</code></a> 从容器中获取事件（events）。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/port"><code>docker port</code></a> 查看容器的公开端口。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/top"><code>docker top</code></a> 查看容器中活动进程。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/stats"><code>docker stats</code></a> 查看容器的资源使用量统计信息。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/diff"><code>docker diff</code></a> 查看容器文件系统中存在改动的文件。</li>
</ul>
<p><code>docker ps -a</code> 将显示所有容器，包括运行中和已停止的。</p>
<p><code>docker stats --all</code> 同样将显示所有容器，默认仅显示运行中的容器。</p>
<h3 id="导入-导出"><a href="#导入-导出" class="headerlink" title="导入 / 导出"></a>导入 / 导出</h3><ul>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/cp"><code>docker cp</code></a> 在容器和本地文件系统之间复制文件或目录。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/export"><code>docker export</code></a> 将容器的文件系统打包为归档文件流 (tarball archive stream) 并输出至标准输出 (STDOUT)。</li>
</ul>
<h3 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h3><ul>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/exec"><code>docker exec</code></a> 在容器内执行命令。</li>
</ul>
<p>例如，进入正在运行的 <code>foo</code> 容器，并连接 (attach) 到一个新的 Shell 进程：<code>docker exec -it foo /bin/bash</code>。</p>
<h2 id="镜像-Images"><a href="#镜像-Images" class="headerlink" title="镜像 (Images)"></a>镜像 (Images)</h2><h3 id="生命周期-1"><a href="#生命周期-1" class="headerlink" title="生命周期"></a>生命周期</h3><ul>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/images"><code>docker images</code></a> 查看所有镜像。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/import"><code>docker import</code></a> 从归档文件创建镜像。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/build"><code>docker build</code></a> 从 Dockerfile 创建镜像。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/commit"><code>docker commit</code></a> 为容器创建镜像，如果容器正在运行则会临时暂停。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/rmi"><code>docker rmi</code></a> 删除镜像。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/load"><code>docker load</code></a> 从标准输入 (STDIN) 加载归档包 (tar archive) 作为镜像，包括镜像本身和标签 (tags, 0.7 起)。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/save"><code>docker save</code></a> 将镜像打包为归档包，并输出至标准输出 (STDOUT)，包括所有的父层、标签和版本 (parent layers, tags, versions, 0.7 起)。</li>
</ul>
<h3 id="其它信息"><a href="#其它信息" class="headerlink" title="其它信息"></a>其它信息</h3><ul>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/history"><code>docker history</code></a> 查看镜像的历史记录。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/tag"><code>docker tag</code></a> 给镜像打标签命名（本地或者仓库均可）。</li>
</ul>
<h3 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h3><p>虽然你可以用 <code>docker rmi</code> 命令来删除指定的镜像，不过有个名为 <a target="_blank" rel="noopener" href="https://github.com/spotify/docker-gc">docker-gc</a> 的工具，它可以以一种安全的方式，清理掉那些不再被任何容器使用的镜像。Docker 1.13 起，使用 <code>docker image prune</code> 亦可删除未使用的镜像。</p>
<h3 id="加载-保存镜像"><a href="#加载-保存镜像" class="headerlink" title="加载 / 保存镜像"></a>加载 / 保存镜像</h3><p>从文件中加载镜像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load &lt; my_image.tar.gz</span><br></pre></td></tr></table></figure>
<p>保存既有镜像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save my_image:my_tag | gzip &gt; my_image.tar.gz</span><br></pre></td></tr></table></figure>
<h3 id="导入-导出容器"><a href="#导入-导出容器" class="headerlink" title="导入 / 导出容器"></a>导入 / 导出容器</h3><p>从文件中导入容器镜像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat my_container.tar.gz | docker import - my_image:my_tag</span><br></pre></td></tr></table></figure>
<p>导出既有容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export my_container | gzip &gt; my_container.tar.gz</span><br></pre></td></tr></table></figure>
<h3 id="加载已保存的镜像-与-导入已导出为镜像的容器-的不同"><a href="#加载已保存的镜像-与-导入已导出为镜像的容器-的不同" class="headerlink" title="加载已保存的镜像 与 导入已导出为镜像的容器 的不同"></a>加载已保存的镜像 与 导入已导出为镜像的容器 的不同</h3><p>通过 <code>load</code> 命令来加载镜像，会创建一个新的镜像，并继承原镜像的所有历史。<br>通过 <code>import</code> 将容器作为镜像导入，也会创建一个新的镜像，但并不包含原镜像的历史，因此会比使用 <code>load</code> 方式生成的镜像更小。</p>
<h2 id="网络-Networks"><a href="#网络-Networks" class="headerlink" title="网络 (Networks)"></a>网络 (Networks)</h2><p>Docker 具备 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/userguide/networking/">网络</a> 功能。我并不是很了解它，所以这是一个扩展本文的好地方。这是一种无需暴露端口即可实现 Docker 容器间通信的好方法。</p>
<h3 id="生命周期-2"><a href="#生命周期-2" class="headerlink" title="生命周期"></a>生命周期</h3><ul>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/network_create/"><code>docker network create</code></a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/network_rm/"><code>docker network rm</code></a></li>
</ul>
<h3 id="其它信息-1"><a href="#其它信息-1" class="headerlink" title="其它信息"></a>其它信息</h3><ul>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/network_ls/"><code>docker network ls</code></a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/network_inspect/"><code>docker network inspect</code></a></li>
</ul>
<h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><ul>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/network_connect/"><code>docker network connect</code></a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/network_disconnect/"><code>docker network disconnect</code></a></li>
</ul>
<p>你可以 <a target="_blank" rel="noopener" href="https://blog.jessfraz.com/post/ips-for-all-the-things/">为容器指定 IP 地址</a>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 使用你自己的子网和网关创建一个桥接网络</span><br><span class="line">docker network create --subnet 203.0.113.0&#x2F;24 --gateway 203.0.113.254 iptastic</span><br><span class="line"></span><br><span class="line"># 基于以上创建的网络，运行一个 Nginx 容器并指定 IP</span><br><span class="line">$ docker run --rm -it --net iptastic --ip 203.0.113.2 nginx</span><br><span class="line"></span><br><span class="line"># 在其他地方使用 CURL 访问这个 IP（假设该 IP 为公网）</span><br><span class="line">$ curl 203.0.113.2</span><br></pre></td></tr></table></figure>


<h2 id="仓管中心和仓库-Registry-amp-Repository"><a href="#仓管中心和仓库-Registry-amp-Repository" class="headerlink" title="仓管中心和仓库 (Registry &amp; Repository)"></a>仓管中心和仓库 (Registry &amp; Repository)</h2><p>仓库 (repository) 是 <em>被托管 (hosted)</em> 的已命名镜像 (tagged images) 的集合，这组镜像用于构建容器文件系统。</p>
<p>仓管中心 (registry) 则是 <em>托管服务 (host)</em> – 用于存储仓库并提供 HTTP API，以便 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/tutorials/dockerrepos/">管理仓库的上传和下载</a>。</p>
<p>Docker 官方托管着自己的 <a target="_blank" rel="noopener" href="https://hub.docker.com/">仓管中心</a>，包含着数量众多的仓库。不过话虽如此，这个仓管中心 <a target="_blank" rel="noopener" href="https://titanous.com/posts/docker-insecurity">并没有很好地验证镜像</a>，所以如果你担心安全问题的话，请尽量避免使用它。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/login"><code>docker login</code></a> 登入仓管中心。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/logout"><code>docker logout</code></a> 登出仓管中心。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/search"><code>docker search</code></a> 从仓管中心检索镜像。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/pull"><code>docker pull</code></a> 从仓管中心拉取镜像到本地。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/push"><code>docker push</code></a> 从本地推送镜像到仓管中心。</li>
</ul>
<h3 id="本地仓管中心"><a href="#本地仓管中心" class="headerlink" title="本地仓管中心"></a>本地仓管中心</h3><p>使用 <a target="_blank" rel="noopener" href="https://github.com/docker/distribution">docker distribution</a> 项目搭建本地的仓管中心。</p>
<p>科学上网后，也可以看看 <a target="_blank" rel="noopener" href="https://groups.google.com/a/dockerproject.org/forum/#!forum/distribution">Google+ Group</a>。</p>
<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>当你执行 <code>docker build</code> 时，Docker 将会根据 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/">配置文件</a> 启动 Docker 容器。远优于使用 <code>docker commit</code>。</p>
<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><ul>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/#dockerignore-file">.dockerignore</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/#from">FROM</a> 为其他指令设置基础镜像 (Base Image)。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/#maintainer-deprecated">MAINTAINER (deprecated - use LABEL instead)</a> 为生成的镜像设置作者字段。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/#run">RUN</a> 在当前镜像的基础上生成一个新层并执行命令。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/#cmd">CMD</a> 设置容器默认执行命令。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/#expose">EXPOSE</a> 告知 Docker 容器在运行时所要监听的网络端口。注意：并没有实际上将端口设置为可访问。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/#env">ENV</a> 设置环境变量。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/#add">ADD</a> 将文件、目录或远程文件复制到容器中。缓存无效。请尽量用 <code>COPY</code> 代替 <code>ADD</code>。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/#copy">COPY</a> 将文件或文件夹复制到容器中。注意：将使用 ROOT 用户复制文件，故无论 USER / WORKDIR 指令如何配置，你都需要手动修改其所有者（<code>chown</code>），<code>ADD</code> 也是一样。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/#entrypoint">ENTRYPOINT</a> 将容器设为可执行的。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/#volume">VOLUME</a> 在容器内部创建挂载点 (mount point) 指向外部挂载的卷标或其他容器。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/#user">USER</a> 设置随后执行 RUN / CMD / ENTRYPOINT 命令的用户名。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/#workdir">WORKDIR</a> 设置工作目录 (working directory)。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/#arg">ARG</a> 定义编译时 (build-time) 变量。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/#onbuild">ONBUILD</a> 添加触发指令，当该镜像被作为其他镜像的基础镜像时该指令会被触发。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/#stopsignal">STOPSIGNAL</a> 设置停止容器时，向容器内发送的系统调用信号 (system call signal)。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/config/labels-custom-metadata/">LABEL</a> 将键值对元数据 (key/value metadata) 应用到镜像、容器或是守护进程。</li>
</ul>
<h2 id="层-Layers"><a href="#层-Layers" class="headerlink" title="层 (Layers)"></a>层 (Layers)</h2><p>Docker 的版本化文件系统是基于层的。就像 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/userguide/storagedriver/imagesandcontainers/">Git 的提交或文件变更系统</a> 一样。</p>
<h2 id="链接-Links"><a href="#链接-Links" class="headerlink" title="链接 (Links)"></a>链接 (Links)</h2><p>链接 (links) <a target="_blank" rel="noopener" href="https://docs.docker.com/userguide/dockerlinks/">通过 TCP/IP 端口</a> 实现 Docker 容器之间的通讯。<a target="_blank" rel="noopener" href="https://blogs.atlassian.com/2013/11/docker-all-the-things-at-atlassian-automation-and-wiring/">Atlassian</a> 展示了可用的例子。你还可以 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/userguide/networking/default_network/dockerlinks/#/updating-the-etchosts-file">通过主机名 (hostname) 链接</a>。</p>
<p>在某种意义上来说，该特性已经被 <a target="_blank" rel="noopener" href="https://docs.docker.com/network/">自定义网络</a> 所替代。</p>
<p>注意: 如果你希望容器之间<strong>只</strong>通过链接进行通讯，在启动 Docker 守护进程时，请使用 <code>-icc=false</code> 来禁用内部进程通讯。</p>
<p>假设你有一个名为 CONTAINER 的容器（通过 <code>docker run --name CONTAINER</code> 指定）并且在 Dockerfile 中，暴露了一个端口:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE 1337</span><br></pre></td></tr></table></figure>
<p>然后，我们创建另外一个名为 LINKED 的容器:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --link CONTAINER:ALIAS --name LINKED user&#x2F;wordpress</span><br></pre></td></tr></table></figure>
<p>然后 CONTAINER 暴露的端口和别名将会以如下的环境变量出现在 LINKED 中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ALIAS_PORT_1337_TCP_PORT</span><br><span class="line">$ALIAS_PORT_1337_TCP_ADDR</span><br></pre></td></tr></table></figure>
<p>那么你便可以通过这种方式来连接它了。</p>
<p>使用 <code>docker rm --link</code> 即可删除链接。</p>
<p>通常，Docker 容器（亦可理解为「服务」）之间的链接，是「服务发现」的一个子集。如果你打算在生产中大规模使用 Docker，这将是一个很大的问题。请参阅<a target="_blank" rel="noopener" href="https://www.digitalocean.com/community/tutorials/the-docker-ecosystem-service-discovery-and-distributed-configuration-stores">The Docker Ecosystem: Service Discovery and Distributed Configuration Stores</a> 获取更多信息。</p>
<h2 id="卷标-Volumes"><a href="#卷标-Volumes" class="headerlink" title="卷标(Volumes)"></a>卷标(Volumes)</h2><p>Docker 的卷标 (volumes) 是 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/tutorials/dockervolumes/">独立的文件系统</a>。它们并非必须连接到特定的容器上。</p>
<h3 id="生命周期-3"><a href="#生命周期-3" class="headerlink" title="生命周期"></a>生命周期</h3><ul>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/volume_create/"><code>docker volume create</code></a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/volume_rm/"><code>docker volume rm</code></a></li>
</ul>
<h3 id="信息-1"><a href="#信息-1" class="headerlink" title="信息"></a>信息</h3><ul>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/volume_ls/"><code>docker volume ls</code></a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/volume_inspect/"><code>docker volume inspect</code></a></li>
</ul>
<p>卷标在不能使用链接（只有 TCP/IP）的情况下非常有用。例如，如果你有两个 Docker 实例需要通讯并在文件系统上留下记录。</p>
<p>你可以一次性将其挂载到多个 docker 容器上，通过 <code>docker run --volumes-from</code>。</p>
<p>因为卷标是独立的文件系统，它们通常被用于存储各容器之间的瞬时状态。也就是说，你可以配置一个无状态临时容器，关掉之后，当你有第二个这种临时容器实例的时候，你可以从上一次保存的状态继续执行。</p>
<p>查看 <a target="_blank" rel="noopener" href="http://crosbymichael.com/advanced-docker-volumes.html">卷标进阶</a> 来获取更多细节。<a target="_blank" rel="noopener" href="http://container42.com/2014/11/03/docker-indepth-volumes/">Container42</a> 非常有用。</p>
<p>你可以 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/tutorials/dockervolumes/#mount-a-host-directory-as-a-data-volume">将宿主 MacOS 的文件夹映射为 Docker 卷标</a>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v &#x2F;Users&#x2F;wsargent&#x2F;myapp&#x2F;src:&#x2F;src</span><br></pre></td></tr></table></figure>
<p>你也可以用远程 NFS 卷标，如果你觉得你 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/tutorials/dockervolumes/#/mount-a-shared-storage-volume-as-a-data-volume">有足够勇气</a>。</p>
<p>还可以考虑运行一个纯数据容器，像 <a target="_blank" rel="noopener" href="http://container42.com/2013/12/16/persistent-volumes-with-docker-container-as-volume-pattern/">这里</a> 所说的那样，提供可移植数据。</p>
<p>记得，<a href="#%E5%B0%86%E6%96%87%E4%BB%B6%E6%8C%82%E8%BD%BD%E4%B8%BA%E5%8D%B7%E6%A0%87">文件也可以被挂载为卷标</a>。</p>
<h2 id="暴露端口-Exposing-ports"><a href="#暴露端口-Exposing-ports" class="headerlink" title="暴露端口 (Exposing ports)"></a>暴露端口 (Exposing ports)</h2><p>通过宿主容器暴露输入端口相当 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/run/#expose-incoming-ports">繁琐但有效的</a>。</p>
<p>例如使用 <code>-p</code> 将容器端口映射到宿主端口上（只使用本地主机 (localhost) 接口）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 127.0.0.1:$HOSTPORT:$CONTAINERPORT --name CONTAINER -t someimage</span><br></pre></td></tr></table></figure>
<p>你可以使用 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/#expose">EXPOSE</a> 告知 Docker，该容器在运行时监听指定的端口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE &lt;CONTAINERPORT&gt;</span><br></pre></td></tr></table></figure>
<p>但是注意 EXPOSE 并不会直接暴露端口，你需要用参数 <code>-p</code> 。比如说你要在 localhost 上暴露容器的端口:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A DOCKER -p tcp --dport &lt;LOCALHOSTPORT&gt; -j DNAT --to-destination &lt;CONTAINERIP&gt;:&lt;PORT&gt;</span><br></pre></td></tr></table></figure>
<p>如果你是在 Virtualbox 中运行 Docker，那么你需要配置端口转发 (forward the port)。使用 <a target="_blank" rel="noopener" href="https://docs.vagrantup.com/v2/networking/forwarded_ports.html">forwarded_port</a> 在 Vagrantfile 上配置暴露的端口范围，这样你就可以动态地映射了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  (49000..49900).each do |port|</span><br><span class="line">    config.vm.network :forwarded_port, :host &#x3D;&gt; port, :guest &#x3D;&gt; port</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>如果你忘记了将什么端口映射到宿主机上的话，可使用 <code>docker port</code> 查看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker port CONTAINER $CONTAINERPORT</span><br></pre></td></tr></table></figure>


<h2 id="安全-Security"><a href="#安全-Security" class="headerlink" title="安全(Security)"></a>安全(Security)</h2><p>这节准备讨论一些关于 Docker 安全性的问题。Docker 官方文档 <a target="_blank" rel="noopener" href="https://docs.docker.com/articles/security/">安全</a> 页面讲述了更多细节。</p>
<p>首先第一件事：Docker 是有 root 权限的。如果你在 <code>docker</code> 组，那么你就有 <a target="_blank" rel="noopener" href="https://web.archive.org/web/20161226211755/http://reventlov.com/advisories/using-the-docker-command-to-root-the-host">root 权限</a>。如果你将 Docker 的 Unix Socket 暴露给容器，意味着你赋予了容器 <a target="_blank" rel="noopener" href="https://www.lvh.io/posts/dont-expose-the-docker-socket-not-even-to-a-container.html">宿主机 root 权限</a>。</p>
<p>Docker 不应当作为唯一的防御措施。你应当使其更加安全可靠。</p>
<p>为了更好地理解容器暴露了什么，可参阅由 <a target="_blank" rel="noopener" href="https://twitter.com/dyn___">Aaron Grattafiori</a> 编写的 <a target="_blank" rel="noopener" href="https://www.nccgroup.trust/globalassets/our-research/us/whitepapers/2016/april/ncc_group_understanding_hardening_linux_containers-1-1.pdf">Understanding and Hardening Linux Containers</a>。这是一个完整全面且包含大量链接和脚注的容器问题指南，介绍了许多有用的内容。即使你已经加固过容器，以下的安全提示依然十分有帮助，但并不能代替理解的过程。</p>
<h3 id="安全提示"><a href="#安全提示" class="headerlink" title="安全提示"></a>安全提示</h3><p>为了最大的安全性，你应当考虑在虚拟机上运行 Docker。这是直接从 Docker 安全团队拿来的资料 – <a target="_blank" rel="noopener" href="http://www.slideshare.net/jpetazzo/linux-containers-lxc-docker-and-security">slides</a> / <a target="_blank" rel="noopener" href="http://www.projectatomic.io/blog/2014/08/is-it-safe-a-look-at-docker-and-security-from-linuxcon/">notes</a>。之后，可使用 AppArmor、seccomp、SELinux、grsec 等来 <a target="_blank" rel="noopener" href="http://linux-audit.com/docker-security-best-practices-for-your-vessel-and-containers/">限制容器的权限</a>。更多细节，请查阅 <a target="_blank" rel="noopener" href="https://blog.docker.com/2016/02/docker-engine-1-10-security/">Docker 1.10 security features</a>。</p>
<p>Docker 镜像 ID 属于 <a target="_blank" rel="noopener" href="https://medium.com/@quayio/your-docker-image-ids-are-secrets-and-its-time-you-treated-them-that-way-f55e9f14c1a4">敏感信息</a> 所以它不应该向外界公开。请将它们当作密码来对待。</p>
<p>阅读由 <a target="_blank" rel="noopener" href="https://github.com/konstruktoid">Thomas Sjögren</a> 编写的 <a target="_blank" rel="noopener" href="https://github.com/konstruktoid/Docker/blob/master/Security/CheatSheet.adoc">Docker Security Cheat Sheet</a>：关于加固容器的不错的建议。</p>
<p>查看 <a target="_blank" rel="noopener" href="https://github.com/docker/docker-bench-security">Docker 安全测试脚本</a>，下载 <a target="_blank" rel="noopener" href="https://blog.docker.com/2015/05/understanding-docker-security-and-best-practices/">最佳实践白皮书</a>。</p>
<p>你应当远离使用非稳定版本 grsecurity / pax 的内核，比如 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Alpine_Linux">Alpine Linux</a>。如果在产品中用了 grsecurity，那么你应该考虑使用有 <a target="_blank" rel="noopener" href="https://grsecurity.net/business_support.php">商业支持</a> 的 <a target="_blank" rel="noopener" href="https://grsecurity.net/announce.php">稳定版本</a>，就像你对待 RedHat 那样。虽然要 $200 每月，但对于你的运维预算来说不值一提。</p>
<p>从 Docker 1.11 开始，你可以轻松的限制在容器中可用的进程数，以防止 fork 炸弹。 这要求 Linux 内核 &gt;= 4.3，并且要在内核配置中打开 CGROUP_PIDS=y。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --pids-limit&#x3D;64</span><br></pre></td></tr></table></figure>
<p>同时，你也可以限制进程再获取新权限。该功能是 Linux 内核从 3.5 版本开始就拥有的。你可以从 <a target="_blank" rel="noopener" href="http://www.projectatomic.io/blog/2016/03/no-new-privs-docker/">这篇博客</a> 中阅读到更多关于这方面的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --security-opt&#x3D;no-new-privileges</span><br></pre></td></tr></table></figure>
<p>关闭内部进程通讯：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -d --icc&#x3D;false --iptables</span><br></pre></td></tr></table></figure>
<p>设置容器为只读：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --read-only</span><br></pre></td></tr></table></figure>
<p>通过 hashsum 来验证卷标：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull debian@sha256:a25306f3850e1bd44541976aa7b5fd0a29be</span><br></pre></td></tr></table></figure>
<p>设置卷标为只读：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v $(pwd)&#x2F;secrets:&#x2F;secrets:ro debian</span><br></pre></td></tr></table></figure>
<p>在 Dockerfile 中定义用户并以该用户运行，避免在容器中以 ROOT 身份操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN groupadd -r user &amp;&amp; useradd -r -g user user</span><br><span class="line">USER user</span><br></pre></td></tr></table></figure>
<h3 id="用户命名空间-User-Namespaces"><a href="#用户命名空间-User-Namespaces" class="headerlink" title="用户命名空间(User Namespaces)"></a>用户命名空间(User Namespaces)</h3><p>还可以通过使用 <a target="_blank" rel="noopener" href="https://s3hh.wordpress.com/2013/07/19/creating-and-using-containers-without-privilege/">用户命名空间</a> – 自 1.10 版本起已内置，但默认并未启用。</p>
<p>要在 Ubuntu 15.10 中启用用户命名空间 (remap the userns)，请 <a target="_blank" rel="noopener" href="https://raesene.github.io/blog/2016/02/04/Docker-User-Namespaces/">跟着这篇博客的例子</a> 来做。</p>
<h2 id="小贴士"><a href="#小贴士" class="headerlink" title="小贴士"></a>小贴士</h2><h3 id="清理-1"><a href="#清理-1" class="headerlink" title="清理"></a>清理</h3><p>最新的 <a target="_blank" rel="noopener" href="https://github.com/docker/docker/pull/26108">数据管理命令</a> 已在 Docker 1.13 实现：</p>
<ul>
<li><code>docker system prune</code></li>
<li><code>docker volume prune</code></li>
<li><code>docker network prune</code></li>
<li><code>docker container prune</code></li>
<li><code>docker image prune</code></li>
</ul>
<h3 id="df-命令"><a href="#df-命令" class="headerlink" title="df 命令"></a>df 命令</h3><p><code>docker system df</code> 将显示当前 Docker 各部分占用的磁盘空间。</p>
<h3 id="Heredoc-声明-Docker-容器"><a href="#Heredoc-声明-Docker-容器" class="headerlink" title="Heredoc 声明 Docker 容器"></a>Heredoc 声明 Docker 容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker build -t htop - &lt;&lt; EOF</span><br><span class="line">FROM alpine</span><br><span class="line">RUN apk --no-cache add htop</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<h3 id="最近一次的容器-ID"><a href="#最近一次的容器-ID" class="headerlink" title="最近一次的容器 ID"></a>最近一次的容器 ID</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alias dl&#x3D;&#39;docker ps -l -q&#39;</span><br><span class="line">docker run ubuntu echo hello world</span><br><span class="line">docker commit $(dl) helloworld</span><br></pre></td></tr></table></figure>
<h3 id="带命令的提交（需要-Dockerfile）"><a href="#带命令的提交（需要-Dockerfile）" class="headerlink" title="带命令的提交（需要 Dockerfile）"></a>带命令的提交（需要 Dockerfile）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -run&#x3D;&#39;&#123;&quot;Cmd&quot;:[&quot;postgres&quot;, &quot;-too -many -opts&quot;]&#125;&#39; $(dl) postgres</span><br></pre></td></tr></table></figure>
<h3 id="获取-IP-地址"><a href="#获取-IP-地址" class="headerlink" title="获取 IP 地址"></a>获取 IP 地址</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect $(dl) | grep -wm1 IPAddress | cut -d &#39;&quot;&#39; -f 4</span><br></pre></td></tr></table></figure>
<p>或使用 <a target="_blank" rel="noopener" href="https://stedolan.github.io/jq/">jq</a>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect $(dl) | jq -r &#39;.[0].NetworkSettings.IPAddress&#39;</span><br></pre></td></tr></table></figure>
<p>或使用 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/inspect">go 模板</a>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect -f &#39;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&#39; &lt;container_name&gt;</span><br></pre></td></tr></table></figure>
<p>或在通过 Dockerfile 构建镜像时，通过构建参数 (build argument) 传入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DOCKER_HOST_IP&#x3D;&#96;ifconfig | grep -E &quot;([0-9]&#123;1,3&#125;\.)&#123;3&#125;[0-9]&#123;1,3&#125;&quot; | grep -v 127.0.0.1 | awk &#39;&#123; print $2 &#125;&#39; | cut -f2 -d: | head -n1&#96;</span><br><span class="line">echo DOCKER_HOST_IP &#x3D; $DOCKER_HOST_IP</span><br><span class="line">docker build \</span><br><span class="line">  --build-arg ARTIFACTORY_ADDRESS&#x3D;$DOCKER_HOST_IP </span><br><span class="line">  -t sometag \</span><br><span class="line">  some-directory&#x2F;</span><br></pre></td></tr></table></figure>
<h3 id="获取端口映射"><a href="#获取端口映射" class="headerlink" title="获取端口映射"></a>获取端口映射</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect -f &#39;&#123;&#123;range $p, $conf :&#x3D; .NetworkSettings.Ports&#125;&#125; &#123;&#123;$p&#125;&#125; -&gt; &#123;&#123;(index $conf 0).HostPort&#125;&#125; &#123;&#123;end&#125;&#125;&#39; &lt;containername&gt;</span><br></pre></td></tr></table></figure>
<h3 id="通过正则匹配容器"><a href="#通过正则匹配容器" class="headerlink" title="通过正则匹配容器"></a>通过正则匹配容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i in $(docker ps -a | grep &quot;REGEXP_PATTERN&quot; | cut -f1 -d&quot; &quot;); do echo $i; done&#96;</span><br></pre></td></tr></table></figure>
<h3 id="获取环境变量配置"><a href="#获取环境变量配置" class="headerlink" title="获取环境变量配置"></a>获取环境变量配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm ubuntu env</span><br></pre></td></tr></table></figure>
<h3 id="强行终止运行中的容器"><a href="#强行终止运行中的容器" class="headerlink" title="强行终止运行中的容器"></a>强行终止运行中的容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker kill $(docker ps -q)</span><br></pre></td></tr></table></figure>
<h3 id="删除所有容器（强行删除！无论容器运行或停止）"><a href="#删除所有容器（强行删除！无论容器运行或停止）" class="headerlink" title="删除所有容器（强行删除！无论容器运行或停止）"></a>删除所有容器（强行删除！无论容器运行或停止）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f $(docker ps -qa)</span><br></pre></td></tr></table></figure>
<h3 id="删除旧容器"><a href="#删除旧容器" class="headerlink" title="删除旧容器"></a>删除旧容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a | grep &#39;weeks ago&#39; | awk &#39;&#123;print $1&#125;&#39; | xargs docker rm</span><br></pre></td></tr></table></figure>
<h3 id="删除已停止的容器"><a href="#删除已停止的容器" class="headerlink" title="删除已停止的容器"></a>删除已停止的容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -v &#96;docker ps -a -q -f status&#x3D;exited&#96;</span><br></pre></td></tr></table></figure>
<h3 id="停止并删除容器"><a href="#停止并删除容器" class="headerlink" title="停止并删除容器"></a>停止并删除容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop $(docker ps -aq) &amp;&amp; docker rm -v $(docker ps -aq)</span><br></pre></td></tr></table></figure>
<h3 id="删除无用-dangling-的镜像"><a href="#删除无用-dangling-的镜像" class="headerlink" title="删除无用 (dangling) 的镜像"></a>删除无用 (dangling) 的镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi $(docker images -q -f dangling&#x3D;true)</span><br></pre></td></tr></table></figure>
<h3 id="删除所有镜像"><a href="#删除所有镜像" class="headerlink" title="删除所有镜像"></a>删除所有镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi $(docker images -q)</span><br></pre></td></tr></table></figure>
<h3 id="删除无用-dangling-的卷标"><a href="#删除无用-dangling-的卷标" class="headerlink" title="删除无用 (dangling) 的卷标"></a>删除无用 (dangling) 的卷标</h3><p>Docker 1.9 版本起：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume rm $(docker volume ls -q -f dangling&#x3D;true)</span><br></pre></td></tr></table></figure>
<p>1.9.0 中，参数 <code>dangling=false</code> 居然 <em>没</em> 用 - 它会被忽略然后列出所有的卷标。</p>
<h3 id="查看镜像依赖"><a href="#查看镜像依赖" class="headerlink" title="查看镜像依赖"></a>查看镜像依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images -viz | dot -Tpng -o docker.png</span><br></pre></td></tr></table></figure>
<h3 id="Docker-容器瘦身"><a href="#Docker-容器瘦身" class="headerlink" title="Docker 容器瘦身"></a>Docker 容器瘦身</h3><ul>
<li>在某层 (RUN layer) 清理 APT</li>
</ul>
<p>这应当和其他 apt 命令在同一层中完成。<br>否则，前面的层将会保持原有信息，而你的镜像则依旧臃肿。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUN &#123;apt commands&#125; \</span><br><span class="line">  &amp;&amp; apt-get clean \  </span><br><span class="line">  &amp;&amp; rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;* &#x2F;tmp&#x2F;* &#x2F;var&#x2F;tmp&#x2F;*</span><br></pre></td></tr></table></figure>
<ul>
<li>压缩镜像<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ID&#x3D;$(docker run -d image-name &#x2F;bin&#x2F;bash)</span><br><span class="line">docker export $ID | docker import – flat-image-name</span><br></pre></td></tr></table></figure></li>
<li>备份<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ID&#x3D;$(docker run -d image-name &#x2F;bin&#x2F;bash)</span><br><span class="line">(docker export $ID | gzip -c &gt; image.tgz)</span><br><span class="line">gzip -dc image.tgz | docker import - flat-image-name</span><br></pre></td></tr></table></figure>
<h3 id="监视运行中容器的系统资源利用率"><a href="#监视运行中容器的系统资源利用率" class="headerlink" title="监视运行中容器的系统资源利用率"></a>监视运行中容器的系统资源利用率</h3></li>
</ul>
<p>检查某个容器的 CPU、内存以及网络 I/O 使用情况，你可以：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stats &lt;container&gt;</span><br></pre></td></tr></table></figure>
<p>按 ID 列出所有容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stats $(docker ps -q)</span><br></pre></td></tr></table></figure>
<p>按名称列出所有容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stats $(docker ps --format &#39;&#123;&#123;.Names&#125;&#125;&#39;)</span><br></pre></td></tr></table></figure>
<p>按指定镜像名称列出所有容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a -f ancestor&#x3D;ubuntu</span><br></pre></td></tr></table></figure>
<p>删除所有未标签命名 (untagged) 的容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi $(docker images | grep “^” | awk &#39;&#123;split($0,a,&quot; &quot;); print a[3]&#125;&#39;)</span><br></pre></td></tr></table></figure>
<p>通过正则匹配删除指定容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a | grep wildfly | awk &#39;&#123;print $1&#125;&#39; | xargs docker rm -f</span><br></pre></td></tr></table></figure>
<p>删除所有已退出 (exited) 的容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f $(docker ps -a | grep Exit | awk &#39;&#123; print $1 &#125;&#39;)</span><br></pre></td></tr></table></figure>
<h3 id="将文件挂载为卷标"><a href="#将文件挂载为卷标" class="headerlink" title="将文件挂载为卷标"></a>将文件挂载为卷标</h3><p>文件也可以被挂载为卷标。例如你可以仅仅注入单个配置文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从容器复制文件</span></span><br><span class="line">docker run --rm httpd cat /usr/<span class="built_in">local</span>/apache2/conf/httpd.conf &gt; httpd.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑文件</span></span><br><span class="line">vim httpd.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载修改后的配置启动容器</span></span><br><span class="line">docker run --rm -ti -v <span class="string">&quot;<span class="variable">$PWD</span>/httpd.conf:/usr/local/apache2/conf/httpd.conf:ro&quot;</span> -p <span class="string">&quot;80:80&quot;</span> httpd</span><br></pre></td></tr></table></figure>
<p><img src="https://images.unsplash.com/photo-1566928224408-18392a67fbc7?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1867&q=80"></p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span></span>
                        <span>Zeesain Tsui</span>
                    </p>
                
                
                
                    <p class="copyright-item">
                        <span></span>
                        <span>Copyright (c) 2020 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span class="tag">
                    
                    
                        <a href="/tags/%E6%8A%80%E6%9C%AF/"># 技术</a>
                    
                        <a href="/tags/Docker/"># Docker</a>
                    
                        
                </span>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2019/20191124%20%E9%98%B2%E6%AD%A2%E8%BF%87%E6%8B%9F%E5%90%88%E5%92%8C%E6%8F%90%E9%AB%98%E6%B3%9B%E5%8C%96%E8%83%BD%E5%8A%9B%E7%9A%84%E6%8A%80%E5%B7%A7/">防止过拟合和提高泛化能力的技巧</a>
            
            
            <a class="next" rel="next" href="/2019/20191105%20%E6%9C%80%E8%BF%91%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B7%A5%E4%BD%9C%E5%B0%8F%E7%BB%93/">最近的一些工作小结</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 2020 By Zeesain Tsui with ❤</span>
    </div>
</footer>


<!-- <script type="text/javascript" color="0,0,0" opacity='0.4' zIndex="-2" count="100" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script> -->

    </div>
</body>
</html>
